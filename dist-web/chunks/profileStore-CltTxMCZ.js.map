{"version":3,"file":"profileStore-CltTxMCZ.js","sources":["../../src/state/profileStore.ts"],"sourcesContent":["import { create } from 'zustand';\r\nimport { ipc } from '../lib/ipc-typed';\r\nimport { ipcEvents, ProfileInfo, ProfilePolicy, ProfilePolicyBlockedEvent } from '../lib/ipc-events';\r\n\r\ntype ProfilesMap = Record<string, ProfileInfo>;\r\ntype PoliciesMap = Record<string, ProfilePolicy>;\r\n\r\ntype ProfileState = {\r\n  profiles: ProfileInfo[];\r\n  profilesById: ProfilesMap;\r\n  policies: PoliciesMap;\r\n  activeProfileId: string;\r\n  loading: boolean;\r\n  lastPolicyBlock?: {\r\n    action: ProfilePolicyBlockedEvent['action'];\r\n    profileId: string;\r\n    timestamp: number;\r\n  };\r\n  loadProfiles: (force?: boolean) => Promise<void>;\r\n  setActiveProfile: (profileId: string) => Promise<void>;\r\n  markPolicyMessageRead: () => void;\r\n};\r\n\r\nconst mergeProfiles = (existing: ProfilesMap, incoming: ProfileInfo[]): ProfilesMap => {\r\n  const next = { ...existing };\r\n  for (const profile of incoming) {\r\n    next[profile.id] = profile;\r\n  }\r\n  return next;\r\n};\r\n\r\nconst useProfileStore = create<ProfileState>((set, get) => ({\r\n  profiles: [],\r\n  profilesById: {},\r\n  policies: {},\r\n  activeProfileId: 'default',\r\n  loading: false,\r\n\r\n  async loadProfiles(force = false) {\r\n    const { loading } = get();\r\n    if (loading && !force) {\r\n      return;\r\n    }\r\n\r\n    set({ loading: true });\r\n    try {\r\n      const [list, active] = await Promise.all([\r\n        ipc.profiles.list(),\r\n        ipc.profiles.getActive(),\r\n      ]);\r\n\r\n      const updatedProfilesById = mergeProfiles(get().profilesById, list);\r\n      if (active) {\r\n        updatedProfilesById[active.id] = active;\r\n      }\r\n\r\n      const policyUpdates: PoliciesMap = { ...get().policies };\r\n      for (const profile of list) {\r\n        if (profile.policy) {\r\n          policyUpdates[profile.id] = profile.policy;\r\n        }\r\n      }\r\n\r\n      if (active?.id && !policyUpdates[active.id]) {\r\n        try {\r\n          const policy = await ipc.profiles.getPolicy(active.id);\r\n          policyUpdates[active.id] = policy;\r\n        } catch (error) {\r\n          console.warn('[Profiles] Failed to fetch policy for active profile', error);\r\n        }\r\n      }\r\n\r\n      set({\r\n        profiles: list,\r\n        profilesById: updatedProfilesById,\r\n        policies: policyUpdates,\r\n        activeProfileId: active?.id ?? 'default',\r\n      });\r\n    } catch (error) {\r\n      console.error('[Profiles] Failed to load profiles', error);\r\n    } finally {\r\n      set({ loading: false });\r\n    }\r\n  },\r\n\r\n  async setActiveProfile(profileId: string) {\r\n    try {\r\n      const result = await ipc.profiles.setActive(profileId);\r\n      const policy = result.policy ?? (await ipc.profiles.getPolicy(result.id));\r\n      const nextProfilesById = mergeProfiles(get().profilesById, [result]);\r\n      set((state) => ({\r\n        activeProfileId: result.id,\r\n        profilesById: nextProfilesById,\r\n        profiles: state.profiles.map((profile) =>\r\n          profile.id === result.id ? { ...profile, ...result } : profile\r\n        ),\r\n        policies: {\r\n          ...state.policies,\r\n          [result.id]: policy,\r\n        },\r\n      }));\r\n    } catch (error) {\r\n      console.error('[Profiles] Failed to activate profile', error);\r\n      throw error;\r\n    }\r\n  },\r\n\r\n  markPolicyMessageRead() {\r\n    set({ lastPolicyBlock: undefined });\r\n  },\r\n}));\r\n\r\nipcEvents.on<{ profileId: string; profile: ProfileInfo }>('profiles:active', (payload) => {\r\n  if (!payload?.profileId) return;\r\n  const state = useProfileStore.getState();\r\n  const { profileId, profile } = payload;\r\n  const policy = profile.policy;\r\n\r\n  useProfileStore.setState((prev) => ({\r\n    activeProfileId: profileId,\r\n    profilesById: mergeProfiles(prev.profilesById, [profile]),\r\n    profiles: prev.profiles.some((p) => p.id === profileId)\r\n      ? prev.profiles.map((p) => (p.id === profileId ? { ...p, ...profile } : p))\r\n      : [...prev.profiles, profile],\r\n    policies: policy\r\n      ? {\r\n          ...prev.policies,\r\n          [profileId]: policy,\r\n        }\r\n      : prev.policies,\r\n  }));\r\n\r\n  if (!state.policies[profileId] && !policy) {\r\n    ipc.profiles\r\n      .getPolicy(profileId)\r\n      .then((policyResponse) => {\r\n        useProfileStore.setState((prev) => ({\r\n          policies: {\r\n            ...prev.policies,\r\n            [profileId]: policyResponse,\r\n          },\r\n        }));\r\n      })\r\n      .catch((error) => console.warn('[Profiles] Failed to refresh policy', error));\r\n  }\r\n});\r\n\r\nipcEvents.on<ProfilePolicyBlockedEvent>('profiles:policy-blocked', (payload) => {\r\n  if (!payload?.profileId || !payload?.action) return;\r\n  useProfileStore.setState({\r\n    lastPolicyBlock: {\r\n      action: payload.action,\r\n      profileId: payload.profileId,\r\n      timestamp: Date.now(),\r\n    },\r\n  });\r\n});\r\n\r\nexport function ensureProfilesLoaded() {\r\n  void useProfileStore.getState().loadProfiles();\r\n}\r\n\r\nexport { useProfileStore };\r\n\r\n"],"names":["mergeProfiles","existing","incoming","next","profile","useProfileStore","create","set","get","force","loading","list","active","ipc","updatedProfilesById","policyUpdates","policy","error","profileId","result","nextProfilesById","state","ipcEvents","payload","prev","p","policyResponse"],"mappings":"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"}