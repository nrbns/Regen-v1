{"version":3,"mappings":"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","names":["getEnvVar","key","define_process_env_default","__vite_import_meta_env__","isDevEnv","nodeMode","isTauriRuntime","isElectronRuntime","maybeIpc","isWebMode","backendAvailable","offlineSince","listeners","RETRY_INTERVAL_MS","isBackendAvailable","canAttemptBackendRequest","markBackendAvailable","listener","error","markBackendUnavailable","reason","onBackendStatusChange","API_BASE_URL","apiRequest","endpoint","options","method","body","headers","params","url","searchParams","requestOptions","response","errorText","contentType","result","textResult","tabsApi","payload","id","sessionsApi","sessionId","agentApi","dsl","systemApi","researchApi","query","jobId","tradeApi","symbol","interval","limit","order","sessionStateApi","apiClient","SESSION_KEY","SAVE_DEBOUNCE_MS","saveTimer","saveSession","state","serialized","loadSession","raw","parsed","clearSession","debouncedSaveSession","getSessionSummary","session","eventLog","reducers","currentState","stateSnapshots","SNAPSHOT_INTERVAL","undoStack","MAX_UNDO_STACK","STORAGE_KEY","MAX_PERSISTED_EVENTS","persistenceEnabled","persistenceInitialized","initPersistence","stored","eventsToLoad","index","replayEvents","persistEventLog","eventsToPersist","snapshotsObj","registerReducer","name","reducer","dispatchEvent","event","fullEvent","getCurrentState","getStateAtEventIndex","snapshotIndex","snapshotState","snapIndex","snapState","i","getStateAtTimestamp","timestamp","e","getEventLog","getEventsByType","type","undo","redo","exportEventLog","importEventLog","data","tabReducer","tabs","performanceReducer","metrics","policyReducer","aiOptimizationReducer","resourceReducer","resources","registerDefaultReducers","MAX_HISTORY_SIZE","MAX_SNAPSHOTS","SNAPSHOT_EVERY","MAX_DIFF_ENTRIES","MAX_DIFF_DEPTH","RedixRuntime","__publicField","eventType","handler","prevState","loggedEvent","logEvent","nextState","diff","computeStateDiff","runtimeEvent","events","undoEventLog","redoEventLog","snapshot","typeListeners","log","prev","next","diffs","walkDiff","path","depth","currentPath","prevValue","nextValue","isPlainObject","prevString","nextString","value","Redix","dispatch","MODES","m","isModeEnabled","modeId","toastObj","message","toastLib","toastId","promise","messages","toastFn","toast","useAppStore","create","set","get","mode","currentMode","modeConfig","__vitePreload","track","n","useTabsStore","tabsStore","modeTabs","defaultUrl","newTab","ipc","ModeManager","open","TAB_GROUP_COLORS","generateId","MAX_RECENTLY_CLOSED","MAX_TABS","persist","tab","newState","appMode","indexTab","t","useAgentStreamStore","agentStreamStore","previousTabs","sorted","previous","a","b","activeCandidate","remaining","nextActive","finalTabs","finalActiveId","updates","updatedTabs","updatedTab","item","first","rest","closedId","entry","otherTabs","pinnedTabs","unpinnedTabs","currentGroups","group","color","tabId","groupId","newUrl","history","historyIndex","newHistory","newEntry","newIndex","useContainerStore","containers","unique","acc","container","c","activeExists","IS_DEV","DEFAULT_PROFILE_POLICY","createDefaultProfile","FALLBACK_CHANNELS","req","tabsState","getTabsStore","previousActiveId","title","deriveTitleFromUrl","reportedMissingChannels","getFallback","channel","request","factory","noteFallback","mapIpcToHttp","schema","normalized","ipcReady","ipcReadyResolvers","handleIpcReady","resolvers","resolve","k","pollCount","maxPolls","pollInterval","expectsIPC","waitForIPC","timeout","startTime","timeoutId","r","resolver","checkInterval","hasIpc","allResolvers","ipcCall","fullChannel","userAgent","userAgentHasElectron","hasElectronRuntime","hasWindowIpc","isRegularBrowser","isElectron","isReady","fallback","ipcBridge","ipcRenderer","ch","force","fullscreen","input","err","capMB","enabled","callback","_event","containerId","timeoutPromise","_","reject","permission","origin","offsets","config","proxy","profileId","optIn","metric","unit","feature","action","category","values","task","taskId","observations","confirmSteps","context","streamId","question","documentIds","topK","maxResults","language","headless","urls","text","prompt","screenshot","domain","signal","filename","size","intervalMinutes","workspace","hostname","format","sources","threshold","filePath","cluster1Id","cluster2Id","pattern","workspaceId","note","runId","bundleId","fromUrl","toUrl","sourceUrl","targetUrl","exportType","noteText","command","commands","document","intervals","pluginId","verifySignature","metadata","trusted","snapshotId","quality","target","status","passphrase","consentId","filter","notes","highlights","file","reader","base64","documentId","login","password","accountId","symbols","orderId","quantity","provider","onChunk","createDefaults","dataKeys","useSettingsStore","_get","searchEngine","partial","defaults","persisted","persistedState","goal","delta","detectProvider","getApiKey","keys","getBaseUrl","baseUrls","getDefaultModel","models","callOpenAI","_apiKey","_baseUrl","model","latency","callAnthropic","callMistral","apiKey","baseUrl","callOllama","sendPrompt","providers","lastError","detectedProvider","AIEngine","PQueue","onStream","backendResult","localResult","base","timeoutMs","controller","combinedSignal","combined","decoder","buffer","tokens","done","json","errorPayload","errorMessage","token","existing","recent","states","last","trackAction","aiEngine","LOOP_STATE_KEY","MAX_SAVED_LOOPS","SAVE_INTERVAL_MS","saveLoopState","loadAllLoopStates","currentRunId","fullState","updated","s","trimmed","loadLoopState","resumeLoop","store","line","deleteLoopState","filtered","saveInterval","startAutoSave","stopAutoSave","checkForCrashedLoops","all","now","CRASH_THRESHOLD_MS","loop","timeSinceLastSave","handoffToN8n","workflowId","workflowUrl","isLoop","loopInterval","maxIterations","callN8nWorkflow","runN8nWorkflowLoop","call","results","lastResult","DEFAULT_LIMIT","useAgentMemoryStore","agentId","pool","StreamingOrchestrator","wsUrl","urlObj","clientId","ws","messageId","firstId","eventSource","lines","maxAttempts","delay","streamingOrchestrator","chunkText","maxChunkSize","overlap","minChunkSize","preserveSentences","chunks","currentIndex","startOffset","endOffset","sentenceEnd","findSentenceEnd","wordCount","offset","sentenceEnders","lastMatch","match","extractAndChunkPage","totalWords","getPartialSummary","maxChunks","chunksToSummarize","summaries","summaryPromises","chunk","LocalCache","maxCacheSize","maxQueueSize","_reject","db","queueStore","cacheRequest","entries","queueRequest","items","oldestKey","tags","keysToDelete","tag","memoryUsage","localCache","BaseAgent","TradeAgent","actions","cacheKey","ResearchAgent","partialSummary","DevAgent","DocumentAgent","WorkflowAgent","workflow","step","steps","urlMatch","MultiAgentSystem","agent","tasks","multiAgentSystem","alphabet","nanoid","length","idx","defaultRedixAsk","defaultFetch","init","safeUrl","agentTools","_ctx","semanticSearchMemories","processMemoryEvent","res","ctx","headerPairs","fetchTradeQuote","quote","MockImageEngine","imageUrls","scanResult","memoryResults","graphData","nodes","edges","content","summaryPrompt","summary","_input","listN8nWorkflows","workflows","w","AgentRuntime","cb","runRecord","recentRuns","env","run","lower","kw","toolset","toolId","tool","missing","cap","overrides","memoryExecutor","redixExecutor","redixAnswer","buildContextPrompt","saveExecutor","tickerRegex","potentialSymbols","tradeDataContext","tradeTool","successfulQuotes","changeSign","enhancedPrompt","output","storeError","MemoryStoreInstance","agentRuntime","useAgentExecutor","useCallback"],"ignoreList":[],"sources":["../../src/lib/env.ts","../../src/lib/backend-status.ts","../../src/lib/api-client.ts","../../src/services/session.ts","../../src/core/redix/event-log.ts","../../src/core/redix/reducers.ts","../../src/core/redix/runtime.ts","../../src/config/modes.ts","../../src/utils/toast.ts","../../src/state/appStore.ts","../../src/state/tabsStore.ts","../../src/state/containerStore.ts","../../src/lib/ipc-typed.ts","../../src/state/settingsStore.ts","../../src/state/agentStreamStore.ts","../../src/core/llm/adapter.ts","../../src/core/ai/engine.ts","../../src/core/agents/loopResume.ts","../../src/core/agents/handoff.ts","../../src/state/agentMemoryStore.ts","../../src/core/streaming/orchestrator.ts","../../src/core/extraction/chunker.ts","../../src/core/cache/localCache.ts","../../src/core/agents/multiAgentSystem.ts","../../src/core/utils/nanoid.ts","../../src/core/agents/tools.ts","../../src/core/agents/runtime.ts","../../src/core/agents/useAgentRuntime.ts"],"sourcesContent":["export const getEnvVar = (key: string): string | undefined => {\n  if (typeof process !== 'undefined' && process?.env && process.env[key] !== undefined) {\n    return process.env[key];\n  }\n  if (\n    typeof import.meta !== 'undefined' &&\n    (import.meta as any).env &&\n    (import.meta as any).env[key] !== undefined\n  ) {\n    return (import.meta as any).env[key];\n  }\n  return undefined;\n};\n\nexport const isDevEnv = (): boolean => {\n  const nodeMode = getEnvVar('NODE_ENV');\n  if (nodeMode) {\n    return nodeMode === 'development';\n  }\n  const viteMode = getEnvVar('MODE');\n  return viteMode === 'development';\n};\n\nexport const isTauriRuntime = (): boolean => {\n  if (typeof window === 'undefined') {\n    return false;\n  }\n  // Check for Tauri runtime\n  return !!(window as any).__TAURI__;\n};\n\nexport const isElectronRuntime = (): boolean => {\n  if (typeof window === 'undefined') {\n    return false;\n  }\n\n  // Check for Tauri first (Tauri also has IPC)\n  if (isTauriRuntime()) {\n    return false; // Tauri is not Electron\n  }\n\n  // Check for IPC bridge (most reliable indicator)\n  const maybeIpc = (window as any).ipc;\n  if (maybeIpc && typeof maybeIpc.invoke === 'function') {\n    return true;\n  }\n\n  // Check for legacy electron API\n  if ((window as any).electron) {\n    return true;\n  }\n\n  // Check for user agent (fallback)\n  if (typeof navigator !== 'undefined' && navigator.userAgent) {\n    return navigator.userAgent.includes('Electron');\n  }\n\n  return false;\n};\n\n/**\n * Check if running in pure web mode (not Electron, not Tauri)\n * This is the authoritative check for whether backend services are available\n */\nexport const isWebMode = (): boolean => {\n  if (typeof window === 'undefined') {\n    return false; // SSR - assume not web mode\n  }\n\n  // Check for Electron runtime\n  if (isElectronRuntime()) {\n    return false;\n  }\n\n  // Check for Tauri runtime\n  if (isTauriRuntime()) {\n    return false;\n  }\n\n  // If neither Electron nor Tauri, we're in web mode\n  return true;\n};\n","let backendAvailable = true;\nlet offlineSince: number | null = null;\nconst listeners = new Set<(online: boolean) => void>();\nconst RETRY_INTERVAL_MS = 8000;\n\nexport function isBackendAvailable(): boolean {\n  return backendAvailable;\n}\n\nexport function canAttemptBackendRequest(): boolean {\n  if (backendAvailable) {\n    return true;\n  }\n  if (offlineSince === null) {\n    return true;\n  }\n  return Date.now() - offlineSince >= RETRY_INTERVAL_MS;\n}\n\nexport function markBackendAvailable() {\n  if (!backendAvailable) {\n    backendAvailable = true;\n    offlineSince = null;\n    listeners.forEach(listener => {\n      try {\n        listener(true);\n      } catch (error) {\n        console.warn('[BackendStatus] Listener failed while marking online:', error);\n      }\n    });\n  }\n}\n\nexport function markBackendUnavailable(reason?: unknown) {\n  if (backendAvailable) {\n    backendAvailable = false;\n  }\n  offlineSince = Date.now();\n\n  // Only warn if backend is expected (Electron/Tauri mode)\n  // In web mode, backend offline is expected and shouldn't spam console\n  if (reason && process.env.NODE_ENV !== 'production') {\n    const isWebMode =\n      typeof window !== 'undefined' && !(window as any).__ELECTRON__ && !(window as any).__TAURI__;\n\n    if (!isWebMode) {\n      console.warn('[BackendStatus] Backend marked offline:', reason);\n    }\n  }\n  listeners.forEach(listener => {\n    try {\n      listener(false);\n    } catch (error) {\n      console.warn('[BackendStatus] Listener failed while marking offline:', error);\n    }\n  });\n}\n\nexport function onBackendStatusChange(listener: (online: boolean) => void) {\n  listeners.add(listener);\n  return () => listeners.delete(listener);\n}\n","/**\n * HTTP API Client for Regen\n *\n * This replaces Electron IPC with HTTP calls to the Fastify backend.\n * Used during Electron  Tauri migration and web fallback.\n */\n\nimport {\n  canAttemptBackendRequest,\n  markBackendAvailable,\n  markBackendUnavailable,\n} from './backend-status';\n\n// CATEGORY C FIX: Read API base URL from .env (Vite env variables)\nconst API_BASE_URL =\n  typeof window !== 'undefined'\n    ? (window as any).__API_BASE_URL ||\n      import.meta.env.VITE_API_BASE_URL ||\n      import.meta.env.VITE_APP_API_URL ||\n      'http://127.0.0.1:4000'\n    : import.meta.env.VITE_API_BASE_URL ||\n      import.meta.env.VITE_APP_API_URL ||\n      'http://127.0.0.1:4000';\n\ninterface RequestOptions {\n  method?: 'GET' | 'POST' | 'PUT' | 'DELETE';\n  body?: unknown;\n  headers?: Record<string, string>;\n  params?: Record<string, string>;\n}\n\nimport { isWebMode } from './env';\n\nasync function apiRequest<T>(endpoint: string, options: RequestOptions = {}): Promise<T> {\n  // Skip all backend requests in web mode - no backend available\n  if (isWebMode()) {\n    // In web mode, return a rejected promise that won't log errors\n    // This prevents connection attempts and error spam in console\n    return Promise.reject(new Error('Backend not available in web mode'));\n  }\n\n  const { method = 'GET', body, headers = {}, params } = options;\n\n  let url = `${API_BASE_URL}${endpoint}`;\n\n  // Add query parameters\n  if (params) {\n    const searchParams = new URLSearchParams(params);\n    url += `?${searchParams.toString()}`;\n  }\n\n  const requestOptions: RequestInit = {\n    method,\n    headers: {\n      'Content-Type': 'application/json',\n      ...headers,\n    },\n  };\n\n  if (body && (method === 'POST' || method === 'PUT')) {\n    requestOptions.body = JSON.stringify(body);\n  }\n\n  if (!canAttemptBackendRequest()) {\n    throw new Error('Backend offline');\n  }\n\n  try {\n    const response = await fetch(url, requestOptions);\n\n    if (!response.ok) {\n      const errorText = await response.text();\n      throw new Error(`API request failed: ${response.statusText} - ${errorText}`);\n    }\n\n    // Handle empty responses\n    const contentType = response.headers.get('content-type');\n    if (contentType && contentType.includes('application/json')) {\n      const result = await response.json();\n      markBackendAvailable();\n      return result;\n    }\n\n    const textResult = (await response.text()) as unknown as T;\n    markBackendAvailable();\n    return textResult;\n  } catch (error) {\n    // Only log errors if backend is expected (not in pure web mode)\n    // In web mode, backend connection failures are expected\n    const isWebMode =\n      typeof window !== 'undefined' && !(window as any).__ELECTRON__ && !(window as any).__TAURI__;\n\n    if (!isWebMode) {\n      console.error(`[API Client] Request failed for ${endpoint}:`, error);\n    }\n    markBackendUnavailable(error);\n    throw error;\n  }\n}\n\n// Tabs API\nexport const tabsApi = {\n  list: () => apiRequest<Array<any>>('/api/tabs'),\n  create: (payload: { url: string; profileId?: string }) =>\n    apiRequest<{ id: string }>('/api/tabs', { method: 'POST', body: payload }),\n  close: (id: string) => apiRequest<{ success: boolean }>(`/api/tabs/${id}`, { method: 'DELETE' }),\n  activate: (id: string) =>\n    apiRequest<{ success: boolean }>(`/api/tabs/${id}/activate`, { method: 'POST' }),\n  navigate: (payload: { id: string; url: string }) =>\n    apiRequest<{ success: boolean }>(`/api/tabs/${payload.id}/navigate`, {\n      method: 'POST',\n      body: { url: payload.url },\n    }),\n  goBack: (id: string) =>\n    apiRequest<{ success: boolean }>(`/api/tabs/${id}/back`, { method: 'POST' }),\n  goForward: (id: string) =>\n    apiRequest<{ success: boolean }>(`/api/tabs/${id}/forward`, { method: 'POST' }),\n  reload: (id: string, options?: { hard?: boolean }) =>\n    apiRequest<{ success: boolean }>(`/api/tabs/${id}/reload`, {\n      method: 'POST',\n      body: options || {},\n    }),\n  stop: (id: string) =>\n    apiRequest<{ success: boolean }>(`/api/tabs/${id}/stop`, { method: 'POST' }),\n  createWithProfile: (payload: { accountId: string; url: string }) =>\n    apiRequest<{ id: string }>('/api/tabs', {\n      method: 'POST',\n      body: { url: payload.url, profileId: payload.accountId },\n    }),\n  overlayStart: () =>\n    apiRequest<{ success: boolean }>('/api/tabs/overlay/start', { method: 'POST' }),\n  overlayGetPick: () => apiRequest<any>('/api/tabs/overlay/pick'),\n  overlayClear: () =>\n    apiRequest<{ success: boolean }>('/api/tabs/overlay/clear', { method: 'POST' }),\n  predictiveGroups: () =>\n    apiRequest<{ groups: any[]; prefetch: any[]; summary?: any }>('/api/tabs/predictive-groups'),\n};\n\n// Sessions API\nexport const sessionsApi = {\n  list: () => apiRequest<Array<any>>('/api/sessions'),\n  create: (payload: { name: string; profileId?: string; color?: string }) =>\n    apiRequest<{ id: string }>('/api/sessions', { method: 'POST', body: payload }),\n  getActive: () => apiRequest<{ id: string } | null>('/api/sessions/active'),\n  setActive: (sessionId: string) =>\n    apiRequest<{ success: boolean }>(`/api/sessions/${sessionId}/activate`, { method: 'POST' }),\n  get: (sessionId: string) => apiRequest<any>(`/api/sessions/${sessionId}`),\n  delete: (sessionId: string) =>\n    apiRequest<{ success: boolean }>(`/api/sessions/${sessionId}`, { method: 'DELETE' }),\n  update: (payload: { sessionId: string; name?: string; color?: string }) =>\n    apiRequest<{ success: boolean }>(`/api/sessions/${payload.sessionId}`, {\n      method: 'PUT',\n      body: payload,\n    }),\n  getPartition: (sessionId: string) =>\n    apiRequest<{ partition: string }>(`/api/sessions/${sessionId}/partition`),\n};\n\n// Agent API\nexport const agentApi = {\n  start: (dsl: any) =>\n    apiRequest<{ id: string }>('/api/agent/start', { method: 'POST', body: { dsl } }),\n  status: (id: string) => apiRequest<any>(`/api/agent/status/${id}`),\n  runs: () => apiRequest<Array<any>>('/api/agent/runs'),\n  executeSkill: (payload: { skill: string; args: any }) =>\n    apiRequest<any>('/api/agent/execute-skill', { method: 'POST', body: payload }),\n  ask: (payload: { prompt: string; sessionId?: string; stream?: boolean }) =>\n    apiRequest<{ response: string }>('/api/agent/ask', { method: 'POST', body: payload }),\n  query: (payload: { query: string; mode?: string }) =>\n    apiRequest<any>('/api/agent/query', { method: 'POST', body: payload }),\n};\n\n// System API\nexport const systemApi = {\n  getStatus: () => apiRequest<{ cpu: number; memory: number; disk?: any }>('/api/system/status'),\n  ping: () => apiRequest<string>('/api/ping'),\n};\n\n// Profiles API\nexport const profilesApi = {\n  list: () => apiRequest<Array<any>>('/api/profiles'),\n  get: (id: string) => apiRequest<any>(`/api/profiles/${id}`),\n  getActive: () => apiRequest<any>('/api/profiles/active'),\n  getPolicy: (id: string) => apiRequest<any>(`/api/profiles/${id}/policy`),\n  updateProxy: (payload: { id: string; proxy: any }) =>\n    apiRequest<{ success: boolean }>(`/api/profiles/${payload.id}/proxy`, {\n      method: 'PUT',\n      body: payload.proxy,\n    }),\n  delete: (id: string) =>\n    apiRequest<{ success: boolean }>(`/api/profiles/${id}`, { method: 'DELETE' }),\n};\n\n// Storage API\nexport const storageApi = {\n  getSetting: (key: string) => apiRequest<any>(`/api/storage/settings/${key}`),\n  listWorkspaces: () => apiRequest<Array<any>>('/api/storage/workspaces'),\n  listDownloads: () => apiRequest<Array<any>>('/api/storage/downloads'),\n  listAccounts: () => apiRequest<Array<any>>('/api/storage/accounts'),\n};\n\n// History API\nexport const historyApi = {\n  list: (limit?: number) =>\n    apiRequest<Array<any>>('/api/history', {\n      params: limit ? { limit: limit.toString() } : undefined,\n    }),\n};\n\n// Research API\nexport const researchApi = {\n  query: (query: string) =>\n    apiRequest<any>('/api/research/query', { method: 'POST', body: { query } }),\n  queryEnhanced: (payload: {\n    query: string;\n    maxSources?: number;\n    includeCounterpoints?: boolean;\n    recencyWeight?: number;\n    authorityWeight?: number;\n    language?: string;\n  }) => apiRequest<any>('/api/research/enhanced', { method: 'POST', body: payload }),\n  run: (payload: {\n    query: string;\n    lang?: string;\n    mode?: 'fast' | 'deep' | 'crawl';\n    maxSources?: number;\n    clientId?: string;\n    sessionId?: string;\n    options?: {\n      maxChunks?: number;\n      model?: string;\n    };\n  }) =>\n    apiRequest<{ jobId: string; status: string; estimatedWait?: number }>('/api/research/run', {\n      method: 'POST',\n      body: payload,\n    }),\n  getStatus: (jobId: string) =>\n    apiRequest<{\n      id: string;\n      state: string;\n      progress: number;\n      result: any;\n      error: string | null;\n    }>(`/api/research/status/${jobId}`),\n};\n\n// Graph API\nexport const graphApi = {\n  add: (node: any, edges: any[] = []) =>\n    apiRequest<{ success: boolean }>('/api/graph', { method: 'POST', body: { node, edges } }),\n  get: (key: string) => apiRequest<any>(`/api/graph/${key}`),\n  all: () => apiRequest<{ nodes: any[]; edges: any[] }>('/api/graph'),\n};\n\n// Trade API\nexport const tradeApi = {\n  getQuote: (symbol: string) => apiRequest<any>(`/api/trade/quote/${symbol}`),\n  getCandles: (symbol: string, interval = '1d', limit = 50) =>\n    apiRequest<{ symbol: string; interval: string; candles: any[] }>(\n      `/api/trade/candles/${symbol}?interval=${interval}&limit=${limit}`\n    ),\n  placeOrder: (order: {\n    symbol: string;\n    quantity: number;\n    orderType: 'buy' | 'sell';\n    stopLoss?: number;\n    takeProfit?: number;\n  }) =>\n    apiRequest<{ success: boolean; orderId: string }>('/api/trade/order', {\n      method: 'POST',\n      body: order,\n    }),\n};\n\n// Ledger API\nexport const ledgerApi = {\n  add: (payload: { url: string; passage: string }) =>\n    apiRequest<{ success: boolean }>('/api/ledger', { method: 'POST', body: payload }),\n  verify: () => apiRequest<any>('/api/ledger/verify'),\n};\n\n// Recorder API\nexport const recorderApi = {\n  start: () => apiRequest<{ success: boolean }>('/api/recorder/start', { method: 'POST' }),\n  getDsl: () => apiRequest<any>('/api/recorder/dsl'),\n};\n\n// Proxy API\nexport const proxyApi = {\n  set: (rules: any) =>\n    apiRequest<{ success: boolean }>('/api/proxy', { method: 'POST', body: rules }),\n  status: () => apiRequest<{ healthy: boolean; killSwitchEnabled: boolean }>('/api/proxy/status'),\n  killSwitch: (enabled: boolean) =>\n    apiRequest<{ success: boolean }>('/api/proxy/kill-switch', {\n      method: 'POST',\n      body: { enabled },\n    }),\n};\n\n// Threats API\nexport const threatsApi = {\n  scanUrl: (url: string) =>\n    apiRequest<any>('/api/threats/scan-url', { method: 'POST', body: { url } }),\n  scanFile: (filePath: string) =>\n    apiRequest<any>('/api/threats/scan-file', { method: 'POST', body: { filePath } }),\n};\n\n// Video API\nexport const videoApi = {\n  start: (args: any) =>\n    apiRequest<{ id: string }>('/api/video/start', { method: 'POST', body: args }),\n  cancel: (id: string) =>\n    apiRequest<{ success: boolean }>(`/api/video/${id}`, { method: 'DELETE' }),\n  consent: {\n    get: () => apiRequest<boolean>('/api/video/consent'),\n    set: (value: boolean) =>\n      apiRequest<{ success: boolean }>('/api/video/consent', { method: 'POST', body: { value } }),\n  },\n};\n\n// UI API\nexport const uiApi = {\n  setRightDock: (px: number) =>\n    apiRequest<{ success: boolean }>('/api/ui/right-dock', { method: 'POST', body: { px } }),\n  setChromeOffsets: (offsets: { top?: number; bottom?: number; left?: number; right?: number }) =>\n    apiRequest<{ success: boolean }>('/api/ui/chrome-offsets', { method: 'POST', body: offsets }),\n};\n\n// Scrape API\nexport const scrapeApi = {\n  enqueue: (task: any) => apiRequest<{ id: string }>('/api/scrape', { method: 'POST', body: task }),\n  get: (id: string) => apiRequest<any>(`/api/scrape/${id}`),\n};\n\n// Summarize API - Tier 1: Unified facade (no polling needed)\nexport const summarizeApi = {\n  summarize: (payload: {\n    url?: string;\n    text?: string;\n    question?: string;\n    maxWaitSeconds?: number;\n  }) =>\n    apiRequest<{\n      summary: string;\n      answer?: string;\n      highlights?: string[];\n      model: string;\n      jobId: string;\n      sources: Array<{ url: string; jobId: string; selector: string | null }>;\n      provenance: any;\n    }>('/api/summarize', { method: 'POST', body: payload }),\n};\n\n// Session State API\nexport const sessionStateApi = {\n  checkRestore: () =>\n    apiRequest<{ available: boolean; snapshot?: any }>('/api/session/check-restore'),\n  getSnapshot: () => apiRequest<any>('/api/session/snapshot'),\n  dismissRestore: () =>\n    apiRequest<{ success: boolean }>('/api/session/dismiss-restore', { method: 'POST' }),\n  saveTabs: () =>\n    apiRequest<{ success: boolean; count: number }>('/api/session/save-tabs', { method: 'POST' }),\n  loadTabs: () => apiRequest<{ tabs: any[] }>('/api/session/load-tabs'),\n  addHistory: (payload: { url: string; title: string; typed?: boolean }) =>\n    apiRequest<{ success: boolean }>('/api/session/add-history', { method: 'POST', body: payload }),\n  getHistory: (payload: { limit?: number }) =>\n    apiRequest<{ history: any[] }>('/api/session/history', {\n      params: payload.limit ? { limit: payload.limit.toString() } : undefined,\n    }),\n  searchHistory: (payload: { query: string; limit?: number }) =>\n    apiRequest<{ results: any[] }>('/api/session/search-history', {\n      method: 'POST',\n      body: payload,\n    }),\n  saveSetting: (payload: { key: string; value: unknown }) =>\n    apiRequest<{ success: boolean }>('/api/session/save-setting', {\n      method: 'POST',\n      body: payload,\n    }),\n  getSetting: (payload: { key: string }) =>\n    apiRequest<{ value: unknown }>(`/api/session/get-setting/${payload.key}`),\n};\n\n// Export default API client\nexport default {\n  tabs: tabsApi,\n  sessions: sessionsApi,\n  agent: agentApi,\n  system: systemApi,\n  profiles: profilesApi,\n  storage: storageApi,\n  history: historyApi,\n  research: researchApi,\n  graph: graphApi,\n  ledger: ledgerApi,\n  recorder: recorderApi,\n  proxy: proxyApi,\n  threats: threatsApi,\n  video: videoApi,\n  ui: uiApi,\n  scrape: scrapeApi,\n  summarize: summarizeApi,\n  session: sessionStateApi,\n};\n","/**\r\n * Session Service - Tier 1\r\n * Handles saving and restoring browser sessions\r\n */\r\n\r\nimport type { Tab } from '../state/tabsStore';\r\nimport type { AppState } from '../state/appStore';\r\n\r\nexport type SessionState = {\r\n  tabs: Tab[];\r\n  activeTabId: string | null;\r\n  mode: AppState['mode'];\r\n  savedAt: number;\r\n};\r\n\r\nconst SESSION_KEY = 'regen_session_v1';\r\nconst SAVE_DEBOUNCE_MS = 2000; // Save 2 seconds after last change\r\n\r\nlet saveTimer: ReturnType<typeof setTimeout> | null = null;\r\n\r\n/**\r\n * Save session to localStorage\r\n */\r\nexport function saveSession(state: SessionState): void {\r\n  try {\r\n    const serialized = JSON.stringify({\r\n      ...state,\r\n      savedAt: Date.now(),\r\n    });\r\n    localStorage.setItem(SESSION_KEY, serialized);\r\n  } catch (error) {\r\n    console.error('[Session] Failed to save session:', error);\r\n  }\r\n}\r\n\r\n/**\r\n * Load session from localStorage\r\n */\r\nexport function loadSession(): SessionState | null {\r\n  try {\r\n    const raw = localStorage.getItem(SESSION_KEY);\r\n    if (!raw) return null;\r\n\r\n    const parsed = JSON.parse(raw) as SessionState;\r\n\r\n    // Validate session structure\r\n    if (!parsed.tabs || !Array.isArray(parsed.tabs)) {\r\n      return null;\r\n    }\r\n\r\n    return parsed;\r\n  } catch (error) {\r\n    console.error('[Session] Failed to load session:', error);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * Clear saved session\r\n */\r\nexport function clearSession(): void {\r\n  try {\r\n    localStorage.removeItem(SESSION_KEY);\r\n  } catch (error) {\r\n    console.error('[Session] Failed to clear session:', error);\r\n  }\r\n}\r\n\r\n/**\r\n * Debounced save - waits for quiet period before saving\r\n */\r\nexport function debouncedSaveSession(state: SessionState): void {\r\n  if (saveTimer) {\r\n    clearTimeout(saveTimer);\r\n  }\r\n\r\n  saveTimer = setTimeout(() => {\r\n    saveSession(state);\r\n    saveTimer = null;\r\n  }, SAVE_DEBOUNCE_MS);\r\n}\r\n\r\n/**\r\n * Get session summary for UI display\r\n */\r\nexport function getSessionSummary(): { tabCount: number; savedAt: number | null } | null {\r\n  const session = loadSession();\r\n  if (!session) return null;\r\n\r\n  return {\r\n    tabCount: session.tabs.length,\r\n    savedAt: session.savedAt,\r\n  };\r\n}\r\n","/**\n * Redix Event Log System\n * Append-only log with deterministic reducers and time-travel debugging\n */\n\nexport interface RedixEvent {\n  id: string;\n  type: string;\n  payload: any;\n  timestamp: number;\n  reducer?: string; // Optional reducer name for this event\n  metadata?: Record<string, any>;\n}\n\nexport interface RedixState {\n  [key: string]: any;\n}\n\nexport type Reducer = (state: RedixState, event: RedixEvent) => RedixState;\n\n// Event log (append-only)\nconst eventLog: RedixEvent[] = [];\n\n// Reducers registry\nconst reducers = new Map<string, Reducer>();\n\n// Current state (computed from log)\nlet currentState: RedixState = {};\n\n// State snapshots for time-travel (every N events)\nconst stateSnapshots = new Map<number, RedixState>(); // eventIndex -> state\nconst SNAPSHOT_INTERVAL = 50; // Create snapshot every 50 events\n\n// Undo/Redo stack\nconst undoStack: RedixEvent[] = [];\nconst MAX_UNDO_STACK = 100;\n\n// Persistence\nconst STORAGE_KEY = 'redix:event-log';\nconst MAX_PERSISTED_EVENTS = 1000; // Keep last 1000 events in storage\nlet persistenceEnabled = false;\nlet persistenceInitialized = false;\n\n/**\n * Initialize persistence (load from storage)\n */\nexport async function initPersistence(): Promise<void> {\n  if (persistenceInitialized) return;\n  persistenceInitialized = true;\n\n  try {\n    if (typeof window !== 'undefined' && window.localStorage) {\n      const stored = localStorage.getItem(STORAGE_KEY);\n      if (stored) {\n        const parsed = JSON.parse(stored);\n        if (Array.isArray(parsed.events)) {\n          // Load last N events (to avoid memory issues)\n          const eventsToLoad = parsed.events.slice(-MAX_PERSISTED_EVENTS);\n          eventLog.length = 0;\n          eventLog.push(...eventsToLoad);\n          \n          // Restore state snapshots if available\n          if (parsed.snapshots) {\n            stateSnapshots.clear();\n            for (const [index, state] of Object.entries(parsed.snapshots)) {\n              stateSnapshots.set(Number(index), state as RedixState);\n            }\n          }\n          \n          // Replay events to rebuild current state\n          replayEvents();\n          \n          console.log(`[Redix] Loaded ${eventLog.length} events from storage`);\n        }\n      }\n      persistenceEnabled = true;\n    }\n  } catch (error) {\n    console.warn('[Redix] Failed to initialize persistence:', error);\n  }\n}\n\n/**\n * Persist event log to storage\n */\nfunction persistEventLog(): void {\n  if (!persistenceEnabled) return;\n\n  try {\n    if (typeof window !== 'undefined' && window.localStorage) {\n      // Only persist last N events\n      const eventsToPersist = eventLog.slice(-MAX_PERSISTED_EVENTS);\n      \n      // Convert snapshots to plain object\n      const snapshotsObj: Record<string, RedixState> = {};\n      for (const [index, state] of stateSnapshots.entries()) {\n        snapshotsObj[index] = state;\n      }\n      \n      localStorage.setItem(STORAGE_KEY, JSON.stringify({\n        events: eventsToPersist,\n        snapshots: snapshotsObj,\n        lastUpdated: Date.now(),\n      }));\n    }\n  } catch (error) {\n    console.warn('[Redix] Failed to persist event log:', error);\n  }\n}\n\n/**\n * Register a reducer\n */\nexport function registerReducer(name: string, reducer: Reducer): void {\n  if (typeof reducer !== 'function') {\n    throw new Error(`Reducer must be a function, got ${typeof reducer}`);\n  }\n  reducers.set(name, reducer);\n}\n\n/**\n * Get registered reducer names\n */\nexport function getRegisteredReducers(): string[] {\n  return Array.from(reducers.keys());\n}\n\n/**\n * Dispatch an event (append to log and apply reducer)\n */\nexport function dispatchEvent(event: Omit<RedixEvent, 'id' | 'timestamp'>): RedixEvent {\n  const fullEvent: RedixEvent = {\n    id: `event_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,\n    timestamp: Date.now(),\n    ...event,\n  };\n\n  // Append to log\n  eventLog.push(fullEvent);\n\n  // Apply reducer if specified\n  if (fullEvent.reducer) {\n    const reducer = reducers.get(fullEvent.reducer);\n    if (reducer) {\n      currentState = reducer(currentState, fullEvent);\n    }\n  }\n\n  // Create snapshot periodically\n  if (eventLog.length % SNAPSHOT_INTERVAL === 0) {\n    stateSnapshots.set(eventLog.length - 1, { ...currentState });\n  }\n\n  // Persist to storage (debounced)\n  if (eventLog.length % 10 === 0) {\n    persistEventLog();\n  }\n\n  return fullEvent;\n}\n\n/**\n * Get current state\n */\nexport function getCurrentState(): RedixState {\n  return { ...currentState };\n}\n\n/**\n * Get state at a specific event index (time-travel)\n */\nexport function getStateAtEventIndex(index: number): RedixState {\n  if (index < 0 || index >= eventLog.length) {\n    throw new Error(`Invalid event index: ${index}`);\n  }\n\n  // Find nearest snapshot\n  let snapshotIndex = -1;\n  let snapshotState: RedixState = {};\n\n  for (const [snapIndex, snapState] of stateSnapshots.entries()) {\n    if (snapIndex <= index && snapIndex > snapshotIndex) {\n      snapshotIndex = snapIndex;\n      snapshotState = { ...snapState };\n    }\n  }\n\n  // Replay events from snapshot to target index\n  for (let i = snapshotIndex + 1; i <= index; i++) {\n    const event = eventLog[i];\n    if (event.reducer) {\n      const reducer = reducers.get(event.reducer);\n      if (reducer) {\n        snapshotState = reducer(snapshotState, event);\n      }\n    }\n  }\n\n  return snapshotState;\n}\n\n/**\n * Get state at a specific timestamp\n */\nexport function getStateAtTimestamp(timestamp: number): RedixState {\n  const index = eventLog.findIndex(e => e.timestamp > timestamp);\n  if (index === -1) {\n    return getCurrentState(); // All events are before timestamp\n  }\n  if (index === 0) {\n    return {}; // All events are after timestamp\n  }\n  return getStateAtEventIndex(index - 1);\n}\n\n/**\n * Replay all events from scratch (rebuild state)\n */\nexport function replayEvents(): RedixState {\n  currentState = {};\n  stateSnapshots.clear();\n\n  for (let i = 0; i < eventLog.length; i++) {\n    const event = eventLog[i];\n    if (event.reducer) {\n      const reducer = reducers.get(event.reducer);\n      if (reducer) {\n        currentState = reducer(currentState, event);\n      }\n    }\n\n    // Create snapshot periodically\n    if ((i + 1) % SNAPSHOT_INTERVAL === 0) {\n      stateSnapshots.set(i, { ...currentState });\n    }\n  }\n\n  return currentState;\n}\n\n/**\n * Get event log\n */\nexport function getEventLog(): RedixEvent[] {\n  return [...eventLog];\n}\n\n/**\n * Get events in a time range\n */\nexport function getEventsInRange(startTime: number, endTime: number): RedixEvent[] {\n  return eventLog.filter(e => e.timestamp >= startTime && e.timestamp <= endTime);\n}\n\n/**\n * Get events by type\n */\nexport function getEventsByType(type: string): RedixEvent[] {\n  return eventLog.filter(e => e.type === type);\n}\n\n/**\n * Undo last event (remove from log and replay)\n */\nexport function undo(): RedixState | null {\n  if (eventLog.length === 0) {\n    return null;\n  }\n\n  // Pop from event log and add to undo stack\n  const event = eventLog.pop()!;\n  undoStack.push(event);\n  \n  // Limit undo stack size\n  if (undoStack.length > MAX_UNDO_STACK) {\n    undoStack.shift();\n  }\n\n  // Replay to rebuild state\n  return replayEvents();\n}\n\n/**\n * Redo (restore last undone event)\n */\nexport function redo(): RedixState | null {\n  if (undoStack.length === 0) {\n    return null;\n  }\n\n  // Pop from undo stack and add back to event log\n  const event = undoStack.pop()!;\n  eventLog.push(event);\n\n  // Apply reducer if specified\n  if (event.reducer) {\n    const reducer = reducers.get(event.reducer);\n    if (reducer) {\n      currentState = reducer(currentState, event);\n    }\n  }\n\n  // Replay to rebuild state\n  return replayEvents();\n}\n\n/**\n * Clear event log\n */\nexport function clearEventLog(): void {\n  eventLog.length = 0;\n  stateSnapshots.clear();\n  undoStack.length = 0;\n  currentState = {};\n  persistEventLog();\n}\n\n/**\n * Get event by ID\n */\nexport function getEventById(id: string): RedixEvent | undefined {\n  return eventLog.find(e => e.id === id);\n}\n\n/**\n * Get event count\n */\nexport function getEventCount(): number {\n  return eventLog.length;\n}\n\n/**\n * Get snapshot count\n */\nexport function getSnapshotCount(): number {\n  return stateSnapshots.size;\n}\n\n/**\n * Export event log (for debugging/analysis)\n */\nexport function exportEventLog(): string {\n  return JSON.stringify({\n    events: eventLog,\n    state: currentState,\n    snapshotIndices: Array.from(stateSnapshots.keys()),\n  }, null, 2);\n}\n\n/**\n * Import event log (for debugging/analysis)\n */\nexport function importEventLog(data: string): void {\n  try {\n    const parsed = JSON.parse(data);\n    eventLog.length = 0;\n    eventLog.push(...parsed.events);\n    stateSnapshots.clear();\n    // Note: Snapshot restoration would require storing full snapshot data in export\n    // For now, snapshots are rebuilt during replay\n    replayEvents();\n  } catch (error) {\n    throw new Error(`Failed to import event log: ${error}`);\n  }\n}\n\n","/**\n * Redix Reducers\n * Deterministic state reducers for common Redix operations\n */\n\nimport { RedixState, RedixEvent, Reducer, registerReducer } from './event-log';\n\n/**\n * Tab state reducer\n */\nexport const tabReducer: Reducer = (state: RedixState, event: RedixEvent): RedixState => {\n  const tabs = state.tabs || {};\n\n  switch (event.type) {\n    case 'redix:tab:suspend':\n      return {\n        ...state,\n        tabs: {\n          ...tabs,\n          [event.payload.tabId]: {\n            ...tabs[event.payload.tabId],\n            suspended: true,\n            suspendedAt: event.timestamp,\n          },\n        },\n      };\n\n    case 'redix:tab:resume':\n      return {\n        ...state,\n        tabs: {\n          ...tabs,\n          [event.payload.tabId]: {\n            ...tabs[event.payload.tabId],\n            suspended: false,\n            resumedAt: event.timestamp,\n          },\n        },\n      };\n\n    case 'redix:tab:activate':\n      return {\n        ...state,\n        tabs: {\n          ...tabs,\n          [event.payload.tabId]: {\n            ...tabs[event.payload.tabId],\n            active: true,\n            lastActive: event.timestamp,\n          },\n        },\n        activeTabId: event.payload.tabId,\n      };\n\n    case 'redix:tab:memory':\n      return {\n        ...state,\n        tabs: {\n          ...tabs,\n          [event.payload.tabId]: {\n            ...tabs[event.payload.tabId],\n            memoryMB: event.payload.memoryMB,\n            memoryUpdatedAt: event.timestamp,\n          },\n        },\n      };\n\n    default:\n      return state;\n  }\n};\n\n/**\n * Performance metrics reducer\n */\nexport const performanceReducer: Reducer = (state: RedixState, event: RedixEvent): RedixState => {\n  const metrics = state.metrics || {};\n\n  switch (event.type) {\n    case 'redix:metrics:update':\n      return {\n        ...state,\n        metrics: {\n          ...metrics,\n          cpu: event.payload.cpu,\n          memory: event.payload.memory,\n          battery: event.payload.battery,\n          updatedAt: event.timestamp,\n        },\n      };\n\n    case 'redix:metrics:threshold':\n      return {\n        ...state,\n        metrics: {\n          ...metrics,\n          thresholds: {\n            memory: event.payload.memoryThreshold,\n            cpu: event.payload.cpuThreshold,\n            battery: event.payload.batteryThreshold,\n          },\n        },\n      };\n\n    default:\n      return state;\n  }\n};\n\n/**\n * Policy reducer\n */\nexport const policyReducer: Reducer = (state: RedixState, event: RedixEvent): RedixState => {\n  switch (event.type) {\n    case 'redix:policy:update':\n      return {\n        ...state,\n        policy: event.payload,\n        policyUpdatedAt: event.timestamp,\n      };\n\n    case 'redix:policy:mode':\n      return {\n        ...state,\n        policyMode: event.payload.mode,\n        policy: event.payload.policy,\n        policyUpdatedAt: event.timestamp,\n      };\n\n    default:\n      return state;\n  }\n};\n\n/**\n * AI-triggered optimization reducer\n */\nexport const aiOptimizationReducer: Reducer = (\n  state: RedixState,\n  event: RedixEvent\n): RedixState => {\n  switch (event.type) {\n    case 'redix:ai:optimize':\n      return {\n        ...state,\n        aiOptimizations: {\n          ...(state.aiOptimizations || {}),\n          [event.timestamp]: {\n            suggestion: event.payload.suggestion,\n            action: event.payload.action,\n            confidence: event.payload.confidence,\n            applied: event.payload.applied || false,\n          },\n        },\n        lastAIOptimization: event.timestamp,\n      };\n\n    default:\n      return state;\n  }\n};\n\n/**\n * Resource allocation reducer\n */\nexport const resourceReducer: Reducer = (state: RedixState, event: RedixEvent): RedixState => {\n  const resources = state.resources || {};\n\n  switch (event.type) {\n    case 'redix:resource:allocate':\n      return {\n        ...state,\n        resources: {\n          ...resources,\n          [event.payload.resourceId]: {\n            ...resources[event.payload.resourceId],\n            allocated: true,\n            allocatedAt: event.timestamp,\n            priority: event.payload.priority || 0,\n          },\n        },\n      };\n\n    case 'redix:resource:release':\n      return {\n        ...state,\n        resources: {\n          ...resources,\n          [event.payload.resourceId]: {\n            ...resources[event.payload.resourceId],\n            allocated: false,\n            releasedAt: event.timestamp,\n          },\n        },\n      };\n\n    default:\n      return state;\n  }\n};\n\n/**\n * Register all default reducers\n */\nexport function registerDefaultReducers(): void {\n  registerReducer('tab', tabReducer);\n  registerReducer('performance', performanceReducer);\n  registerReducer('policy', policyReducer);\n  registerReducer('ai', aiOptimizationReducer);\n  registerReducer('resource', resourceReducer);\n}\n","/**\n * Redix Runtime - Real-time orchestration & optimization engine\n * Event bus (pub/sub) for browser-wide coordination + state snapshots\n */\n\nimport {\n  RedixEvent as RedixLogEvent,\n  RedixState,\n  dispatchEvent as logEvent,\n  getCurrentState,\n  // getEventById, // Unused for now\n  // getEventCount, // Unused for now\n  getEventLog,\n  getStateAtEventIndex,\n  getStateAtTimestamp,\n  initPersistence,\n  redo as redoEventLog,\n  undo as undoEventLog,\n} from './event-log';\n\nimport { registerDefaultReducers } from './reducers';\n\nexport interface RedixStateDiffEntry {\n  path: string;\n  before: unknown;\n  after: unknown;\n}\n\nexport interface RedixSnapshot {\n  id: string;\n  eventId: string;\n  eventType: string;\n  timestamp: number;\n  state: RedixState;\n  diff: RedixStateDiffEntry[];\n}\n\nexport interface RedixDispatchEvent {\n  type: string;\n  payload?: any;\n  source?: string;\n  reducer?: string;\n  metadata?: Record<string, any>;\n}\n\nexport interface RedixEvent extends RedixLogEvent {\n  source?: string;\n  ts: number;\n  prevState?: RedixState;\n  nextState?: RedixState;\n  diff?: RedixStateDiffEntry[];\n}\n\ntype RedixListener = (event: RedixEvent) => void;\n\nconst MAX_HISTORY_SIZE = 200;\nconst MAX_SNAPSHOTS = 100;\nconst SNAPSHOT_EVERY = 5;\nconst MAX_DIFF_ENTRIES = 50;\nconst MAX_DIFF_DEPTH = 2;\n\nclass RedixRuntime {\n  private listeners: Map<string, Set<RedixListener>> = new Map();\n  private globalListeners: Set<RedixListener> = new Set();\n  private eventHistory: RedixEvent[] = [];\n  private snapshots: RedixSnapshot[] = [];\n  private initialized = false;\n  private initPromise: Promise<void> | null = null;\n  private dispatchCount = 0;\n\n  /**\n   * Ensure persistence + reducers are initialized (only once).\n   */\n  private ensureInitialized(): void {\n    if (this.initialized) return;\n    if (!this.initPromise) {\n      this.initPromise = initPersistence()\n        .catch((error) => {\n          console.warn('[Redix] Persistence init failed:', error);\n        })\n        .finally(() => {\n          try {\n            registerDefaultReducers();\n          } catch (error) {\n            console.warn('[Redix] Default reducers failed to register:', error);\n          }\n          this.initialized = true;\n          this.initPromise = null;\n        });\n    }\n  }\n\n  /**\n   * Watch for specific event types\n   */\n  watch(eventType: string | RedixListener, handler?: RedixListener): () => void {\n    if (typeof eventType === 'function') {\n      // Global listener\n      this.globalListeners.add(eventType);\n      return () => this.globalListeners.delete(eventType);\n    }\n\n    if (!handler) {\n      throw new Error('Handler required when watching specific event type');\n    }\n\n    if (!this.listeners.has(eventType)) {\n      this.listeners.set(eventType, new Set());\n    }\n    this.listeners.get(eventType)!.add(handler);\n\n    // Return unsubscribe function\n    return () => {\n      const listeners = this.listeners.get(eventType);\n      if (listeners) {\n        listeners.delete(handler);\n        if (listeners.size === 0) {\n          this.listeners.delete(eventType);\n        }\n      }\n    };\n  }\n\n  /**\n   * Dispatch an event to all listeners and capture state snapshots/diffs\n   */\n  dispatch(event: RedixDispatchEvent): RedixEvent {\n    this.ensureInitialized();\n\n    const prevState = getCurrentState();\n\n    const loggedEvent = logEvent({\n      type: event.type,\n      payload: event.payload,\n      reducer: event.reducer,\n      metadata: {\n        ...(event.metadata || {}),\n        source: event.source || event.metadata?.source,\n      },\n    });\n\n    const nextState = getCurrentState();\n    const diff = computeStateDiff(prevState, nextState);\n\n    const runtimeEvent: RedixEvent = {\n      ...loggedEvent,\n      source: event.source,\n      ts: loggedEvent.timestamp,\n      prevState,\n      nextState,\n      diff,\n    };\n\n    this.recordEvent(runtimeEvent);\n    this.maybeCaptureSnapshot(runtimeEvent);\n    this.notifyListeners(runtimeEvent);\n\n    return runtimeEvent;\n  }\n\n  /**\n   * Get recent event history\n   */\n  getHistory(eventType?: string, limit = 10): RedixEvent[] {\n    let events = this.eventHistory;\n    if (eventType) {\n      events = events.filter(e => e.type === eventType);\n    }\n    return events.slice(-limit).reverse();\n  }\n\n  /**\n   * Get current Redix state\n   */\n  getState(): RedixState {\n    return getCurrentState();\n  }\n\n  /**\n   * Time-travel to a specific event or timestamp\n   */\n  timeTravel(options: { eventId?: string; eventIndex?: number; timestamp?: number }): RedixState | null {\n    try {\n      if (options.eventId) {\n        const index = getEventLog().findIndex(e => e.id === options.eventId);\n        if (index >= 0) {\n          return getStateAtEventIndex(index);\n        }\n        return null;\n      }\n\n      if (typeof options.eventIndex === 'number') {\n        return getStateAtEventIndex(options.eventIndex);\n      }\n\n      if (typeof options.timestamp === 'number') {\n        return getStateAtTimestamp(options.timestamp);\n      }\n\n      return null;\n    } catch (error) {\n      console.error('[Redix] timeTravel failed:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Undo last event via event-log\n   */\n  undo(): RedixState | null {\n    const state = undoEventLog();\n    if (state) {\n      this.syncHistoryFromLog();\n    }\n    return state;\n  }\n\n  /**\n   * Redo last undone event via event-log\n   */\n  redo(): RedixState | null {\n    const state = redoEventLog();\n    if (state) {\n      this.syncHistoryFromLog();\n    }\n    return state;\n  }\n\n  /**\n   * Get snapshot history (newest first)\n   */\n  getSnapshots(limit = 10): RedixSnapshot[] {\n    return this.snapshots.slice(-limit).reverse();\n  }\n\n  /**\n   * Clear all listeners and in-memory history (does not clear event-log).\n   */\n  clear(): void {\n    this.listeners.clear();\n    this.globalListeners.clear();\n    this.eventHistory = [];\n    this.snapshots = [];\n  }\n\n  private recordEvent(event: RedixEvent): void {\n    this.eventHistory.push(event);\n    if (this.eventHistory.length > MAX_HISTORY_SIZE) {\n      this.eventHistory.shift();\n    }\n  }\n\n  private maybeCaptureSnapshot(event: RedixEvent): void {\n    this.dispatchCount += 1;\n    if (this.dispatchCount % SNAPSHOT_EVERY !== 0) {\n      return;\n    }\n\n    const snapshot: RedixSnapshot = {\n      id: `snapshot_${event.id}`,\n      eventId: event.id,\n      eventType: event.type,\n      timestamp: event.timestamp,\n      state: event.nextState ? { ...event.nextState } : getCurrentState(),\n      diff: event.diff || [],\n    };\n\n    this.snapshots.push(snapshot);\n    if (this.snapshots.length > MAX_SNAPSHOTS) {\n      this.snapshots.shift();\n    }\n  }\n\n  private notifyListeners(event: RedixEvent): void {\n    // Notify specific listeners\n    const typeListeners = this.listeners.get(event.type);\n    if (typeListeners) {\n      typeListeners.forEach(listener => {\n        try {\n          listener(event);\n        } catch (error) {\n          console.error('[Redix] Listener error:', error);\n        }\n      });\n    }\n\n    // Notify global listeners\n    this.globalListeners.forEach(listener => {\n      try {\n        listener(event);\n      } catch (error) {\n        console.error('[Redix] Global listener error:', error);\n      }\n    });\n  }\n\n  /**\n   * Sync in-memory history with event-log (used after undo/redo)\n   */\n  private syncHistoryFromLog(): void {\n    const log = getEventLog();\n    this.eventHistory = log.slice(-MAX_HISTORY_SIZE).map((event) => ({\n      ...event,\n      ts: event.timestamp,\n    }));\n  }\n}\n\nfunction computeStateDiff(prev: RedixState, next: RedixState): RedixStateDiffEntry[] {\n  if (!prev && !next) return [];\n  const diffs: RedixStateDiffEntry[] = [];\n  walkDiff(prev || {}, next || {}, '', 0, diffs);\n  return diffs.slice(0, MAX_DIFF_ENTRIES);\n}\n\nfunction walkDiff(\n  prev: Record<string, any>,\n  next: Record<string, any>,\n  path: string,\n  depth: number,\n  diffs: RedixStateDiffEntry[]\n): void {\n  if (depth > MAX_DIFF_DEPTH || diffs.length >= MAX_DIFF_ENTRIES) {\n    return;\n  }\n\n  const keys = new Set([...Object.keys(prev || {}), ...Object.keys(next || {})]);\n  keys.forEach((key) => {\n    if (diffs.length >= MAX_DIFF_ENTRIES) return;\n    const currentPath = path ? `${path}.${key}` : key;\n    const prevValue = prev?.[key];\n    const nextValue = next?.[key];\n\n    if (!Object.prototype.hasOwnProperty.call(next || {}, key)) {\n      diffs.push({ path: currentPath, before: prevValue, after: undefined });\n      return;\n    }\n\n    if (!Object.prototype.hasOwnProperty.call(prev || {}, key)) {\n      diffs.push({ path: currentPath, before: undefined, after: nextValue });\n      return;\n    }\n\n    if (isPlainObject(prevValue) && isPlainObject(nextValue)) {\n      const prevString = JSON.stringify(prevValue);\n      const nextString = JSON.stringify(nextValue);\n      if (prevString !== nextString) {\n        walkDiff(prevValue, nextValue, currentPath, depth + 1, diffs);\n      }\n      return;\n    }\n\n    if (Array.isArray(prevValue) && Array.isArray(nextValue)) {\n      const prevString = JSON.stringify(prevValue);\n      const nextString = JSON.stringify(nextValue);\n      if (prevString !== nextString) {\n        diffs.push({ path: currentPath, before: prevValue, after: nextValue });\n      }\n      return;\n    }\n\n    if (prevValue !== nextValue) {\n      diffs.push({ path: currentPath, before: prevValue, after: nextValue });\n    }\n  });\n}\n\nfunction isPlainObject(value: unknown): value is Record<string, unknown> {\n  return Object.prototype.toString.call(value) === '[object Object]';\n}\n\n// Singleton instance\nexport const Redix = new RedixRuntime();\n\n// Export convenience methods\nexport const watch = (eventType: string | RedixListener, handler?: RedixListener) => Redix.watch(eventType, handler);\nexport const dispatch = (event: RedixDispatchEvent) => Redix.dispatch(event);\nexport const getRedixState = () => Redix.getState();\nexport const getRedixHistory = (eventType?: string, limit?: number) => Redix.getHistory(eventType, limit);\nexport const getRedixSnapshots = (limit?: number) => Redix.getSnapshots(limit);\nexport const timeTravelRedix = (options: { eventId?: string; eventIndex?: number; timestamp?: number }) =>\n  Redix.timeTravel(options);\nexport const undoRedix = () => Redix.undo();\nexport const redoRedix = () => Redix.redo();\n\n\n","/**\r\n * Mode Configuration for Tier 1\r\n * Only Research mode is fully enabled; others are marked as \"Coming Soon\"\r\n */\r\n\r\nexport type ModeId =\r\n  | 'Browse'\r\n  | 'Research'\r\n  | 'Trade'\r\n  | 'Games'\r\n  | 'Docs'\r\n  | 'Images'\r\n  | 'Threats'\r\n  | 'GraphMind';\r\n\r\nexport interface ModeConfig {\r\n  id: ModeId;\r\n  label: string;\r\n  enabled: boolean;\r\n  comingSoon: boolean;\r\n  description?: string;\r\n}\r\n\r\nexport const MODES: Record<ModeId, ModeConfig> = {\r\n  Browse: {\r\n    id: 'Browse',\r\n    label: 'Browse',\r\n    enabled: true,\r\n    comingSoon: false,\r\n    description: 'Standard browsing with lightweight enhancements.',\r\n  },\r\n  Research: {\r\n    id: 'Research',\r\n    label: 'Research',\r\n    enabled: true,\r\n    comingSoon: false,\r\n    description: 'AI-powered research and summarization',\r\n  },\r\n  Trade: {\r\n    id: 'Trade',\r\n    label: 'Trade',\r\n    enabled: true,\r\n    comingSoon: false,\r\n    description: 'Trading mode with TradingView integration and real-time market data',\r\n  },\r\n  Games: {\r\n    id: 'Games',\r\n    label: 'Games',\r\n    enabled: false,\r\n    comingSoon: true,\r\n    description: 'Game mode with AI recommendations (Coming Soon)',\r\n  },\r\n  Docs: {\r\n    id: 'Docs',\r\n    label: 'Docs',\r\n    enabled: false,\r\n    comingSoon: true,\r\n    description: 'Document mode (Coming Soon)',\r\n  },\r\n  Images: {\r\n    id: 'Images',\r\n    label: 'Images',\r\n    enabled: false,\r\n    comingSoon: true,\r\n    description: 'Image mode (Coming Soon)',\r\n  },\r\n  Threats: {\r\n    id: 'Threats',\r\n    label: 'Threats',\r\n    enabled: false,\r\n    comingSoon: true,\r\n    description: 'Threat intelligence mode (Coming Soon)',\r\n  },\r\n  GraphMind: {\r\n    id: 'GraphMind',\r\n    label: 'GraphMind',\r\n    enabled: false,\r\n    comingSoon: true,\r\n    description: 'GraphMind mode (Coming Soon)',\r\n  },\r\n};\r\n\r\nexport const ENABLED_MODES = Object.values(MODES).filter(m => m.enabled);\r\nexport const PRIMARY_MODES: ModeId[] = ['Browse', 'Research', 'Trade'];\r\nexport const TIER1_MODE: ModeId = 'Research';\r\n\r\n/**\r\n * Check if a mode is available for use\r\n */\r\nexport function isModeEnabled(modeId: ModeId): boolean {\r\n  return MODES[modeId]?.enabled ?? false;\r\n}\r\n\r\n/**\r\n * Get mode config\r\n */\r\nexport function getModeConfig(modeId: ModeId): ModeConfig {\r\n  return MODES[modeId] ?? MODES.Browse;\r\n}\r\n","/**\n * Toast Utility\n * Provides toast notification functions using react-hot-toast\n * Backward compatible with existing code\n */\n\nimport toastLib from 'react-hot-toast';\n\nexport type ToastType = 'info' | 'success' | 'error' | 'warning';\n\n/**\n * Toast utility object with convenience methods\n * Uses react-hot-toast for better UX with animations and positioning\n */\nconst toastObj = {\n  info: (message: string, options?: { duration?: number }) => {\n    return toastLib(message, {\n      icon: '',\n      duration: options?.duration ?? 4000,\n      style: {\n        background: '#1e293b',\n        color: '#e2e8f0',\n        border: '1px solid #334155',\n      },\n    });\n  },\n  success: (message: string, options?: { duration?: number }) => {\n    return toastLib.success(message, {\n      duration: options?.duration ?? 4000,\n      style: {\n        background: '#1e293b',\n        color: '#10b981',\n        border: '1px solid #334155',\n      },\n    });\n  },\n  error: (message: string, options?: { duration?: number }) => {\n    return toastLib.error(message, {\n      duration: options?.duration ?? 5000,\n      style: {\n        background: '#1e293b',\n        color: '#ef4444',\n        border: '1px solid #334155',\n      },\n    });\n  },\n  warning: (message: string, options?: { duration?: number }) => {\n    return toastLib(message, {\n      icon: '',\n      duration: options?.duration ?? 4000,\n      style: {\n        background: '#1e293b',\n        color: '#f59e0b',\n        border: '1px solid #334155',\n      },\n    });\n  },\n  loading: (message: string) => {\n    return toastLib.loading(message, {\n      duration: Infinity, // Loading toasts don't auto-dismiss\n      style: {\n        background: '#1e293b',\n        color: '#e2e8f0',\n        border: '1px solid #334155',\n      },\n    });\n  },\n  dismiss: (toastId?: string) => {\n    if (toastId) {\n      toastLib.dismiss(toastId);\n    } else {\n      toastLib.dismiss();\n    }\n  },\n  promise: <T>(\n    promise: Promise<T>,\n    messages: {\n      loading: string;\n      success: string | ((data: T) => string);\n      error: string | ((error: Error) => string);\n    }\n  ) => {\n    return toastLib.promise(promise, messages, {\n      style: {\n        background: '#1e293b',\n        color: '#e2e8f0',\n        border: '1px solid #334155',\n      },\n      success: {\n        style: {\n          color: '#10b981',\n        },\n      },\n      error: {\n        style: {\n          color: '#ef4444',\n        },\n      },\n    });\n  },\n};\n\n// Create toast function that also has methods\nfunction toastFn(type: ToastType, message: string): void {\n  switch (type) {\n    case 'info':\n      toastObj.info(message);\n      break;\n    case 'success':\n      toastObj.success(message);\n      break;\n    case 'error':\n      toastObj.error(message);\n      break;\n    case 'warning':\n      toastObj.warning(message);\n      break;\n  }\n}\n\n// Assign methods to function for backward compatibility\nexport const toast = Object.assign(toastFn, toastObj);\n\n// Re-export react-hot-toast for direct usage if needed\nexport { toastLib };\n","import { create } from 'zustand';\r\nimport { ModeManager } from '../core/modes/manager';\r\nimport { MODES, isModeEnabled, type ModeId } from '../config/modes';\r\nimport { toast } from '../utils/toast';\r\n\r\nexport type AppState = {\r\n  mode: 'Browse' | 'Research' | 'Trade' | 'Games' | 'Docs' | 'Images' | 'Threats' | 'GraphMind';\r\n  setMode: (m: AppState['mode']) => void;\r\n  graphDockOpen: boolean;\r\n  toggleGraphDock: () => void;\r\n  ledgerDockOpen: boolean;\r\n  toggleLedgerDock: () => void;\r\n  researchPaneOpen: boolean;\r\n  toggleResearchPane: () => void;\r\n  setResearchPaneOpen: (open: boolean) => void;\r\n  memorySidebarOpen: boolean;\r\n  setMemorySidebarOpen: (open: boolean) => void;\r\n  regenSidebarOpen: boolean;\r\n  setRegenSidebarOpen: (open: boolean) => void;\r\n  toggleRegenSidebar: () => void;\r\n};\r\n\r\nexport const useAppStore = create<AppState>((set, get) => ({\r\n  mode: 'Research',\r\n  setMode: async mode => {\r\n    const currentMode = get().mode;\r\n    if (mode === currentMode) return;\r\n\r\n    // Tier 1: Check if mode is enabled\r\n    if (!isModeEnabled(mode as ModeId)) {\r\n      const modeConfig = MODES[mode as ModeId];\r\n      toast.info(modeConfig?.description || `${mode} mode is coming soon!`);\r\n      return;\r\n    }\r\n\r\n    set({ mode });\r\n\r\n    // Tier 2: Track mode switch\r\n    import('../services/analytics').then(({ track }) => {\r\n      track('mode_switched', { mode });\r\n    });\r\n\r\n    // Get tabs for the new mode\r\n    const { useTabsStore } = await import('./tabsStore');\r\n    const tabsStore = useTabsStore.getState();\r\n    const modeTabs = tabsStore.getTabsForMode(mode);\r\n\r\n    // Research and Trade modes don't use tabs - they have their own UI\r\n    if (mode !== 'Research' && mode !== 'Trade') {\r\n      // If no tabs exist for this mode, create one with a default URL\r\n      if (modeTabs.length === 0) {\r\n        const defaultUrls: Record<AppState['mode'], string> = {\r\n          Browse: 'https://www.google.com',\r\n          Research: 'https://www.google.com',\r\n          Trade: 'https://www.tradingview.com',\r\n          Games: 'https://www.friv.com',\r\n          Docs: 'about:blank',\r\n          Images: 'https://www.google.com/imghp',\r\n          Threats: 'about:blank',\r\n          GraphMind: 'about:blank',\r\n        };\r\n\r\n        const defaultUrl = defaultUrls[mode] || 'about:blank';\r\n        const newTab = await (await import('../lib/ipc-typed')).ipc.tabs.create(defaultUrl);\r\n\r\n        // Update the tab with the appMode\r\n        if (newTab && typeof newTab === 'object' && 'id' in newTab) {\r\n          tabsStore.updateTab((newTab as { id: string }).id, { appMode: mode });\r\n        } else if (typeof newTab === 'string') {\r\n          // Fallback: if it returns just an ID string\r\n          tabsStore.updateTab(newTab, { appMode: mode });\r\n        }\r\n      } else {\r\n        // Switch to the first tab of this mode\r\n        if (modeTabs[0]?.id) {\r\n          tabsStore.setActive(modeTabs[0].id);\r\n          await (await import('../lib/ipc-typed')).ipc.tabs.activate({ id: modeTabs[0].id });\r\n        }\r\n      }\r\n    }\r\n\r\n    // Activate the mode manager\r\n    ModeManager.activate(mode).catch(console.error);\r\n  },\r\n  graphDockOpen: false,\r\n  toggleGraphDock: () => {\r\n    const next = !get().graphDockOpen;\r\n    set({ graphDockOpen: next });\r\n    (window as any).ui?.setRightDock?.(next ? 360 : 0);\r\n  },\r\n  ledgerDockOpen: false,\r\n  toggleLedgerDock: () => {\r\n    const next = !get().ledgerDockOpen;\r\n    set({ ledgerDockOpen: next });\r\n    (window as any).ui?.setRightDock?.(next ? 360 : 0);\r\n  },\r\n  researchPaneOpen: false,\r\n  toggleResearchPane: () => {\r\n    const next = !get().researchPaneOpen;\r\n    set({ researchPaneOpen: next });\r\n    (window as any).ui?.setRightDock?.(next ? 420 : 0);\r\n  },\r\n  setResearchPaneOpen: (open: boolean) => {\r\n    set({ researchPaneOpen: open });\r\n    (window as any).ui?.setRightDock?.(open ? 420 : 0);\r\n  },\r\n  memorySidebarOpen: false,\r\n  setMemorySidebarOpen: (open: boolean) => {\r\n    set({ memorySidebarOpen: open });\r\n    // Dispatch event for AppShell to sync state\r\n    if (typeof window !== 'undefined') {\r\n      window.dispatchEvent(new CustomEvent('memory-sidebar:toggle', { detail: { open } }));\r\n    }\r\n  },\r\n  regenSidebarOpen: false,\r\n  setRegenSidebarOpen: (open: boolean) => {\r\n    set({ regenSidebarOpen: open });\r\n    // Dispatch event for AppShell to sync state\r\n    if (typeof window !== 'undefined') {\r\n      window.dispatchEvent(new CustomEvent('regen-sidebar:toggle', { detail: { open } }));\r\n    }\r\n  },\r\n  toggleRegenSidebar: () => {\r\n    const next = !get().regenSidebarOpen;\r\n    get().setRegenSidebarOpen(next);\r\n  },\r\n}));\r\n","import { create } from 'zustand';\nimport { persist } from 'zustand/middleware';\nimport { ipc } from '../lib/ipc-typed';\nimport { debouncedSaveSession } from '../services/session';\nimport { useAppStore } from './appStore';\n\nexport const TAB_GROUP_COLORS = [\n  '#6366f1',\n  '#8b5cf6',\n  '#f472b6',\n  '#14b8a6',\n  '#0ea5e9',\n  '#f97316',\n  '#facc15',\n];\n\nconst generateId = () => {\n  if (typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function') {\n    return crypto.randomUUID();\n  }\n  return `tab-group-${Math.random().toString(36).slice(2, 10)}`;\n};\n\nexport type TabHistoryEntry = {\n  url: string;\n  title?: string;\n  timestamp: number;\n};\n\nexport type Tab = {\n  id: string;\n  title: string;\n  active?: boolean;\n  url?: string;\n  containerId?: string;\n  containerColor?: string;\n  containerName?: string;\n  mode?: 'normal' | 'ghost' | 'private';\n  appMode?: 'Browse' | 'Research' | 'Trade' | 'Games' | 'Docs' | 'Images' | 'Threats' | 'GraphMind';\n  createdAt?: number;\n  lastActiveAt?: number;\n  sessionId?: string;\n  profileId?: string;\n  sleeping?: boolean;\n  pinned?: boolean;\n  groupId?: string;\n  // Tier 1: History tracking for back/forward\n  history?: TabHistoryEntry[];\n  historyIndex?: number; // Current pointer in history\n};\n\nexport type TabGroup = {\n  id: string;\n  name: string;\n  color: string;\n  collapsed?: boolean;\n  createdAt: number;\n};\n\nexport type ClosedTab = {\n  closedId: string;\n  title?: string;\n  url?: string;\n  appMode?: Tab['appMode'];\n  mode?: Tab['mode'];\n  containerId?: string;\n  containerName?: string;\n  containerColor?: string;\n  groupId?: string;\n  closedAt: number;\n};\n\ntype TabsState = {\n  tabs: Tab[];\n  activeId: string | null;\n  recentlyClosed: ClosedTab[];\n  tabGroups: TabGroup[];\n  add: (t: Tab) => void;\n  setActive: (id: string | null) => void;\n  setAll: (tabs: Tab[]) => void;\n  remove: (id: string) => void;\n  getTabsForMode: (mode: string) => Tab[];\n  updateTab: (id: string, updates: Partial<Tab>) => void;\n  rememberClosedTab: (tab: Tab) => void;\n  popRecentlyClosed: () => ClosedTab | undefined;\n  removeRecentlyClosed: (closedId: string) => void;\n  pushRecentlyClosed: (entry: ClosedTab) => void;\n  clearRecentlyClosed: () => void;\n  pinTab: (id: string) => void;\n  unpinTab: (id: string) => void;\n  togglePinTab: (id: string) => void;\n  createGroup: (options?: { name?: string; color?: string }) => TabGroup;\n  updateGroup: (id: string, updates: Partial<TabGroup>) => void;\n  deleteGroup: (id: string) => void;\n  toggleGroupCollapsed: (id: string) => void;\n  setGroupColor: (id: string, color: string) => void;\n  assignTabToGroup: (tabId: string, groupId: string | null) => void;\n  // Tier 1: History navigation\n  navigateTab: (tabId: string, newUrl: string) => void;\n  goBack: (tabId: string) => void;\n  goForward: (tabId: string) => void;\n  canGoBack: (tabId: string) => boolean;\n  canGoForward: (tabId: string) => boolean;\n  // Tier 1: Tab limits\n  canAddTab: () => boolean;\n  getTabCount: () => number;\n  getMaxTabs: () => number;\n};\n\nconst MAX_RECENTLY_CLOSED = 12;\nconst MAX_TABS = 15; // Tier 1: Limit tabs for MVP\n\nexport const useTabsStore = create<TabsState>()(\n  persist(\n    (set, get) => ({\n      tabs: [],\n      activeId: null,\n      recentlyClosed: [],\n      tabGroups: [],\n      add: tab =>\n        set(state => {\n          // Tier 1: Check tab limit\n          if (state.tabs.length >= MAX_TABS) {\n            // Don't add, but return state (caller should show toast)\n            return state;\n          }\n          const newState = {\n            tabs: [...state.tabs, { ...tab, createdAt: tab.createdAt ?? Date.now() }],\n            activeId: tab.id,\n          };\n          // Tier 1: Auto-save session\n          const appMode = useAppStore.getState().mode;\n          debouncedSaveSession({\n            tabs: newState.tabs,\n            activeTabId: newState.activeId,\n            mode: appMode,\n            savedAt: Date.now(),\n          });\n          // Tier 2: Track tab creation\n          import('../services/analytics').then(({ track }) => {\n            track('tab_created', { mode: appMode });\n          });\n          // Index tab in MeiliSearch\n          import('../services/meiliIndexer').then(({ indexTab }) => {\n            indexTab(tab).catch(console.error);\n          });\n          return newState;\n        }),\n      setActive: id => {\n        // PR: Fix tab switch - add logging and null guards\n        const currentState = get();\n\n        // Early return if already active (prevents unnecessary re-renders and race conditions)\n        if (id === currentState.activeId) {\n          return;\n        }\n\n        console.log('[TABS] setActive', {\n          tabId: id,\n          currentActiveId: currentState.activeId,\n          totalTabs: currentState.tabs.length,\n          tabIds: currentState.tabs.map(t => t.id),\n        });\n\n        // Validate tab exists if id is provided\n        if (id !== null) {\n          const tabExists = currentState.tabs.find(t => t.id === id);\n          if (!tabExists) {\n            // Suppress warning for internal/system tabs (e.g., 'local-initial')\n            if (!id.includes('local-') && !id.includes('system-')) {\n              console.warn('[TABS] setActive: Tab not found', id);\n            }\n            // Don't set to null, keep current active tab\n            return;\n          }\n        }\n\n        set(state => {\n          // PR: Fix tab switch - ensure atomic update\n          const newState = {\n            activeId: id,\n            tabs: state.tabs.map(tab => {\n              if (tab.id === id) {\n                return { ...tab, active: true, lastActiveAt: Date.now() };\n              } else {\n                return { ...tab, active: false };\n              }\n            }),\n          };\n          // Tier 1: Auto-save session\n          const appMode = useAppStore.getState().mode;\n          debouncedSaveSession({\n            tabs: newState.tabs,\n            activeTabId: newState.activeId,\n            mode: appMode,\n            savedAt: Date.now(),\n          });\n\n          // PR: Fix tab switch - update agent stream store\n          import('../state/agentStreamStore')\n            .then(({ useAgentStreamStore }) => {\n              useAgentStreamStore.getState().setActiveTabId(id);\n            })\n            .catch(() => {\n              // Silently fail if store not available\n            });\n\n          return newState;\n        });\n      },\n      setAll: tabs =>\n        set(() => {\n          const previousTabs = get().tabs;\n          const normalized = tabs.map((tab, index) => {\n            const previous = previousTabs.find(prev => prev.id === tab.id);\n            return {\n              ...tab,\n              createdAt: tab.createdAt ?? previous?.createdAt ?? Date.now(),\n              lastActiveAt:\n                tab.lastActiveAt ?? previous?.lastActiveAt ?? Date.now() - (tabs.length - index),\n              pinned: (typeof tab.pinned === 'boolean' ? tab.pinned : previous?.pinned) ?? false,\n              groupId: previous?.groupId,\n            };\n          });\n          // Sort: pinned tabs first (by creation time), then unpinned tabs\n          const sorted = normalized.sort((a, b) => {\n            if (a.pinned && !b.pinned) return -1;\n            if (!a.pinned && b.pinned) return 1;\n            if (a.pinned && b.pinned) return (a.createdAt ?? 0) - (b.createdAt ?? 0);\n            return (a.lastActiveAt ?? 0) - (b.lastActiveAt ?? 0);\n          });\n          const activeCandidate = sorted.find(tab => tab.active) ?? sorted[0] ?? null;\n          return {\n            tabs: sorted,\n            activeId: activeCandidate ? activeCandidate.id : null,\n          };\n        }),\n      remove: id =>\n        set(state => {\n          const tabToRemove = state.tabs.find(t => t.id === id);\n          // Prevent closing pinned tabs accidentally (user must unpin first)\n          if (tabToRemove?.pinned) {\n            return state;\n          }\n          const remaining = state.tabs.filter(tab => tab.id !== id);\n          const nextActive =\n            state.activeId === id\n              ? (remaining.find(\n                  tab => tab.appMode === state.tabs.find(t => t.id === id)?.appMode\n                ) ??\n                remaining[0] ??\n                null)\n              : (state.tabs.find(tab => tab.id === state.activeId) ?? null);\n\n          // Tier 1: If no tabs left, create a new blank tab\n          const finalTabs =\n            remaining.length === 0\n              ? [\n                  {\n                    id: `tab-${Date.now()}`,\n                    title: 'New Tab',\n                    url: 'about:blank',\n                    appMode: useAppStore.getState().mode,\n                    createdAt: Date.now(),\n                    lastActiveAt: Date.now(),\n                  } as Tab,\n                ]\n              : remaining;\n\n          const finalActiveId =\n            remaining.length === 0 ? finalTabs[0].id : nextActive ? nextActive.id : null;\n\n          const newState = {\n            tabs: finalTabs,\n            activeId: finalActiveId,\n          };\n\n          // MEMORY LEAK FIX: Clean up tab resources\n          // Emit cleanup event for tab content cleanup\n          if (typeof window !== 'undefined') {\n            window.dispatchEvent(new CustomEvent('tab-closed', { detail: { tabId: id } }));\n          }\n\n          // Tier 1: Auto-save session\n          const appMode = useAppStore.getState().mode;\n          debouncedSaveSession({\n            tabs: newState.tabs,\n            activeTabId: newState.activeId,\n            mode: appMode,\n            savedAt: Date.now(),\n          });\n\n          // Tier 2: Track tab closure\n          import('../services/analytics').then(({ track }) => {\n            track('tab_closed', { mode: appMode });\n          });\n\n          return newState;\n        }),\n      getTabsForMode: (mode: string) => {\n        const state = get();\n        return state.tabs.filter(tab => !tab.appMode || tab.appMode === mode);\n      },\n      updateTab: (id: string, updates: Partial<Tab>) =>\n        set(state => {\n          const updatedTabs = state.tabs.map(tab => (tab.id === id ? { ...tab, ...updates } : tab));\n          const updatedTab = updatedTabs.find(t => t.id === id);\n          // Re-index updated tab in MeiliSearch\n          if (updatedTab) {\n            import('../services/meiliIndexer').then(({ indexTab }) => {\n              indexTab(updatedTab).catch(console.error);\n            });\n          }\n          return { tabs: updatedTabs };\n        }),\n      rememberClosedTab: (tab: Tab) =>\n        set(state => {\n          const entry: ClosedTab = {\n            closedId: tab.id,\n            title: tab.title,\n            url: tab.url,\n            appMode: tab.appMode,\n            mode: tab.mode,\n            containerId: tab.containerId,\n            containerName: tab.containerName,\n            containerColor: tab.containerColor,\n            groupId: tab.groupId,\n            closedAt: Date.now(),\n          };\n          return {\n            recentlyClosed: [\n              entry,\n              ...state.recentlyClosed.filter(item => item.closedId !== tab.id),\n            ].slice(0, MAX_RECENTLY_CLOSED),\n          };\n        }),\n      popRecentlyClosed: () => {\n        const state = get();\n        if (state.recentlyClosed.length === 0) {\n          return undefined;\n        }\n        const [first, ...rest] = state.recentlyClosed;\n        set({ recentlyClosed: rest });\n        return first;\n      },\n      removeRecentlyClosed: (closedId: string) =>\n        set(state => ({\n          recentlyClosed: state.recentlyClosed.filter(entry => entry.closedId !== closedId),\n        })),\n      pushRecentlyClosed: (entry: ClosedTab) =>\n        set(state => ({\n          recentlyClosed: [\n            entry,\n            ...state.recentlyClosed.filter(item => item.closedId !== entry.closedId),\n          ].slice(0, MAX_RECENTLY_CLOSED),\n        })),\n      clearRecentlyClosed: () => set({ recentlyClosed: [] }),\n      pinTab: (id: string) => {\n        set(state => {\n          const tab = state.tabs.find(t => t.id === id);\n          if (!tab) return state;\n          const otherTabs = state.tabs.filter(t => t.id !== id);\n          const pinnedTabs = otherTabs\n            .filter(t => t.pinned)\n            .sort((a, b) => (a.createdAt ?? 0) - (b.createdAt ?? 0));\n          const unpinnedTabs = otherTabs.filter(t => !t.pinned);\n          return {\n            tabs: [...pinnedTabs, { ...tab, pinned: true }, ...unpinnedTabs],\n          };\n        });\n        try {\n          void ipc.tabs.setPinned({ id, pinned: true });\n        } catch (error) {\n          if (process.env.NODE_ENV === 'development') {\n            console.warn('[TabsStore] Failed to pin tab via IPC', error);\n          }\n        }\n      },\n      unpinTab: (id: string) => {\n        set(state => {\n          const tab = state.tabs.find(t => t.id === id);\n          if (!tab) return state;\n          const otherTabs = state.tabs.filter(t => t.id !== id);\n          const pinnedTabs = otherTabs\n            .filter(t => t.pinned)\n            .sort((a, b) => (a.createdAt ?? 0) - (b.createdAt ?? 0));\n          const unpinnedTabs = otherTabs.filter(t => !t.pinned);\n          return {\n            tabs: [...pinnedTabs, { ...tab, pinned: false }, ...unpinnedTabs],\n          };\n        });\n        try {\n          void ipc.tabs.setPinned({ id, pinned: false });\n        } catch (error) {\n          if (process.env.NODE_ENV === 'development') {\n            console.warn('[TabsStore] Failed to unpin tab via IPC', error);\n          }\n        }\n      },\n      togglePinTab: (id: string) => {\n        const state = get();\n        const tab = state.tabs.find(t => t.id === id);\n        if (!tab) return;\n        if (tab.pinned) {\n          get().unpinTab(id);\n        } else {\n          get().pinTab(id);\n        }\n      },\n      createGroup: options => {\n        const currentGroups = get().tabGroups;\n        const group: TabGroup = {\n          id: generateId(),\n          name: options?.name?.trim() || `Group ${currentGroups.length + 1}`,\n          color: options?.color || TAB_GROUP_COLORS[currentGroups.length % TAB_GROUP_COLORS.length],\n          collapsed: false,\n          createdAt: Date.now(),\n        };\n        set(state => ({\n          tabGroups: [...state.tabGroups, group],\n        }));\n        return group;\n      },\n      updateGroup: (id, updates) =>\n        set(state => ({\n          tabGroups: state.tabGroups.map(group =>\n            group.id === id ? { ...group, ...updates } : group\n          ),\n        })),\n      deleteGroup: id =>\n        set(state => ({\n          tabGroups: state.tabGroups.filter(group => group.id !== id),\n          tabs: state.tabs.map(tab => (tab.groupId === id ? { ...tab, groupId: undefined } : tab)),\n        })),\n      toggleGroupCollapsed: id =>\n        set(state => ({\n          tabGroups: state.tabGroups.map(group =>\n            group.id === id ? { ...group, collapsed: !group.collapsed } : group\n          ),\n        })),\n      setGroupColor: (id, color) =>\n        set(state => ({\n          tabGroups: state.tabGroups.map(group => (group.id === id ? { ...group, color } : group)),\n        })),\n      assignTabToGroup: (tabId, groupId) =>\n        set(state => ({\n          tabs: state.tabs.map(tab =>\n            tab.id === tabId ? { ...tab, groupId: groupId || undefined } : tab\n          ),\n        })),\n      // Tier 1: History navigation\n      navigateTab: (tabId, newUrl) =>\n        set(state => {\n          const tab = state.tabs.find(t => t.id === tabId);\n          if (!tab) return state;\n\n          // Initialize history if it doesn't exist, starting with the current URL\n          let history = tab.history || [];\n          if (history.length === 0 && tab.url) {\n            history = [\n              {\n                url: tab.url,\n                title: tab.title,\n                timestamp: tab.createdAt || Date.now(),\n              },\n            ];\n          }\n          const historyIndex = tab.historyIndex ?? history.length - 1;\n\n          // If we're not at the end of history, truncate forward history\n          const newHistory =\n            historyIndex < history.length - 1 ? history.slice(0, historyIndex + 1) : history;\n\n          // Add new entry\n          const newEntry: TabHistoryEntry = {\n            url: newUrl,\n            title: tab.title,\n            timestamp: Date.now(),\n          };\n\n          return {\n            tabs: state.tabs.map(t =>\n              t.id === tabId\n                ? {\n                    ...t,\n                    url: newUrl,\n                    history: [...newHistory, newEntry],\n                    historyIndex: newHistory.length, // Points to the new entry\n                  }\n                : t\n            ),\n          };\n        }),\n      goBack: tabId =>\n        set(state => {\n          const tab = state.tabs.find(t => t.id === tabId);\n          if (!tab || !tab.history || tab.historyIndex === undefined || tab.historyIndex <= 0) {\n            return state;\n          }\n\n          const newIndex = tab.historyIndex - 1;\n          const entry = tab.history[newIndex];\n\n          return {\n            tabs: state.tabs.map(t =>\n              t.id === tabId\n                ? {\n                    ...t,\n                    url: entry.url,\n                    title: entry.title || t.title,\n                    historyIndex: newIndex,\n                  }\n                : t\n            ),\n          };\n        }),\n      goForward: tabId =>\n        set(state => {\n          const tab = state.tabs.find(t => t.id === tabId);\n          if (\n            !tab ||\n            !tab.history ||\n            tab.historyIndex === undefined ||\n            tab.historyIndex >= tab.history.length - 1\n          ) {\n            return state;\n          }\n\n          const newIndex = tab.historyIndex + 1;\n          const entry = tab.history[newIndex];\n\n          return {\n            tabs: state.tabs.map(t =>\n              t.id === tabId\n                ? {\n                    ...t,\n                    url: entry.url,\n                    title: entry.title || t.title,\n                    historyIndex: newIndex,\n                  }\n                : t\n            ),\n          };\n        }),\n      canGoBack: tabId => {\n        const tab = get().tabs.find(t => t.id === tabId);\n        if (!tab || !tab.history || tab.history.length === 0) return false;\n        const historyIndex = tab.historyIndex ?? tab.history.length - 1;\n        return historyIndex > 0;\n      },\n      canGoForward: tabId => {\n        const tab = get().tabs.find(t => t.id === tabId);\n        return (\n          tab?.history !== undefined &&\n          tab.historyIndex !== undefined &&\n          tab.historyIndex < tab.history.length - 1\n        );\n      },\n      // Tier 1: Tab limits\n      canAddTab: () => {\n        return get().tabs.length < MAX_TABS;\n      },\n      getTabCount: () => {\n        return get().tabs.length;\n      },\n      getMaxTabs: () => {\n        return MAX_TABS;\n      },\n    }),\n    {\n      name: 'regen:tabs-state',\n      version: 1,\n      partialize: state => ({\n        tabs: state.tabs,\n        activeId: state.activeId,\n        recentlyClosed: state.recentlyClosed,\n        tabGroups: state.tabGroups,\n      }),\n    }\n  )\n);\n","import { create } from 'zustand';\r\nimport { ContainerInfo } from '../lib/ipc-events';\r\n\r\ntype ContainerState = {\r\n  containers: ContainerInfo[];\r\n  activeContainerId: string;\r\n  setContainers: (containers: ContainerInfo[]) => void;\r\n  setActiveContainer: (container: ContainerInfo) => void;\r\n};\r\n\r\nexport const useContainerStore = create<ContainerState>((set) => ({\r\n  containers: [],\r\n  activeContainerId: 'default',\r\n  setContainers: (containers) =>\r\n    set((state) => {\r\n      const unique = containers.reduce<ContainerInfo[]>((acc, container) => {\r\n        if (!acc.find((c) => c.id === container.id)) {\r\n          acc.push(container);\r\n        }\r\n        return acc;\r\n      }, []);\r\n      const activeExists = unique.some((c) => c.id === state.activeContainerId);\r\n      return {\r\n        containers: unique,\r\n        activeContainerId: activeExists ? state.activeContainerId : unique[0]?.id || 'default',\r\n      };\r\n    }),\r\n  setActiveContainer: (container) =>\r\n    set((state) => ({\r\n      activeContainerId: container.id,\r\n      containers: [container, ...state.containers.filter((c) => c.id !== container.id)],\r\n    })),\r\n}));\r\n\r\n\r\n","/**\r\n * Typed IPC Client for Renderer\r\n * Provides type-safe IPC calls with automatic error handling\r\n */\r\n\r\n// @ts-nocheck\r\n\r\nimport { z } from 'zod';\r\nimport type { PrivacyAuditSummary } from './ipc-events';\r\nimport { isDevEnv, isElectronRuntime, isTauriRuntime } from './env';\r\nimport apiClient from './api-client';\r\nimport type { EcoImpactForecast } from '../types/ecoImpact';\r\nimport type { TrustSummary } from '../types/trustWeaver';\r\nimport type { NexusListResponse, NexusPluginEntry } from '../types/extensionNexus';\r\nimport type {\r\n  IdentityCredential,\r\n  IdentityRevealPayload,\r\n  IdentityVaultSummary,\r\n} from '../types/identity';\r\nimport type { ConsentAction, ConsentRecord } from '../types/consent';\r\nimport { useTabsStore } from '../state/tabsStore';\r\nimport { useContainerStore } from '../state/containerStore';\r\n\r\nconst IS_DEV = isDevEnv();\r\n\r\nconst DEFAULT_PROFILE_POLICY = Object.freeze({\r\n  allowDownloads: true,\r\n  allowPrivateWindows: true,\r\n  allowGhostTabs: true,\r\n  allowScreenshots: true,\r\n  allowClipping: true,\r\n});\r\n\r\nconst createDefaultProfile = () => ({\r\n  id: 'default',\r\n  name: 'Default',\r\n  createdAt: Date.now(),\r\n  proxy: undefined,\r\n  kind: 'default' as const,\r\n  color: '#3b82f6',\r\n  system: true,\r\n  policy: { ...DEFAULT_PROFILE_POLICY },\r\n  description: 'Fallback profile (IPC unavailable)',\r\n});\r\n\r\nconst FALLBACK_CHANNELS: Record<string, (req?: any) => unknown> = {\r\n  'tabs:setMemoryCap': () => ({ success: true }),\r\n  'telemetry:trackPerf': () => ({ success: false, stub: true }),\r\n  'system:getStatus': () => ({\r\n    redisConnected: false,\r\n    redixAvailable: false,\r\n    workerState: 'stopped',\r\n    vpn: { connected: false },\r\n    tor: { running: false, bootstrapped: false },\r\n    mode: 'Research',\r\n    uptime: 0,\r\n    memoryUsage: {\r\n      heapUsed: 0,\r\n      heapTotal: 0,\r\n      external: 0,\r\n      rss: 0,\r\n    },\r\n  }),\r\n  'session:checkRestore': () => ({ available: false }),\r\n  'profiles:list': () => [createDefaultProfile()],\r\n  'profiles:get': () => createDefaultProfile(),\r\n  'profiles:getActive': () => createDefaultProfile(),\r\n  'profiles:getPolicy': () => ({ ...DEFAULT_PROFILE_POLICY }),\r\n  'profiles:updateProxy': () => ({ success: false }),\r\n  'profiles:delete': () => ({ success: false }),\r\n  'sessions:list': () => [],\r\n  'sessions:getActive': () => null,\r\n  'workspace-v2:list': () => ({ workspaces: [] }),\r\n  'trust:list': () => ({ records: [] }),\r\n  'trust:getStatus': () => ({ status: 'unknown', totalRecords: 0, lastUpdatedAt: null }),\r\n  'privacy:sentinel:audit': () => ({\r\n    score: 0,\r\n    grade: 'low',\r\n    trackers: [],\r\n    thirdPartyHosts: [],\r\n    message: 'Privacy Sentinel unavailable outside Electron runtime.',\r\n    suggestions: ['Launch the desktop build to enable Privacy Sentinel audits.'],\r\n    timestamp: Date.now(),\r\n    ai: null,\r\n  }),\r\n  'tor:status': () => ({\r\n    running: false,\r\n    bootstrapped: false,\r\n    progress: 0,\r\n    circuitEstablished: false,\r\n    stub: true,\r\n    error: 'Tor runtime not available in this environment.',\r\n  }),\r\n  'tor:start': () => ({\r\n    success: false,\r\n    stub: true,\r\n    warning: 'Tor runtime not available in this environment.',\r\n  }),\r\n  'tor:stop': () => ({ success: true, stub: true }),\r\n  'tor:newIdentity': () => ({ success: false, stub: true }),\r\n  'vpn:status': () => ({ connected: false, stub: true }),\r\n  'vpn:check': () => ({ connected: false, stub: true }),\r\n  'vpn:listProfiles': () => [],\r\n  'vpn:connect': () => ({ connected: false, stub: true }),\r\n  'vpn:disconnect': () => ({ connected: false, stub: true }),\r\n  'dns:status': () => ({ enabled: false, provider: 'system', stub: true }),\r\n  'tabs:predictiveGroups': () => ({ groups: [], prefetch: [], summary: undefined }),\r\n  'tabs:create': (req?: any) => {\r\n    const payload = typeof req === 'object' && req ? req : {};\r\n    const tabsState = getTabsStore();\r\n    const previousActiveId = tabsState?.activeId;\r\n    const tabId =\r\n      (typeof payload.tabId === 'string' && payload.tabId.trim().length > 0\r\n        ? payload.tabId\r\n        : undefined) ?? `tab-${Date.now()}`;\r\n    const url =\r\n      typeof payload.url === 'string' && payload.url.trim().length > 0\r\n        ? payload.url\r\n        : 'about:blank';\r\n    const title =\r\n      typeof payload.title === 'string' && payload.title.trim().length > 0\r\n        ? payload.title\r\n        : deriveTitleFromUrl(url);\r\n\r\n    tabsState?.add?.({\r\n      id: tabId,\r\n      title,\r\n      url,\r\n      mode: payload.mode,\r\n      appMode: payload.appMode,\r\n      containerId: payload.containerId,\r\n      createdAt: payload.createdAt ?? Date.now(),\r\n      lastActiveAt: payload.lastActiveAt ?? Date.now(),\r\n      profileId: payload.profileId,\r\n      sessionId: payload.sessionId,\r\n    });\r\n\r\n    if (payload.activate === false && previousActiveId && tabsState?.setActive) {\r\n      tabsState.setActive(previousActiveId);\r\n    }\r\n\r\n    return { id: tabId, title, url, success: true };\r\n  },\r\n  'tabs:list': () => {\r\n    try {\r\n      const state = useTabsStore.getState?.();\r\n      if (state) {\r\n        return [...state.tabs];\r\n      }\r\n    } catch {\r\n      // ignore\r\n    }\r\n    return [];\r\n  },\r\n  'tabs:getActive': () => {\r\n    try {\r\n      const state = useTabsStore.getState?.();\r\n      if (state) {\r\n        return state.tabs.find(tab => tab.id === state.activeId) ?? null;\r\n      }\r\n    } catch {\r\n      // ignore\r\n    }\r\n    return null;\r\n  },\r\n  'tabs:close': (req?: { id?: string }) => {\r\n    try {\r\n      if (req?.id) {\r\n        const state = useTabsStore.getState?.();\r\n        state?.remove?.(req.id);\r\n      }\r\n    } catch {\r\n      // ignore\r\n    }\r\n    return { success: true };\r\n  },\r\n  'tabs:activate': (req?: { id?: string }) => {\r\n    try {\r\n      if (req?.id) {\r\n        const state = useTabsStore.getState?.();\r\n        state?.setActive?.(req.id);\r\n      }\r\n    } catch {\r\n      // ignore\r\n    }\r\n    return { success: true };\r\n  },\r\n  'tabs:navigate': (req?: { id?: string; url?: string }) => {\r\n    try {\r\n      if (req?.id && req?.url) {\r\n        const state = useTabsStore.getState?.();\r\n        if (state?.navigateTab) {\r\n          state.navigateTab(req.id, req.url);\r\n        } else {\r\n          state?.updateTab?.(req.id, { url: req.url, title: deriveTitleFromUrl(req.url) });\r\n        }\r\n      }\r\n    } catch {\r\n      // ignore\r\n    }\r\n    return { success: true };\r\n  },\r\n  'tabs:goBack': (req?: { id?: string }) => {\r\n    try {\r\n      if (req?.id) {\r\n        const state = useTabsStore.getState?.();\r\n        state?.goBack?.(req.id);\r\n      }\r\n    } catch {\r\n      // ignore\r\n    }\r\n    return { success: true };\r\n  },\r\n  'tabs:goForward': (req?: { id?: string }) => {\r\n    try {\r\n      if (req?.id) {\r\n        const state = useTabsStore.getState?.();\r\n        state?.goForward?.(req.id);\r\n      }\r\n    } catch {\r\n      // ignore\r\n    }\r\n    return { success: true };\r\n  },\r\n  'tabs:reload': () => ({ success: true }),\r\n  'tabs:stop': () => ({ success: true }),\r\n  'containers:list': () => {\r\n    try {\r\n      const state = useContainerStore.getState?.();\r\n      if (state) {\r\n        return [...state.containers];\r\n      }\r\n    } catch {\r\n      // ignore\r\n    }\r\n    return [];\r\n  },\r\n  'containers:getActive': () => {\r\n    try {\r\n      const state = useContainerStore.getState?.();\r\n      if (state) {\r\n        return state.containers.find(c => c.id === state.activeContainerId) ?? null;\r\n      }\r\n    } catch {\r\n      // ignore\r\n    }\r\n    return null;\r\n  },\r\n  'identity:status': () =>\r\n    ({ status: 'locked', totalCredentials: 0, lastUpdatedAt: null }) satisfies IdentityVaultSummary,\r\n  'identity:unlock': () =>\r\n    ({ status: 'locked', totalCredentials: 0, lastUpdatedAt: null }) satisfies IdentityVaultSummary,\r\n  'identity:lock': () =>\r\n    ({ status: 'locked', totalCredentials: 0, lastUpdatedAt: null }) satisfies IdentityVaultSummary,\r\n  'identity:list': () => [] as IdentityCredential[],\r\n  'identity:add': () =>\r\n    ({\r\n      id: 'demo',\r\n      domain: 'example.com',\r\n      username: 'demo',\r\n      createdAt: Date.now(),\r\n      updatedAt: Date.now(),\r\n    }) satisfies IdentityCredential,\r\n  'identity:remove': () => ({ success: false }),\r\n  'identity:reveal': () => ({ id: 'demo', secret: 'demo' }) satisfies IdentityRevealPayload,\r\n  'consent:list': () => [],\r\n  'shields:getStatus': () => ({\r\n    adsBlocked: 0,\r\n    trackersBlocked: 0,\r\n    httpsUpgrades: 0,\r\n    cookies3p: 'allow',\r\n    webrtcBlocked: false,\r\n    fingerprinting: false,\r\n  }),\r\n  'history:search': () => [],\r\n  'performance:battery:update': () => ({ success: true }),\r\n  'session:lastSnapshotSummary': () => null,\r\n  'telemetry:getStatus': () => ({ optIn: false, enabled: false }),\r\n  'telemetry:getSummary': () => ({\r\n    optIn: false,\r\n    enabled: false,\r\n    crashCount: 0,\r\n    lastCrashAt: null,\r\n    uptimeSeconds: 0,\r\n    perfMetrics: [],\r\n  }),\r\n  'analytics:getStatus': () => ({ optIn: false, enabled: false }),\r\n  'cross-reality:handoff': () => ({ success: false, handoff: null }),\r\n  'cross-reality:queue': () => ({ handoffs: [] }),\r\n  'cross-reality:handoffStatus': () => ({ success: true }),\r\n  'research:queryEnhanced': (payload?: any) => {\r\n    if (!payload?.query) {\r\n      return {\r\n        query: '',\r\n        summary: 'Enter a question to start research.',\r\n        sources: [],\r\n        citations: [],\r\n        confidence: 0,\r\n        language: 'en',\r\n        languageLabel: 'English',\r\n        languageConfidence: 0,\r\n        verification: {\r\n          verified: false,\r\n          claimDensity: 0,\r\n          citationCoverage: 0,\r\n          ungroundedClaims: [],\r\n          hallucinationRisk: 1,\r\n          suggestions: ['Add a research query to continue.'],\r\n        },\r\n        contradictions: [],\r\n      };\r\n    }\r\n    return apiClient.research.queryEnhanced(payload);\r\n  },\r\n};\r\n\r\nconst reportedMissingChannels = new Set<string>();\r\n\r\nfunction getTabsStore() {\r\n  try {\r\n    return typeof useTabsStore.getState === 'function' ? useTabsStore.getState() : undefined;\r\n  } catch {\r\n    return undefined;\r\n  }\r\n}\r\n\r\nexport function deriveTitleFromUrl(url?: string) {\r\n  if (!url || url === 'about:blank') {\r\n    return 'New Tab';\r\n  }\r\n  try {\r\n    const parsed = new URL(url);\r\n    return parsed.hostname || url;\r\n  } catch {\r\n    return url;\r\n  }\r\n}\r\n\r\nfunction getFallback<T>(channel: string, request?: unknown): T | undefined {\r\n  const factory = FALLBACK_CHANNELS[channel];\r\n  if (!factory) return undefined;\r\n  return factory(request) as T;\r\n}\r\n\r\nfunction noteFallback(channel: string, reason: string) {\r\n  if (!IS_DEV) return;\r\n  if (reportedMissingChannels.has(channel)) return;\r\n\r\n  // Don't warn about missing channels in web mode - they're expected\r\n  // Only warn if we're in a runtime that should have IPC (Electron/Tauri)\r\n  const expectsIPC = isElectronRuntime() || isTauriRuntime();\r\n\r\n  if (!expectsIPC) return; // Silent in web mode\r\n\r\n  reportedMissingChannels.add(channel);\r\n  console.warn(`[IPC] Channel ${channel} unavailable (${reason}); using renderer fallback.`);\r\n}\r\n\r\nasync function mapIpcToHttp<TRequest, TResponse = unknown>(\r\n  channel: string,\r\n  request: TRequest,\r\n  schema?: z.ZodSchema<TResponse>\r\n): Promise<TResponse> {\r\n  const normalized = channel.replace('ob://ipc/v1/', '');\r\n\r\n  const handlers: Record<string, (req: any) => Promise<unknown>> = {\r\n    'tabs:list': () => apiClient.tabs.list(),\r\n    'tabs:create': async (req: any) => {\r\n      if (typeof req === 'string') {\r\n        return apiClient.tabs.create({ url: req });\r\n      }\r\n      if (req && typeof req === 'object') {\r\n        const payload = 'url' in req ? req : { url: 'about:blank' };\r\n        return apiClient.tabs.create(payload);\r\n      }\r\n      return apiClient.tabs.create({ url: 'about:blank' });\r\n    },\r\n    'tabs:close': (req: any) => apiClient.tabs.close(req.id),\r\n    'tabs:activate': (req: any) => apiClient.tabs.activate(req.id),\r\n    'tabs:navigate': (req: any) => apiClient.tabs.navigate(req),\r\n    'tabs:goBack': (req: any) => apiClient.tabs.goBack(req.id),\r\n    'tabs:goForward': (req: any) => apiClient.tabs.goForward(req.id),\r\n    'tabs:reload': (req: any) => apiClient.tabs.reload(req.id, req),\r\n    'tabs:stop': (req: any) => apiClient.tabs.stop(req.id),\r\n    'tabs:overlay/start': () => apiClient.tabs.overlayStart(),\r\n    'tabs:overlay/pick': () => apiClient.tabs.overlayGetPick(),\r\n    'tabs:overlay/clear': () => apiClient.tabs.overlayClear(),\r\n    'sessions:list': () => apiClient.sessions.list(),\r\n    'sessions:create': (req: any) => apiClient.sessions.create(req),\r\n    'sessions:getActive': () => apiClient.sessions.getActive(),\r\n    'session:checkRestore': () => apiClient.session.checkRestore(),\r\n    'session:getSnapshot': () => apiClient.session.getSnapshot(),\r\n    'session:dismissRestore': () => apiClient.session.dismissRestore(),\r\n    'system:getStatus': () => apiClient.system.getStatus(),\r\n    'agent:ask': (req: any) => apiClient.agent.ask(req),\r\n    'telemetry:getStatus': () => apiClient.system.getStatus(),\r\n    'research:queryEnhanced': (req: any) => apiClient.research.queryEnhanced(req),\r\n    'search:hybrid': async (req: any) => {\r\n      const response = await fetch(\r\n        `${apiClient.API_BASE_URL || 'http://localhost:3000'}/api/search/hybrid`,\r\n        {\r\n          method: 'POST',\r\n          headers: { 'Content-Type': 'application/json' },\r\n          body: JSON.stringify({\r\n            query: req.query,\r\n            lang: req.language || 'auto',\r\n            maxResults: req.maxResults || 6,\r\n          }),\r\n        }\r\n      );\r\n      if (!response.ok) {\r\n        throw new Error(`Search failed: ${response.status}`);\r\n      }\r\n      return response.json();\r\n    },\r\n  };\r\n\r\n  const handler = handlers[normalized];\r\n  if (!handler) {\r\n    // In web mode, suppress errors for missing mappings - they're expected\r\n    const isWeb =\r\n      typeof window !== 'undefined' && !(window as any).__ELECTRON__ && !(window as any).__TAURI__;\r\n    if (isWeb) {\r\n      // Return a rejected promise that won't be logged\r\n      return Promise.reject(new Error(`No HTTP endpoint mapping for channel: ${normalized}`));\r\n    }\r\n    throw new Error(`No HTTP endpoint mapping for channel: ${normalized}`);\r\n  }\r\n\r\n  const response = await handler(request);\r\n  if (schema && response !== undefined && response !== null) {\r\n    const parsed = schema.safeParse(response);\r\n    if (!parsed.success) {\r\n      throw new Error(`Invalid response: ${parsed.error.message}`);\r\n    }\r\n    return parsed.data;\r\n  }\r\n  return response as TResponse;\r\n}\r\n\r\n/**\r\n * Make a typed IPC call\r\n * @param channel Channel name (without ob://ipc/v1/ prefix)\r\n * @param request Request payload\r\n * @param schema Optional response schema for validation\r\n */\r\n// Plan type for agent\r\nexport interface Plan {\r\n  id: string;\r\n  goal: string;\r\n  steps: Array<{\r\n    id: string;\r\n    action: string;\r\n    args: Record<string, unknown>;\r\n    dependsOn?: string[];\r\n    expectedOutput?: string;\r\n  }>;\r\n  estimatedDuration?: number;\r\n}\r\n\r\n// Track IPC readiness\r\nlet ipcReady = false;\r\nlet ipcReadyResolvers: Array<() => void> = [];\r\n\r\n// Set up IPC ready listener immediately when module loads\r\nif (typeof window !== 'undefined') {\r\n  // Listen for custom event from preload script\r\n  const handleIpcReady = () => {\r\n    // Double-check that window.ipc actually exists before marking as ready\r\n    if (window.ipc && typeof window.ipc.invoke === 'function') {\r\n      ipcReady = true;\r\n      // Resolve all pending promises\r\n      const resolvers = [...ipcReadyResolvers];\r\n      ipcReadyResolvers = [];\r\n      resolvers.forEach(resolve => resolve());\r\n      if (IS_DEV) {\r\n        console.log('[IPC] Ready signal received and window.ipc is available');\r\n      }\r\n    } else {\r\n      if (IS_DEV) {\r\n        console.warn('[IPC] Ready event received but window.ipc is not available');\r\n        console.warn('[IPC] window.ipc:', window.ipc);\r\n        console.warn(\r\n          '[IPC] window keys:',\r\n          Object.keys(window).filter(k => k.includes('ipc') || k.includes('api'))\r\n        );\r\n      }\r\n    }\r\n  };\r\n\r\n  window.addEventListener('ipc:ready', handleIpcReady);\r\n\r\n  // Also check if IPC is already available (in case event fired before listener was added)\r\n  // Poll for window.ipc to appear (preload script might load after this code)\r\n  let pollCount = 0;\r\n  const maxPolls = 50; // Poll for up to 5 seconds (50 * 100ms)\r\n  const pollInterval = setInterval(() => {\r\n    pollCount++;\r\n    if (window.ipc && typeof window.ipc.invoke === 'function') {\r\n      clearInterval(pollInterval);\r\n      if (!ipcReady) {\r\n        handleIpcReady();\r\n      }\r\n    } else if (pollCount >= maxPolls) {\r\n      clearInterval(pollInterval);\r\n      // Only warn in Electron/Tauri mode - silent in web mode\r\n      const expectsIPC = isElectronRuntime() || isTauriRuntime();\r\n      if (IS_DEV && expectsIPC) {\r\n        console.warn('[IPC] window.ipc never appeared after polling');\r\n        console.warn(\r\n          '[IPC] Available window properties:',\r\n          Object.keys(window).filter(\r\n            k => k.includes('ipc') || k.includes('api') || k.includes('electron')\r\n          )\r\n        );\r\n      }\r\n    }\r\n  }, 100);\r\n\r\n  // Also check immediately\r\n  if (window.ipc && typeof window.ipc.invoke === 'function') {\r\n    setTimeout(() => {\r\n      if (!ipcReady) {\r\n        handleIpcReady();\r\n      }\r\n    }, 100);\r\n  }\r\n}\r\n\r\n// Wait for IPC to be ready (with timeout)\r\nasync function waitForIPC(timeout = 10000): Promise<boolean> {\r\n  // In web mode, skip IPC wait entirely - resolve immediately with false\r\n  // This prevents timeout warnings in web mode where IPC is not available\r\n  if (!isElectronRuntime() && !isTauriRuntime()) {\r\n    return Promise.resolve(false);\r\n  }\r\n\r\n  // If already ready, return immediately\r\n  if (\r\n    ipcReady &&\r\n    typeof window !== 'undefined' &&\r\n    window.ipc &&\r\n    typeof window.ipc.invoke === 'function'\r\n  ) {\r\n    return true;\r\n  }\r\n\r\n  // Check if window.ipc exists (even if not marked as ready)\r\n  if (typeof window !== 'undefined' && window.ipc && typeof window.ipc.invoke === 'function') {\r\n    // Mark as ready if IPC bridge exists\r\n    if (!ipcReady) {\r\n      ipcReady = true;\r\n      const resolvers = [...ipcReadyResolvers];\r\n      ipcReadyResolvers = [];\r\n      resolvers.forEach(resolve => resolve());\r\n      if (IS_DEV) {\r\n        console.log('[IPC] Bridge detected and marked as ready');\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  // Wait for ready signal\r\n  return new Promise(resolve => {\r\n    const startTime = Date.now();\r\n\r\n    // If already ready, resolve immediately\r\n    if (ipcReady && window.ipc && typeof window.ipc.invoke === 'function') {\r\n      resolve(true);\r\n      return;\r\n    }\r\n\r\n    // Add resolver to list\r\n    const timeoutId = setTimeout(() => {\r\n      // Remove from list if timeout\r\n      ipcReadyResolvers = ipcReadyResolvers.filter(r => r !== resolver);\r\n      resolve(false);\r\n    }, timeout);\r\n\r\n    const resolver = () => {\r\n      clearTimeout(timeoutId);\r\n      resolve(true);\r\n    };\r\n\r\n    ipcReadyResolvers.push(resolver);\r\n\r\n    // Also poll as fallback - check both ipcReady flag AND window.ipc existence\r\n    const checkInterval = setInterval(() => {\r\n      const hasIpc =\r\n        typeof window !== 'undefined' && window.ipc && typeof window.ipc.invoke === 'function';\r\n      if (ipcReady && hasIpc) {\r\n        clearInterval(checkInterval);\r\n        clearTimeout(timeoutId);\r\n        ipcReadyResolvers = ipcReadyResolvers.filter(r => r !== resolver);\r\n        resolve(true);\r\n      } else if (hasIpc && !ipcReady) {\r\n        // IPC bridge exists but not marked ready - mark it now\r\n        ipcReady = true;\r\n        const allResolvers = [...ipcReadyResolvers];\r\n        ipcReadyResolvers = [];\r\n        allResolvers.forEach(r => r());\r\n        clearInterval(checkInterval);\r\n        clearTimeout(timeoutId);\r\n        if (IS_DEV) {\r\n          console.log('[IPC] Bridge detected during polling and marked as ready');\r\n        }\r\n        resolve(true);\r\n      } else if (Date.now() - startTime > timeout) {\r\n        clearInterval(checkInterval);\r\n        clearTimeout(timeoutId);\r\n        ipcReadyResolvers = ipcReadyResolvers.filter(r => r !== resolver);\r\n        // Don't log IPC timeout warnings in web mode - they're expected\r\n        // Only log if we're actually expecting IPC (Electron/Tauri runtime)\r\n        const expectsIPC = isElectronRuntime() || isTauriRuntime();\r\n        if (IS_DEV && expectsIPC) {\r\n          console.warn(`[IPC] Timeout waiting for IPC bridge (${timeout}ms)`);\r\n        }\r\n        resolve(false);\r\n      }\r\n    }, 100);\r\n  });\r\n}\r\n\r\nexport async function ipcCall<TRequest, TResponse = unknown>(\r\n  channel: string,\r\n  request: TRequest,\r\n  schema?: z.ZodSchema<TResponse>\r\n): Promise<TResponse> {\r\n  const fullChannel = `ob://ipc/v1/${channel}`;\r\n\r\n  // Check if we're in Electron - be lenient, check multiple indicators\r\n  const hasUserAgent = typeof navigator !== 'undefined' && navigator.userAgent;\r\n  const userAgent = hasUserAgent ? navigator.userAgent : '';\r\n  const userAgentHasElectron = userAgent.includes('Electron');\r\n  const hasElectronRuntime = isElectronRuntime();\r\n  // Check for window.ipc OR window.api (legacy API) - both indicate Electron\r\n  const hasWindowIpc =\r\n    typeof window !== 'undefined' &&\r\n    ((window.ipc && typeof window.ipc.invoke === 'function') ||\r\n      (window.api && typeof window.api.ping === 'function'));\r\n\r\n  // Check if we're in a regular web browser (Chrome, Firefox, Safari, Edge)\r\n  // But exclude Electron's Chrome user agent\r\n  const isRegularBrowser =\r\n    (userAgent.includes('Chrome') && !userAgent.includes('Electron')) ||\r\n    userAgent.includes('Firefox') ||\r\n    (userAgent.includes('Safari') && !userAgent.includes('Chrome')) ||\r\n    userAgent.includes('Edg');\r\n\r\n  // If we have window.ipc or window.api, we're definitely in Electron (even if other checks fail)\r\n  // Also, if we're NOT in a regular browser, assume Electron (more aggressive detection)\r\n  const isElectron =\r\n    hasElectronRuntime || userAgentHasElectron || hasWindowIpc || !isRegularBrowser;\r\n\r\n  // Wait for IPC to be ready (with longer timeout for first call)\r\n  const isReady = await waitForIPC(8000);\r\n\r\n  // Check if IPC bridge is actually available\r\n  // Migration: Use HTTP API client if not in Electron runtime\r\n  if (!isElectron) {\r\n    // Map IPC channels to HTTP API calls\r\n    try {\r\n      return await mapIpcToHttp<TRequest, TResponse>(fullChannel, request, schema);\r\n    } catch (error) {\r\n      // Fallback to default fallback if HTTP call fails\r\n      const normalized = fullChannel.replace('ob://ipc/v1/', '');\r\n      const fallback = getFallback<TResponse>(normalized, request);\r\n      if (fallback !== undefined) {\r\n        noteFallback(normalized, 'HTTP API unavailable, using fallback');\r\n        return fallback;\r\n      }\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  // Try to use window.ipc first, but also check if we can access ipcRenderer directly\r\n  let ipcBridge = window.ipc;\r\n\r\n  // If window.ipc is not available, try to create a bridge from window.api or direct access\r\n  if (!ipcBridge || typeof ipcBridge.invoke !== 'function') {\r\n    // Check if we can access Electron APIs directly (shouldn't work with context isolation, but worth trying)\r\n    if (typeof window !== 'undefined' && (window as any).require) {\r\n      try {\r\n        const { ipcRenderer } = (window as any).require('electron');\r\n        if (ipcRenderer && typeof ipcRenderer.invoke === 'function') {\r\n          // Create a temporary bridge\r\n          ipcBridge = {\r\n            invoke: async (ch: string, req: unknown) => {\r\n              const response = await ipcRenderer.invoke(ch, req);\r\n              if (response && typeof response === 'object' && 'ok' in response) {\r\n                if (!response.ok) {\r\n                  throw new Error(response.error || 'IPC call failed');\r\n                }\r\n                return response.data;\r\n              }\r\n              return response;\r\n            },\r\n            on: () => {},\r\n            removeListener: () => {},\r\n          };\r\n        }\r\n      } catch {\r\n        // context isolation prevents direct access, that's expected\r\n      }\r\n    }\r\n  }\r\n\r\n  if (!isReady || !ipcBridge || typeof ipcBridge.invoke !== 'function') {\r\n    // Always try fallback first if available, regardless of Electron detection\r\n    const fallback = getFallback<TResponse>(channel, request);\r\n    if (fallback !== undefined) {\r\n      const reason = !isElectron && !hasWindowIpc ? 'non-Electron runtime' : 'IPC bridge not ready';\r\n      noteFallback(channel, reason);\r\n      return fallback;\r\n    }\r\n\r\n    // If no fallback and we're in Electron, this is an error\r\n    if (IS_DEV) {\r\n      console.warn(\r\n        `[IPC] Channel ${channel} unavailable (IPC bridge not ready after 8s, no fallback available)`\r\n      );\r\n      console.warn(\r\n        `[IPC] Debug: isElectron=${isElectron}, hasWindowIpc=${hasWindowIpc}, userAgentHasElectron=${userAgentHasElectron}, isReady=${isReady}`\r\n      );\r\n      console.warn(`[IPC] window.ipc:`, window.ipc);\r\n      console.warn(`[IPC] window.api:`, window.api);\r\n      console.warn(`[IPC] typeof window:`, typeof window);\r\n    }\r\n    throw new Error('IPC unavailable');\r\n  }\r\n\r\n  try {\r\n    const response = await ipcBridge.invoke(fullChannel, request);\r\n\r\n    if (schema && response !== undefined && response !== null) {\r\n      const parsed = schema.safeParse(response);\r\n      if (!parsed.success) {\r\n        throw new Error(`Invalid response: ${parsed.error.message}`);\r\n      }\r\n      return parsed.data;\r\n    }\r\n\r\n    return response as TResponse;\r\n  } catch (error) {\r\n    const message = error instanceof Error ? error.message : String(error);\r\n    if (message.includes('No handler registered')) {\r\n      const fallback = getFallback<TResponse>(channel, request);\r\n      if (fallback !== undefined) {\r\n        noteFallback(channel, 'handler not registered');\r\n        return fallback;\r\n      }\r\n    }\r\n\r\n    if (IS_DEV && !reportedMissingChannels.has(channel)) {\r\n      reportedMissingChannels.add(channel);\r\n      console.warn(`IPC call failed for ${channel}:`, message);\r\n    }\r\n\r\n    if (error instanceof Error) {\r\n      throw error;\r\n    }\r\n    throw new Error(message);\r\n  }\r\n}\r\n\r\n/**\r\n * Typed IPC client with pre-configured channels\r\n */\r\nexport const ipc = {\r\n  windowControl: {\r\n    toggleFullscreen: (force?: boolean) =>\r\n      ipcCall<{ fullscreen?: boolean }, { success: boolean; fullscreen: boolean }>(\r\n        'app:toggleFullscreen',\r\n        {\r\n          fullscreen: force,\r\n        }\r\n      ).catch(error => {\r\n        if (IS_DEV) {\r\n          console.warn('[IPC] Failed to toggle fullscreen:', error);\r\n        }\r\n        return { success: false, fullscreen: false };\r\n      }),\r\n    setFullscreen: (fullscreen: boolean) =>\r\n      ipcCall<{ fullscreen: boolean }, { success: boolean; fullscreen: boolean }>(\r\n        'app:setFullscreen',\r\n        { fullscreen }\r\n      ).catch(error => {\r\n        if (IS_DEV) {\r\n          console.warn('[IPC] Failed to set fullscreen:', error);\r\n        }\r\n        return { success: false, fullscreen };\r\n      }),\r\n    getState: () =>\r\n      ipcCall<unknown, { fullscreen: boolean }>('app:getWindowState', {}).catch(() => ({\r\n        fullscreen: !!document.fullscreenElement,\r\n      })),\r\n  },\r\n  tabs: {\r\n    create: async (\r\n      input?:\r\n        | string\r\n        | {\r\n            url?: string;\r\n            profileId?: string;\r\n            mode?: 'normal' | 'ghost' | 'private';\r\n            containerId?: string;\r\n            tabId?: string;\r\n            activate?: boolean;\r\n            createdAt?: number;\r\n            lastActiveAt?: number;\r\n            sessionId?: string;\r\n            fromSessionRestore?: boolean;\r\n          }\r\n    ) => {\r\n      try {\r\n        // Wait for IPC to be ready\r\n        await waitForIPC(5000);\r\n        const payload = typeof input === 'string' ? { url: input } : input || {};\r\n        const result = await ipcCall('tabs:create', {\r\n          url: payload.url || 'about:blank',\r\n          profileId: payload.profileId,\r\n          mode: payload.mode,\r\n          containerId: payload.containerId,\r\n          tabId: payload.tabId,\r\n          activate: payload.activate,\r\n          createdAt: payload.createdAt,\r\n          lastActiveAt: payload.lastActiveAt,\r\n          sessionId: payload.sessionId,\r\n          fromSessionRestore: payload.fromSessionRestore,\r\n        });\r\n        if (IS_DEV) {\r\n          console.log('[IPC] Tab created:', result);\r\n        }\r\n        return result;\r\n      } catch (error) {\r\n        if (IS_DEV) {\r\n          console.error('Failed to create tab:', error);\r\n        }\r\n        // Return a mock result to prevent UI from breaking\r\n        return { id: `temp-${Date.now()}`, success: false };\r\n      }\r\n    },\r\n    close: async (request: { id: string }) => {\r\n      try {\r\n        const response = await ipcCall('tabs:close', request);\r\n        if (IS_DEV) {\r\n          console.log('[IPC] tabs.close response:', response);\r\n        }\r\n        return response;\r\n      } catch (err) {\r\n        if (IS_DEV) {\r\n          console.warn('Failed to close tab:', err);\r\n        }\r\n        throw err;\r\n      }\r\n    },\r\n    activate: async (request: { id: string }) => {\r\n      try {\r\n        const response = await ipcCall('tabs:activate', request);\r\n        if (IS_DEV) {\r\n          console.log('[IPC] tabs.activate response:', response);\r\n        }\r\n        return response;\r\n      } catch (err) {\r\n        if (IS_DEV) {\r\n          console.warn('Failed to activate tab:', err);\r\n        }\r\n        throw err;\r\n      }\r\n    },\r\n    navigate: (id: string, url: string) =>\r\n      ipcCall('tabs:navigate', { id, url }).catch(err => console.warn('Failed to navigate:', err)),\r\n    goBack: (id: string) =>\r\n      ipcCall('tabs:goBack', { id }).catch(err => console.warn('Failed to go back:', err)),\r\n    goForward: (id: string) =>\r\n      ipcCall('tabs:goForward', { id }).catch(err => console.warn('Failed to go forward:', err)),\r\n    setMemoryCap: async (tabId: string, capMB: number) => {\r\n      try {\r\n        return await ipcCall('tabs:setMemoryCap', { tabId, capMB });\r\n      } catch (err) {\r\n        if (IS_DEV) {\r\n          console.warn('Failed to set memory cap:', err);\r\n        }\r\n        throw err;\r\n      }\r\n    },\r\n    devtools: (id: string) => ipcCall('tabs:devtools', { id }),\r\n    zoomIn: (id: string) =>\r\n      ipcCall<{ id: string }, { success: boolean; error?: string }>('tabs:zoomIn', { id }),\r\n    zoomOut: (id: string) =>\r\n      ipcCall<{ id: string }, { success: boolean; error?: string }>('tabs:zoomOut', { id }),\r\n    zoomReset: (id: string) =>\r\n      ipcCall<{ id: string }, { success: boolean; error?: string }>('tabs:zoomReset', { id }),\r\n    screenshot: (id?: string) =>\r\n      ipcCall<{ id?: string }, { success: boolean; path?: string; error?: string }>(\r\n        'tabs:screenshot',\r\n        { id }\r\n      ),\r\n    capturePreview: (request: { id: string; maxWidth?: number; quality?: number }) =>\r\n      ipcCall<\r\n        { id: string; maxWidth?: number; quality?: number },\r\n        { success: boolean; dataUrl?: string; width?: number; height?: number; error?: string }\r\n      >('tabs:capturePreview', request),\r\n    pip: (id?: string, enabled?: boolean) =>\r\n      ipcCall<{ id?: string; enabled?: boolean }, { success: boolean; error?: string }>(\r\n        'tabs:pip',\r\n        { id, enabled }\r\n      ),\r\n    find: (id?: string) =>\r\n      ipcCall<{ id?: string }, { success: boolean; error?: string }>('tabs:find', { id }),\r\n    reload: (id: string, options?: { hard?: boolean }) =>\r\n      ipcCall('tabs:reload', { id, ...(options ?? {}) }).catch(err =>\r\n        console.warn('Failed to reload:', err)\r\n      ),\r\n    stop: (id: string) =>\r\n      ipcCall('tabs:stop', { id }).catch(err => console.warn('Failed to stop loading:', err)),\r\n    list: async () => {\r\n      try {\r\n        const result = await ipcCall<\r\n          unknown,\r\n          Array<{\r\n            id: string;\r\n            title: string;\r\n            active: boolean;\r\n            url?: string;\r\n            mode?: 'normal' | 'ghost' | 'private';\r\n            containerId?: string;\r\n            containerName?: string;\r\n            containerColor?: string;\r\n            createdAt?: number;\r\n            lastActiveAt?: number;\r\n            sessionId?: string;\r\n            profileId?: string;\r\n            sleeping?: boolean;\r\n          }>\r\n        >('tabs:list', {});\r\n        return Array.isArray(result) ? result : [];\r\n      } catch (error) {\r\n        console.warn('Failed to list tabs:', error);\r\n        return [];\r\n      }\r\n    },\r\n    predictiveGroups: async (options?: { windowId?: number; force?: boolean }) => {\r\n      try {\r\n        const response = await ipcCall<\r\n          { windowId?: number; force?: boolean },\r\n          {\r\n            groups?: Array<{ id: string; label: string; tabIds: string[]; confidence?: number }>;\r\n            prefetch?: Array<{ tabId: string; url: string; reason?: string; confidence?: number }>;\r\n            summary?: { generatedAt?: string; explanation?: string };\r\n          }\r\n        >('tabs:predictiveGroups', options ?? {});\r\n\r\n        return {\r\n          groups: Array.isArray(response?.groups) ? response.groups : [],\r\n          prefetch: Array.isArray(response?.prefetch) ? response.prefetch : [],\r\n          summary: response?.summary,\r\n        };\r\n      } catch (error) {\r\n        if (IS_DEV) {\r\n          console.warn('Failed to fetch predictive tab groups:', error);\r\n        }\r\n        return { groups: [], prefetch: [], summary: undefined } as const;\r\n      }\r\n    },\r\n    moveToWorkspace: (request: { tabId: string; workspaceId: string; label?: string }) =>\r\n      ipcCall('tabs:moveToWorkspace', request),\r\n    hibernate: (id: string) => ipcCall('tabs:hibernate', { id }),\r\n    wake: (id: string) =>\r\n      ipcCall<{ id: string }, { success: boolean; error?: string }>('tabs:wake', { id }),\r\n    burn: (id: string) => ipcCall('tabs:burn', { id }),\r\n    onUpdated: (\r\n      callback: (\r\n        tabs: Array<{\r\n          id: string;\r\n          title: string;\r\n          active: boolean;\r\n          url?: string;\r\n          mode?: 'normal' | 'ghost' | 'private';\r\n          containerId?: string;\r\n          containerName?: string;\r\n          containerColor?: string;\r\n          createdAt?: number;\r\n          lastActiveAt?: number;\r\n          sessionId?: string;\r\n          profileId?: string;\r\n          sleeping?: boolean;\r\n        }>\r\n      ) => void\r\n    ) => {\r\n      if ((window.ipc as any)?.on) {\r\n        (window.ipc as any).on('tabs:updated', (_event: any, tabs: any[]) => callback(tabs));\r\n      }\r\n    },\r\n    setContainer: (id: string, containerId: string) =>\r\n      ipcCall<{ id: string; containerId: string }, { success: boolean; error?: string }>(\r\n        'tabs:setContainer',\r\n        {\r\n          id,\r\n          containerId,\r\n        }\r\n      ),\r\n    reorder: (tabId: string, newIndex: number) =>\r\n      ipcCall<{ tabId: string; newIndex: number }, { success: boolean; error?: string }>(\r\n        'tabs:reorder',\r\n        {\r\n          tabId,\r\n          newIndex,\r\n        }\r\n      ),\r\n    reopenClosed: (index?: number) =>\r\n      ipcCall<{ index?: number }, { success: boolean; tabId?: string; error?: string }>(\r\n        'tabs:reopenClosed',\r\n        {\r\n          index,\r\n        }\r\n      ),\r\n    setPinned: (request: { id: string; pinned: boolean }) =>\r\n      ipcCall<\r\n        { id: string; pinned: boolean },\r\n        { success: boolean; error?: string; unchanged?: boolean }\r\n      >('tabs:setPinned', request),\r\n    listClosed: () =>\r\n      ipcCall<\r\n        unknown,\r\n        Array<{\r\n          id: string;\r\n          url: string;\r\n          title: string;\r\n          containerId?: string;\r\n          containerName?: string;\r\n          containerColor?: string;\r\n          mode?: 'normal' | 'ghost' | 'private';\r\n          closedAt: number;\r\n        }>\r\n      >('tabs:listClosed', {}),\r\n    getContext: (tabId?: string) =>\r\n      ipcCall<\r\n        { tabId?: string },\r\n        {\r\n          success: boolean;\r\n          context?: { tabId: string; url: string; title: string; pageText: string; domain: string };\r\n          error?: string;\r\n        }\r\n      >('tabs:getContext', { tabId }),\r\n  },\r\n  workflow: {\r\n    launch: (query: string) =>\r\n      ipcCall<\r\n        { query: string },\r\n        {\r\n          success: boolean;\r\n          workflowId?: string;\r\n          workflowName?: string;\r\n          results?: any[];\r\n          error?: string;\r\n        }\r\n      >('workflow:launch', { query }),\r\n    list: () =>\r\n      ipcCall<\r\n        unknown,\r\n        { success: boolean; workflows?: Array<{ id: string; name: string; description: string }> }\r\n      >('workflow:list', {}),\r\n  },\r\n  tor: {\r\n    async status() {\r\n      try {\r\n        await waitForIPC(3000);\r\n        return await ipcCall('tor:status', {});\r\n      } catch (error) {\r\n        if (IS_DEV) {\r\n          console.warn('[IPC] tor.status falling back to stub', error);\r\n        }\r\n        return {\r\n          running: false,\r\n          bootstrapped: false,\r\n          circuitEstablished: false,\r\n          progress: 0,\r\n          stub: true,\r\n          error: 'Tor bridge unavailable',\r\n        };\r\n      }\r\n    },\r\n    async start() {\r\n      try {\r\n        await waitForIPC(3000);\r\n        return await ipcCall('tor:start', {});\r\n      } catch (error) {\r\n        if (IS_DEV) {\r\n          console.warn('[IPC] tor.start falling back to stub', error);\r\n        }\r\n        return { stub: true, warning: 'Tor bridge unavailable (stub mode)' };\r\n      }\r\n    },\r\n    async stop() {\r\n      try {\r\n        await waitForIPC(3000);\r\n        return await ipcCall('tor:stop', {});\r\n      } catch (error) {\r\n        if (IS_DEV) {\r\n          console.warn('[IPC] tor.stop failed in stub mode', error);\r\n        }\r\n        return { stub: true };\r\n      }\r\n    },\r\n    async newIdentity() {\r\n      try {\r\n        await waitForIPC(3000);\r\n        return await ipcCall('tor:newIdentity', {});\r\n      } catch (error) {\r\n        if (IS_DEV) {\r\n          console.warn('[IPC] tor.newIdentity failed in stub mode', error);\r\n        }\r\n        return { stub: true };\r\n      }\r\n    },\r\n    async getProxy() {\r\n      try {\r\n        await waitForIPC(3000);\r\n        return await ipcCall<unknown, { proxy: string | null; stub?: boolean }>('tor:getProxy', {});\r\n      } catch (error) {\r\n        if (IS_DEV) {\r\n          console.warn('[IPC] tor.getProxy falling back to stub', error);\r\n        }\r\n        return { proxy: null, stub: true };\r\n      }\r\n    },\r\n  },\r\n  vpn: {\r\n    async status() {\r\n      try {\r\n        await waitForIPC(3000);\r\n        // Add timeout to prevent hanging\r\n        const timeoutPromise = new Promise((_, reject) => {\r\n          setTimeout(() => reject(new Error('VPN status timeout')), 4000);\r\n        });\r\n        return await Promise.race([ipcCall('vpn:status', {}), timeoutPromise]);\r\n      } catch (error) {\r\n        // Silently fall back to stub - VPN status is non-critical\r\n        // Only log in dev mode if it's not a timeout\r\n        if (IS_DEV && !(error instanceof Error && error.message.includes('timeout'))) {\r\n          console.debug('[IPC] vpn.status falling back to stub', error);\r\n        }\r\n        return {\r\n          connected: false,\r\n          type: 'stub',\r\n          name: 'Not connected',\r\n          stub: true,\r\n        };\r\n      }\r\n    },\r\n    async check() {\r\n      try {\r\n        await waitForIPC(3000);\r\n        return await ipcCall('vpn:check', {});\r\n      } catch (error) {\r\n        if (IS_DEV) {\r\n          console.warn('[IPC] vpn.check falling back to stub', error);\r\n        }\r\n        return {\r\n          connected: false,\r\n          type: 'stub',\r\n          name: 'Not connected',\r\n          stub: true,\r\n        };\r\n      }\r\n    },\r\n    listProfiles: () =>\r\n      ipcCall<unknown, Array<{ id: string; name: string; type: string; server?: string }>>(\r\n        'vpn:listProfiles',\r\n        {}\r\n      ),\r\n    connect: (id: string) =>\r\n      ipcCall<\r\n        { id: string },\r\n        { connected: boolean; type?: string; name?: string; interface?: string; server?: string }\r\n      >('vpn:connect', { id }),\r\n    disconnect: () =>\r\n      ipcCall<\r\n        unknown,\r\n        { connected: boolean; type?: string; name?: string; interface?: string; server?: string }\r\n      >('vpn:disconnect', {}),\r\n  },\r\n  containers: {\r\n    list: () =>\r\n      ipcCall<\r\n        unknown,\r\n        Array<{\r\n          id: string;\r\n          name: string;\r\n          color: string;\r\n          icon?: string;\r\n          description?: string;\r\n          scope: string;\r\n          persistent: boolean;\r\n          system?: boolean;\r\n        }>\r\n      >('containers:list', {}),\r\n    getActive: () =>\r\n      ipcCall<\r\n        unknown,\r\n        {\r\n          id: string;\r\n          name: string;\r\n          color: string;\r\n          icon?: string;\r\n          description?: string;\r\n          scope?: string;\r\n          persistent?: boolean;\r\n          system?: boolean;\r\n        }\r\n      >('containers:getActive', {}),\r\n    setActive: (containerId: string) =>\r\n      ipcCall<\r\n        { containerId: string },\r\n        {\r\n          id: string;\r\n          name: string;\r\n          color: string;\r\n          icon?: string;\r\n          description?: string;\r\n          scope?: string;\r\n          persistent?: boolean;\r\n          system?: boolean;\r\n        }\r\n      >('containers:setActive', { containerId }),\r\n    create: (payload: { name: string; color?: string; icon?: string }) =>\r\n      ipcCall<\r\n        { name: string; color?: string; icon?: string },\r\n        {\r\n          id: string;\r\n          name: string;\r\n          color: string;\r\n          icon?: string;\r\n          description?: string;\r\n          scope?: string;\r\n          persistent?: boolean;\r\n          system?: boolean;\r\n        }\r\n      >('containers:create', payload),\r\n    getPermissions: (containerId: string) =>\r\n      ipcCall<{ containerId: string }, { containerId: string; permissions: string[] }>(\r\n        'containers:getPermissions',\r\n        { containerId }\r\n      ),\r\n    setPermission: (\r\n      containerId: string,\r\n      permission: 'media' | 'display-capture' | 'notifications' | 'fullscreen',\r\n      enabled: boolean\r\n    ) =>\r\n      ipcCall<\r\n        {\r\n          containerId: string;\r\n          permission: 'media' | 'display-capture' | 'notifications' | 'fullscreen';\r\n          enabled: boolean;\r\n        },\r\n        { containerId: string; permissions: string[] }\r\n      >('containers:setPermission', { containerId, permission, enabled }),\r\n    getSitePermissions: (containerId: string) =>\r\n      ipcCall<\r\n        { containerId: string },\r\n        Array<{\r\n          permission: 'media' | 'display-capture' | 'notifications' | 'fullscreen';\r\n          origins: string[];\r\n        }>\r\n      >('containers:getSitePermissions', { containerId }),\r\n    allowSitePermission: (\r\n      containerId: string,\r\n      permission: 'media' | 'display-capture' | 'notifications' | 'fullscreen',\r\n      origin: string\r\n    ) =>\r\n      ipcCall<\r\n        {\r\n          containerId: string;\r\n          permission: 'media' | 'display-capture' | 'notifications' | 'fullscreen';\r\n          origin: string;\r\n        },\r\n        Array<{\r\n          permission: 'media' | 'display-capture' | 'notifications' | 'fullscreen';\r\n          origins: string[];\r\n        }>\r\n      >('containers:allowSitePermission', { containerId, permission, origin }),\r\n    revokeSitePermission: (\r\n      containerId: string,\r\n      permission: 'media' | 'display-capture' | 'notifications' | 'fullscreen',\r\n      origin: string\r\n    ) =>\r\n      ipcCall<\r\n        {\r\n          containerId: string;\r\n          permission: 'media' | 'display-capture' | 'notifications' | 'fullscreen';\r\n          origin: string;\r\n        },\r\n        Array<{\r\n          permission: 'media' | 'display-capture' | 'notifications' | 'fullscreen';\r\n          origins: string[];\r\n        }>\r\n      >('containers:revokeSitePermission', { containerId, permission, origin }),\r\n  },\r\n  ui: {\r\n    setChromeOffsets: async (\r\n      offsets: Partial<{ top: number; bottom: number; left: number; right: number }>\r\n    ) => {\r\n      try {\r\n        return await ipcCall('ui:setChromeOffsets', offsets);\r\n      } catch (err) {\r\n        if (IS_DEV) {\r\n          console.warn('[IPC] Failed to set chrome offsets:', err);\r\n        }\r\n        return { success: false };\r\n      }\r\n    },\r\n  },\r\n  proxy: {\r\n    set: (config: {\r\n      type?: 'socks5' | 'http';\r\n      host?: string;\r\n      port?: number;\r\n      username?: string;\r\n      password?: string;\r\n      tabId?: string;\r\n      profileId?: string;\r\n      proxyRules?: string;\r\n      mode?: string;\r\n    }) => ipcCall('proxy:set', config),\r\n    status: () =>\r\n      ipcCall<unknown, { healthy: boolean; killSwitchEnabled: boolean }>('proxy:status', {}),\r\n    getForTab: (tabId: string) =>\r\n      ipcCall<unknown, { proxy: { type: string; host: string; port: number } | null }>(\r\n        'proxy:getForTab',\r\n        { tabId }\r\n      ),\r\n  },\r\n  profiles: {\r\n    create: (\r\n      input: string | { name: string; proxy?: unknown; color?: string },\r\n      proxy?: unknown\r\n    ) => {\r\n      if (typeof input === 'string') {\r\n        return ipcCall('profiles:create', { name: input, proxy });\r\n      }\r\n      return ipcCall('profiles:create', input);\r\n    },\r\n    list: () =>\r\n      ipcCall<\r\n        unknown,\r\n        Array<{\r\n          id: string;\r\n          name: string;\r\n          createdAt: number;\r\n          proxy?: unknown;\r\n          kind?: 'default' | 'work' | 'personal' | 'custom';\r\n          color?: string;\r\n          system?: boolean;\r\n          policy?: {\r\n            allowDownloads: boolean;\r\n            allowPrivateWindows: boolean;\r\n            allowGhostTabs: boolean;\r\n            allowScreenshots: boolean;\r\n            allowClipping: boolean;\r\n          };\r\n          description?: string;\r\n        }>\r\n      >('profiles:list', {}),\r\n    get: (id: string) =>\r\n      ipcCall<\r\n        { id: string },\r\n        {\r\n          id: string;\r\n          name: string;\r\n          createdAt: number;\r\n          proxy?: unknown;\r\n          kind?: 'default' | 'work' | 'personal' | 'custom';\r\n          color?: string;\r\n          system?: boolean;\r\n          policy?: {\r\n            allowDownloads: boolean;\r\n            allowPrivateWindows: boolean;\r\n            allowGhostTabs: boolean;\r\n            allowScreenshots: boolean;\r\n            allowClipping: boolean;\r\n          };\r\n          description?: string;\r\n        }\r\n      >('profiles:get', { id }),\r\n    delete: (id: string) => ipcCall('profiles:delete', { id }),\r\n    updateProxy: (profileId: string, proxy?: unknown) =>\r\n      ipcCall('profiles:updateProxy', { profileId, proxy }),\r\n    setActive: (profileId: string) =>\r\n      ipcCall<\r\n        { profileId: string },\r\n        {\r\n          id: string;\r\n          name: string;\r\n          color?: string;\r\n          kind?: 'default' | 'work' | 'personal' | 'custom';\r\n          system?: boolean;\r\n          policy?: {\r\n            allowDownloads: boolean;\r\n            allowPrivateWindows: boolean;\r\n            allowGhostTabs: boolean;\r\n            allowScreenshots: boolean;\r\n            allowClipping: boolean;\r\n          };\r\n          description?: string;\r\n        }\r\n      >('profiles:setActive', { profileId }),\r\n    getActive: () =>\r\n      ipcCall<\r\n        unknown,\r\n        {\r\n          id: string;\r\n          name: string;\r\n          color?: string;\r\n          kind?: 'default' | 'work' | 'personal' | 'custom';\r\n          system?: boolean;\r\n          policy?: {\r\n            allowDownloads: boolean;\r\n            allowPrivateWindows: boolean;\r\n            allowGhostTabs: boolean;\r\n            allowScreenshots: boolean;\r\n            allowClipping: boolean;\r\n          };\r\n          description?: string;\r\n        }\r\n      >('profiles:getActive', {}),\r\n    getPolicy: (profileId?: string) =>\r\n      ipcCall<\r\n        { profileId?: string },\r\n        {\r\n          allowDownloads: boolean;\r\n          allowPrivateWindows: boolean;\r\n          allowGhostTabs: boolean;\r\n          allowScreenshots: boolean;\r\n          allowClipping: boolean;\r\n        }\r\n      >('profiles:getPolicy', profileId ? { profileId } : ({} as Record<string, never>)),\r\n  },\r\n  games: {\r\n    createSandbox: (payload: { gameId: string; url: string; title?: string }) =>\r\n      ipcCall<\r\n        { gameId: string; url: string; title?: string },\r\n        {\r\n          sandboxId: string;\r\n          partition?: string;\r\n          url: string;\r\n          hardened?: boolean;\r\n          createdAt: number;\r\n        }\r\n      >('games:sandbox:create', payload),\r\n    destroySandbox: (payload: { sandboxId: string }) =>\r\n      ipcCall<{ sandboxId: string }, { success: boolean; error?: string }>(\r\n        'games:sandbox:destroy',\r\n        payload\r\n      ),\r\n    reportMetrics: (payload: {\r\n      sandboxId: string;\r\n      metrics: { fps?: number; droppedFrames?: number; memoryMb?: number; cpuPercent?: number };\r\n    }) =>\r\n      ipcCall<\r\n        {\r\n          sandboxId: string;\r\n          metrics: { fps?: number; droppedFrames?: number; memoryMb?: number; cpuPercent?: number };\r\n        },\r\n        { success: boolean; error?: string }\r\n      >('games:sandbox:metrics', payload),\r\n  },\r\n  telemetry: {\r\n    setOptIn: (optIn: boolean) => {\r\n      // Always return success, even if IPC fails (non-blocking for onboarding)\r\n      return ipcCall<{ optIn: boolean }, { success: boolean }>('telemetry:setOptIn', {\r\n        optIn,\r\n      }).catch(() => ({ success: true })); // Fallback to success if IPC fails\r\n    },\r\n    getStatus: () =>\r\n      ipcCall<Record<string, never>, { optIn: boolean; enabled: boolean }>(\r\n        'telemetry:getStatus',\r\n        {} as Record<string, never>\r\n      ).catch(() => ({\r\n        optIn: false,\r\n        enabled: false,\r\n      })),\r\n    getSummary: () =>\r\n      ipcCall<\r\n        Record<string, never>,\r\n        {\r\n          optIn: boolean;\r\n          enabled: boolean;\r\n          crashCount: number;\r\n          lastCrashAt: number | null;\r\n          uptimeSeconds: number;\r\n          perfMetrics: Array<{\r\n            metric: string;\r\n            samples: number;\r\n            avg: number;\r\n            p95: number;\r\n            last: number;\r\n            unit: string;\r\n          }>;\r\n        }\r\n      >('telemetry:getSummary', {} as Record<string, never>).catch(() => ({\r\n        optIn: false,\r\n        enabled: false,\r\n        crashCount: 0,\r\n        lastCrashAt: null,\r\n        uptimeSeconds: 0,\r\n        perfMetrics: [],\r\n      })),\r\n    trackPerf: (metric: string, value: number, unit?: 'ms' | 'MB' | '%') =>\r\n      ipcCall<{ metric: string; value: number; unit?: 'ms' | 'MB' | '%' }, { success: boolean }>(\r\n        'telemetry:trackPerf',\r\n        { metric, value, unit }\r\n      ),\r\n    trackFeature: (feature: string, action?: string) =>\r\n      ipcCall<{ feature: string; action?: string }, { success: boolean }>(\r\n        'telemetry:trackFeature',\r\n        { feature, action }\r\n      ),\r\n  },\r\n  analytics: {\r\n    setOptIn: (optIn: boolean) =>\r\n      ipcCall<{ optIn: boolean }, { success: boolean }>('analytics:setOptIn', { optIn }).catch(\r\n        () => ({ success: true })\r\n      ),\r\n    getStatus: () =>\r\n      ipcCall<Record<string, never>, { optIn: boolean; enabled: boolean }>(\r\n        'analytics:getStatus',\r\n        {}\r\n      ).catch(() => ({\r\n        optIn: false,\r\n        enabled: false,\r\n      })),\r\n    track: (type: string, payload?: Record<string, unknown>) =>\r\n      ipcCall<{ type: string; payload?: Record<string, unknown> }, { success: boolean }>(\r\n        'analytics:track',\r\n        { type, payload }\r\n      ).catch(() => ({\r\n        success: false,\r\n      })),\r\n  },\r\n  settings: {\r\n    get: () => ipcCall<unknown, unknown>('settings:get', {}),\r\n    set: (path: string[], value: unknown) => ipcCall('settings:set', { path, value }),\r\n    reset: () => ipcCall<unknown, { success: boolean; settings?: unknown }>('settings:reset', {}),\r\n    getCategory: (category: string) =>\r\n      ipcCall<{ category: string }, unknown>('settings:getCategory', { category }),\r\n    setCategory: (category: string, values: Record<string, unknown>) =>\r\n      ipcCall<\r\n        { category: string; values: Record<string, unknown> },\r\n        { success: boolean; settings?: unknown }\r\n      >('settings:setCategory', { category, values }),\r\n    exportAll: () =>\r\n      ipcCall<unknown, { success: boolean; path?: string; canceled?: boolean }>(\r\n        'settings:exportAll',\r\n        {}\r\n      ),\r\n    importAll: () =>\r\n      ipcCall<unknown, { success: boolean; path?: string; settings?: unknown; canceled?: boolean }>(\r\n        'settings:importAll',\r\n        {}\r\n      ),\r\n    exportFile: () =>\r\n      ipcCall<unknown, { success: boolean; path?: string; canceled?: boolean }>(\r\n        'settings:exportAll',\r\n        {}\r\n      ),\r\n    importFile: () =>\r\n      ipcCall<unknown, { success: boolean; path?: string; settings?: unknown; canceled?: boolean }>(\r\n        'settings:importAll',\r\n        {}\r\n      ),\r\n  },\r\n  diagnostics: {\r\n    openLogs: () => ipcCall<unknown, { success: boolean }>('diagnostics:openLogs', {}),\r\n    copyDiagnostics: () => ipcCall<unknown, { diagnostics: string }>('diagnostics:copy', {}),\r\n  },\r\n  agent: {\r\n    createTask: (task: unknown) => ipcCall('agent:createTask', task),\r\n    generatePlan: (taskId: string, observations?: unknown[]) =>\r\n      ipcCall('agent:generatePlan', { taskId, observations }),\r\n    executeTask: (taskId: string, confirmSteps?: string[]) =>\r\n      ipcCall('agent:executeTask', { taskId, confirmSteps }),\r\n    cancelTask: (taskId: string) => ipcCall('agent:cancelTask', { taskId }),\r\n    getStatus: (taskId: string) => ipcCall('agent:getStatus', { taskId }),\r\n    ask: (query: string, context?: { url?: string; text?: string }) =>\r\n      ipcCall<\r\n        { query: string; context?: { url?: string; text?: string } },\r\n        { answer: string; sources?: string[] }\r\n      >('agent:ask', { query, context }),\r\n    askWithScrape: (payload: {\r\n      url: string;\r\n      question: string;\r\n      task?: 'summarize' | 'qa' | 'threat';\r\n      waitFor?: number;\r\n    }) =>\r\n      ipcCall<\r\n        { url: string; question: string; task?: 'summarize' | 'qa' | 'threat'; waitFor?: number },\r\n        {\r\n          jobId: string;\r\n          task?: string;\r\n          status?: 'complete' | 'enqueued';\r\n          answer?: string;\r\n          summary?: string;\r\n          highlights?: string[];\r\n          model?: string | { name?: string };\r\n          sources?: string[];\r\n          scrape: { status: number; cached: boolean; fetchedAt?: string };\r\n        }\r\n      >('agent:askWithScrape', payload),\r\n    deepResearch: (request: {\r\n      query: string;\r\n      maxSources?: number;\r\n      outputFormat?: 'json' | 'csv' | 'markdown';\r\n      includeCitations?: boolean;\r\n    }) => ipcCall('agent:deepResearch', request),\r\n    stream: {\r\n      start: (\r\n        query: string,\r\n        options?: { model?: string; temperature?: number; maxTokens?: number }\r\n      ) => ipcCall('agent:stream:start', { query, ...options }),\r\n      stop: (streamId: string) => ipcCall('agent:stream:stop', { streamId }),\r\n    },\r\n    generatePlanFromGoal: (request: { goal: string; mode?: string; constraints?: string[] }) =>\r\n      ipcCall<{ goal: string; mode?: string; constraints?: string[] }, Plan>(\r\n        'agent:generatePlanFromGoal',\r\n        request\r\n      ),\r\n    executePlan: (request: { planId: string; plan: Plan }) => ipcCall('agent:executePlan', request),\r\n    guardrails: {\r\n      config: (config: any) => ipcCall('agent:guardrails:config', config),\r\n      check: (type: 'prompt' | 'domain' | 'ratelimit' | 'step', data: any) =>\r\n        ipcCall('agent:guardrails:check', { type, data }),\r\n    },\r\n  },\r\n  cursor: {\r\n    setApiKey: (payload: { apiKey: string }) =>\r\n      ipcCall<{ apiKey: string }, { success: boolean }>('cursor:setApiKey', payload),\r\n    checkApiKey: () =>\r\n      ipcCall<unknown, { hasKey: boolean; isAvailable: boolean }>('cursor:checkApiKey', {}),\r\n    query: (payload: {\r\n      question: string;\r\n      pageSnapshot?: { url: string; title: string; html?: string; text?: string };\r\n      editorState?: {\r\n        filePath: string;\r\n        content: string;\r\n        language?: string;\r\n        cursorLine?: number;\r\n        cursorCol?: number;\r\n      };\r\n      useWebSocket?: boolean;\r\n      systemInstructions?: string;\r\n    }) =>\r\n      ipcCall<\r\n        typeof payload,\r\n        {\r\n          jobId: string;\r\n          answer?: string;\r\n          status: 'streaming' | 'complete' | 'error';\r\n          error?: string;\r\n        }\r\n      >('cursor:query', payload),\r\n    clearHistory: () => ipcCall<unknown, { success: boolean }>('cursor:clearHistory', {}),\r\n  },\r\n  omnix: {\r\n    browser: {\r\n      getPage: () =>\r\n        ipcCall<unknown, { url: string; title: string; html?: string; text?: string } | null>(\r\n          'omnix:browser:getPage',\r\n          {}\r\n        ),\r\n      getActiveTab: () =>\r\n        ipcCall<unknown, { id: string; url: string; title: string } | null>(\r\n          'omnix:browser:getActiveTab',\r\n          {}\r\n        ),\r\n      captureSnapshot: (payload: { url?: string }) =>\r\n        ipcCall<{ url?: string }, { url: string; title: string; html: string; text: string }>(\r\n          'omnix:browser:captureSnapshot',\r\n          payload\r\n        ),\r\n    },\r\n    scrape: {\r\n      fetch: (payload: { url: string; options?: { timeout?: number; cache?: boolean } }) =>\r\n        ipcCall<typeof payload, { body: string; status: number; headers: Record<string, string> }>(\r\n          'omnix:scrape:fetch',\r\n          payload\r\n        ),\r\n      enqueue: (payload: { url: string }) =>\r\n        ipcCall<{ url: string }, { jobId: string }>('omnix:scrape:enqueue', payload),\r\n    },\r\n    ai: {\r\n      ask: (payload: { question: string; context?: { url?: string; text?: string } }) =>\r\n        ipcCall<typeof payload, { answer: string; sources?: string[] }>('omnix:ai:ask', payload),\r\n      summarize: (payload: { url: string }) =>\r\n        ipcCall<{ url: string }, { summary: string; highlights: string[] }>(\r\n          'omnix:ai:summarize',\r\n          payload\r\n        ),\r\n    },\r\n    trade: {\r\n      getChart: (payload: { symbol: string }) =>\r\n        ipcCall<{ symbol: string }, { data: unknown }>('omnix:trade:getChart', payload),\r\n    },\r\n    file: {\r\n      save: (payload: { path: string; content: string }) =>\r\n        ipcCall<{ path: string; content: string }, { success: boolean }>(\r\n          'omnix:file:save',\r\n          payload\r\n        ),\r\n      read: (payload: { path: string }) =>\r\n        ipcCall<{ path: string }, { content: string }>('omnix:file:read', payload),\r\n    },\r\n    security: {\r\n      scanPage: (payload: { url: string }) =>\r\n        ipcCall<{ url: string }, { threats: string[]; score: number }>(\r\n          'omnix:security:scanPage',\r\n          payload\r\n        ),\r\n    },\r\n  },\r\n  session: {\r\n    saveTabs: () => ipcCall<unknown, { success: boolean; count: number }>('session:saveTabs', {}),\r\n    loadTabs: () =>\r\n      ipcCall<\r\n        unknown,\r\n        {\r\n          tabs: Array<{\r\n            id: string;\r\n            url: string;\r\n            title: string;\r\n            active: boolean;\r\n            position: number;\r\n          }>;\r\n        }\r\n      >('session:loadTabs', {}),\r\n    addHistory: (payload: { url: string; title: string; typed?: boolean }) =>\r\n      ipcCall<typeof payload, { success: boolean }>('session:addHistory', payload),\r\n    getHistory: (payload: { limit?: number }) =>\r\n      ipcCall<\r\n        typeof payload,\r\n        {\r\n          history: Array<{\r\n            id: string;\r\n            url: string;\r\n            title: string;\r\n            visitCount: number;\r\n            lastVisitAt: number;\r\n          }>;\r\n        }\r\n      >('session:getHistory', payload),\r\n    searchHistory: (payload: { query: string; limit?: number }) =>\r\n      ipcCall<typeof payload, { results: Array<{ id: string; url: string; title: string }> }>(\r\n        'session:searchHistory',\r\n        payload\r\n      ),\r\n    saveSetting: (payload: { key: string; value: unknown }) =>\r\n      ipcCall<typeof payload, { success: boolean }>('session:saveSetting', payload),\r\n    getSetting: (payload: { key: string }) =>\r\n      ipcCall<{ key: string }, { value: unknown }>('session:getSetting', payload),\r\n    checkRestore: () =>\r\n      ipcCall<\r\n        unknown,\r\n        {\r\n          available: boolean;\r\n          snapshot?: {\r\n            tabCount: number;\r\n            mode: string;\r\n            timestamp: number;\r\n            activeTabId: string | null;\r\n          };\r\n        }\r\n      >('session:checkRestore', {}),\r\n    getSnapshot: () =>\r\n      ipcCall<\r\n        unknown,\r\n        {\r\n          version: number;\r\n          tabs: Array<{\r\n            id: string;\r\n            url: string;\r\n            title: string;\r\n            active: boolean;\r\n            mode?: string;\r\n            containerId?: string;\r\n          }>;\r\n          mode: string;\r\n          activeTabId: string | null;\r\n          chromeOffsets?: { top: number; bottom: number; left: number; right: number };\r\n          rightDockPx?: number;\r\n          timestamp: number;\r\n        } | null\r\n      >('session:getSnapshot', {}),\r\n    dismissRestore: () => ipcCall<unknown, { success: boolean }>('session:dismissRestore', {}),\r\n  },\r\n  researchStream: {\r\n    start: async (question: string, mode?: 'default' | 'threat' | 'trade') => {\r\n      const payload = { question, ...(mode ? { mode } : {}) };\r\n      const response = await ipcCall<\r\n        { question: string; mode?: string },\r\n        { jobId: string; channel: string }\r\n      >('research:start', payload);\r\n      return response;\r\n    },\r\n  },\r\n  cloudVector: {\r\n    config: (config: {\r\n      provider: 'qdrant' | 'pinecone' | 'none';\r\n      endpoint?: string;\r\n      apiKey?: string;\r\n      collection?: string;\r\n      enabled: boolean;\r\n    }) => ipcCall('cloud-vector:config', config),\r\n    sync: (documentIds?: string[]) => ipcCall('cloud-vector:sync', { documentIds }),\r\n    search: (query: string, topK?: number) => ipcCall('cloud-vector:search', { query, topK }),\r\n    available: () => ipcCall<unknown, { available: boolean }>('cloud-vector:available', {}),\r\n  },\r\n  hybridSearch: {\r\n    search: (query: string, maxResults?: number, language?: string) =>\r\n      ipcCall('search:hybrid', { query, maxResults, language }),\r\n    config: (config: {\r\n      sources?: {\r\n        brave?: { enabled: boolean; apiKey?: string };\r\n        bing?: { enabled: boolean; apiKey?: string; endpoint?: string };\r\n        custom?: { enabled: boolean };\r\n      };\r\n      maxResults?: number;\r\n      rerank?: boolean;\r\n    }) => ipcCall('search:config', config),\r\n  },\r\n  liveSearch: {\r\n    start: (\r\n      query: string,\r\n      options?: { mode?: 'default' | 'threat' | 'trade'; region?: string; maxResults?: number }\r\n    ) =>\r\n      ipcCall<\r\n        {\r\n          query: string;\r\n          mode?: 'default' | 'threat' | 'trade';\r\n          region?: string;\r\n          maxResults?: number;\r\n        },\r\n        { jobId: string; channel: string }\r\n      >('search:live:start', { query, ...options }),\r\n  },\r\n  graph: {\r\n    tabs: () =>\r\n      ipcCall<\r\n        unknown,\r\n        {\r\n          nodes: Array<{\r\n            id: string;\r\n            title: string;\r\n            url: string;\r\n            domain: string;\r\n            containerId?: string;\r\n            containerName?: string;\r\n            containerColor?: string;\r\n            mode?: 'normal' | 'ghost' | 'private';\r\n            active: boolean;\r\n            createdAt?: number;\r\n            lastActiveAt?: number;\r\n          }>;\r\n          edges: Array<{\r\n            id: string;\r\n            source: string;\r\n            target: string;\r\n            weight: number;\r\n            reasons: string[];\r\n          }>;\r\n          summary: { totalTabs: number; activeTabs: number; domains: number; containers: number };\r\n          updatedAt: number;\r\n        }\r\n      >('graph:tabs', {}),\r\n    workflow: (options?: { maxSteps?: number }) =>\r\n      ipcCall<\r\n        { maxSteps?: number },\r\n        {\r\n          planId: string;\r\n          goal: string;\r\n          summary: string;\r\n          generatedAt: number;\r\n          confidence: number;\r\n          steps: Array<{\r\n            id: string;\r\n            title: string;\r\n            description: string;\r\n            tabIds: string[];\r\n            recommendedActions: string[];\r\n            primaryDomain?: string;\r\n            confidence?: number;\r\n          }>;\r\n          sources: Array<{ domain: string; tabIds: string[] }>;\r\n        }\r\n      >('graph:workflowWeaver', options ?? {}),\r\n  },\r\n  efficiency: {\r\n    applyMode: (mode: 'normal' | 'battery-saver' | 'extreme') =>\r\n      ipcCall<{ mode: 'normal' | 'battery-saver' | 'extreme' }, { success: boolean }>(\r\n        'efficiency:applyMode',\r\n        { mode }\r\n      ),\r\n    clearOverride: () => ipcCall<unknown, { success: boolean }>('efficiency:clearOverride', {}),\r\n    hibernateInactiveTabs: () =>\r\n      ipcCall<unknown, { success: boolean; count: number }>('efficiency:hibernate', {}),\r\n    ecoImpact: (options?: { horizonMinutes?: number }) =>\r\n      ipcCall<{ horizonMinutes?: number }, EcoImpactForecast>(\r\n        'efficiency:ecoImpact',\r\n        options ?? {}\r\n      ),\r\n  },\r\n  browser: {\r\n    launch: (url: string, headless?: boolean) =>\r\n      ipcCall<\r\n        { url: string; headless?: boolean },\r\n        { success: boolean; title?: string; url?: string; screenshot?: string; error?: string }\r\n      >('launch_browser', { url, headless }),\r\n    regenLaunch: (url: string, mode: string) =>\r\n      ipcCall<{ url: string; mode: string }, string>('regen_launch', { url, mode }),\r\n    regenSession: (urls: string[]) =>\r\n      ipcCall<\r\n        { urls: string[] },\r\n        Array<{\r\n          success: boolean;\r\n          title?: string;\r\n          url?: string;\r\n          screenshot?: string;\r\n          error?: string;\r\n        }>\r\n      >('regen_session', { urls }),\r\n    captureScreenshot: (url: string) =>\r\n      ipcCall<{ url: string }, { success: boolean; screenshot?: string; error?: string }>(\r\n        'capture_browser_screenshot',\r\n        { url }\r\n      ),\r\n  },\r\n  grammar: {\r\n    correct: (text: string) => ipcCall<{ text: string }, string>('correct_text', { text }),\r\n  },\r\n  vision: {\r\n    captureScreen: () => ipcCall<unknown, string>('capture_screen', {}),\r\n    analyze: (prompt: string, screenshot?: string) =>\r\n      ipcCall<{ prompt: string; screenshot?: string }, string>('ollama_vision', {\r\n        prompt,\r\n        screenshot,\r\n      }),\r\n  },\r\n  trust: {\r\n    list: () => ipcCall<unknown, { records: TrustSummary[] }>('trust:list', {}),\r\n    get: (domain: string) =>\r\n      ipcCall<{ domain: string }, { found: boolean; summary?: TrustSummary }>('trust:get', {\r\n        domain,\r\n      }),\r\n    submit: (signal: {\r\n      domain: string;\r\n      url?: string;\r\n      title?: string;\r\n      score: number;\r\n      confidence?: number;\r\n      tags?: string[];\r\n      comment?: string;\r\n      sourcePeer?: string;\r\n    }) => ipcCall<typeof signal, { summary: TrustSummary | null }>('trust:submit', signal),\r\n  },\r\n  downloads: {\r\n    list: () =>\r\n      ipcCall<\r\n        unknown,\r\n        Array<{\r\n          id: string;\r\n          url: string;\r\n          filename?: string;\r\n          status: string;\r\n          progress?: number;\r\n          receivedBytes?: number;\r\n          totalBytes?: number;\r\n          path?: string;\r\n          checksum?: string;\r\n          createdAt: number;\r\n          speedBytesPerSec?: number;\r\n          etaSeconds?: number;\r\n          safety?: {\r\n            status: string;\r\n            threatLevel?: string;\r\n            details?: string;\r\n            recommendations?: string[];\r\n            scannedAt?: number;\r\n            quarantinePath?: string;\r\n          };\r\n        }>\r\n      >('downloads:list', {}),\r\n    openFile: (path: string) => ipcCall('downloads:openFile', { path }),\r\n    showInFolder: (path: string) => ipcCall('downloads:showInFolder', { path }),\r\n    requestConsent: (url: string, filename: string, size?: number) =>\r\n      ipcCall('downloads:requestConsent', { url, filename, size }),\r\n    pause: (id: string) => ipcCall('downloads:pause', { id }),\r\n    resume: (id: string) => ipcCall('downloads:resume', { id }),\r\n    cancel: (id: string) => ipcCall('downloads:cancel', { id }),\r\n    retry: (id: string) =>\r\n      ipcCall<{ id: string }, { success: boolean; queued?: boolean }>('downloads:retry', { id }),\r\n    getQueue: () =>\r\n      ipcCall<unknown, { active: number; queued: number; maxConcurrent: number }>(\r\n        'downloads:getQueue',\r\n        {}\r\n      ),\r\n  },\r\n  watchers: {\r\n    list: () =>\r\n      ipcCall<\r\n        unknown,\r\n        Array<{\r\n          id: string;\r\n          url: string;\r\n          createdAt: number;\r\n          intervalMinutes: number;\r\n          lastCheckedAt?: number;\r\n          lastHash?: string;\r\n          lastChangeAt?: number;\r\n          status: string;\r\n          error?: string;\r\n        }>\r\n      >('watchers:list', {}),\r\n    add: (request: { url: string; intervalMinutes?: number }) =>\r\n      ipcCall<\r\n        { url: string; intervalMinutes?: number },\r\n        { id: string; url: string; createdAt: number; intervalMinutes: number; status: string }\r\n      >('watchers:add', request),\r\n    remove: (id: string) =>\r\n      ipcCall<{ id: string }, { success: boolean }>('watchers:remove', { id }),\r\n    trigger: (id: string) =>\r\n      ipcCall<{ id: string }, { success: boolean; error?: string }>('watchers:trigger', { id }),\r\n    updateInterval: (id: string, intervalMinutes: number) =>\r\n      ipcCall<{ id: string; intervalMinutes: number }, { success: boolean; error?: string }>(\r\n        'watchers:updateInterval',\r\n        { id, intervalMinutes }\r\n      ),\r\n  },\r\n  history: {\r\n    list: () => ipcCall<unknown, any[]>('history:list', {}),\r\n    clear: () => ipcCall('history:clear', {}),\r\n    search: async (query: string) => {\r\n      try {\r\n        return await ipcCall<{ query: string }, any[]>('history:search', { query });\r\n      } catch (error) {\r\n        // Return empty array on error instead of throwing\r\n        if (IS_DEV) {\r\n          console.warn('History search failed:', error);\r\n        }\r\n        return [];\r\n      }\r\n    },\r\n    deleteUrl: (url: string) =>\r\n      ipcCall<{ url: string }, { success: boolean }>('history:deleteUrl', { url }),\r\n  },\r\n  storage: {\r\n    saveWorkspace: (workspace: unknown) => ipcCall('storage:saveWorkspace', workspace),\r\n    listWorkspaces: () => ipcCall<unknown, unknown[]>('storage:listWorkspaces', {}),\r\n  },\r\n  shields: {\r\n    get: (url: string) => ipcCall('shields:get', { url }),\r\n    set: (hostname: string, config: unknown) => ipcCall('shields:set', { hostname, config }),\r\n    updateDefault: (config: unknown) => ipcCall('shields:updateDefault', config),\r\n    list: () => ipcCall<unknown, unknown[]>('shields:list', {}),\r\n    getStatus: () =>\r\n      ipcCall<\r\n        unknown,\r\n        {\r\n          adsBlocked: number;\r\n          trackersBlocked: number;\r\n          httpsUpgrades: number;\r\n          cookies3p: 'block' | 'allow';\r\n          webrtcBlocked: boolean;\r\n          fingerprinting: boolean;\r\n        }\r\n      >('shields:getStatus', {}),\r\n  },\r\n  network: {\r\n    get: () =>\r\n      ipcCall<unknown, { quicEnabled: boolean; ipv6Enabled: boolean; ipv6LeakProtection: boolean }>(\r\n        'network:get',\r\n        {}\r\n      ),\r\n    disableQUIC: () => ipcCall('network:disableQUIC', {}),\r\n    enableQUIC: () => ipcCall('network:enableQUIC', {}),\r\n    disableIPv6: () => ipcCall('network:disableIPv6', {}),\r\n    enableIPv6: () => ipcCall('network:enableIPv6', {}),\r\n  },\r\n  ollama: {\r\n    check: () => ipcCall<unknown, { available: boolean; models?: string[] }>('ollama:check', {}),\r\n    listModels: () => ipcCall<unknown, { models: string[] }>('ollama:listModels', {}),\r\n  },\r\n  citation: {\r\n    extract: (text: string, url?: string) => ipcCall('citation:extract', { text, url }),\r\n    get: () => ipcCall<unknown, { nodes: any[]; edges: any[] }>('citation:get', {}),\r\n    export: (format: 'json' | 'graphml') => ipcCall('citation:export', { format }),\r\n    clear: () => ipcCall('citation:clear', {}),\r\n  },\r\n  knowledge: {\r\n    cluster: (sources: Array<{ url: string; title: string; text?: string }>, threshold?: number) =>\r\n      ipcCall('knowledge:cluster', { sources, threshold: threshold ?? 0.7 }),\r\n    parsePDF: (filePath: string) => ipcCall('knowledge:parsePDF', { filePath }),\r\n    clusterCompare: (cluster1Id: string, cluster2Id: string) =>\r\n      ipcCall('knowledge:clusterCompare', { cluster1Id, cluster2Id }),\r\n    clustersList: () => ipcCall<unknown, { clusters: any[] }>('knowledge:clustersList', {}),\r\n  },\r\n  cognitive: {\r\n    recordPattern: (pattern: {\r\n      url: string;\r\n      domain: string;\r\n      timeSpent: number;\r\n      actions: string[];\r\n      topics?: string[];\r\n    }) => ipcCall('cognitive:recordPattern', pattern),\r\n    getSuggestions: (request?: { currentUrl?: string; recentActions?: string[] }) =>\r\n      ipcCall('cognitive:getSuggestions', request || {}),\r\n    getPersona: () =>\r\n      ipcCall<unknown, { interests: string[]; habits: string[]; patterns: string }>(\r\n        'cognitive:getPersona',\r\n        {}\r\n      ),\r\n    getGraph: () => ipcCall<unknown, { graph: any }>('cognitive:getGraph', {}),\r\n    clear: () => ipcCall('cognitive:clear', {}),\r\n  },\r\n  workspaceV2: {\r\n    save: (workspace: {\r\n      id: string;\r\n      name: string;\r\n      tabs: any[];\r\n      notes?: Record<string, string>;\r\n      proxyProfileId?: string;\r\n      mode?: string;\r\n      layout?: any;\r\n    }) => ipcCall('workspace-v2:save', workspace),\r\n    load: (workspaceId: string) => ipcCall('workspace-v2:load', { workspaceId }),\r\n    list: () => ipcCall<unknown, { workspaces: any[] }>('workspace-v2:list', {}),\r\n    delete: (workspaceId: string) => ipcCall('workspace-v2:delete', { workspaceId }),\r\n    updateNotes: (workspaceId: string, tabId: string, note: string) =>\r\n      ipcCall('workspace-v2:updateNotes', { workspaceId, tabId, note }),\r\n    getNotes: (workspaceId: string) =>\r\n      ipcCall<unknown, { notes: Record<string, string> }>('workspace-v2:getNotes', { workspaceId }),\r\n  },\r\n  sessionBundle: {\r\n    export: (runId: string, options?: { name?: string; description?: string }) =>\r\n      ipcCall('session-bundle:export', { runId, ...options }),\r\n    import: (filePath: string) => ipcCall('session-bundle:import', { filePath }),\r\n    replay: (bundleId: string, options?: { restoreWorkspace?: boolean; replayAgent?: boolean }) =>\r\n      ipcCall('session-bundle:replay', { bundleId, ...options }),\r\n    list: () => ipcCall<unknown, { bundles: any[] }>('session-bundle:list', {}),\r\n  },\r\n  sessionState: {\r\n    summary: () =>\r\n      ipcCall<\r\n        unknown,\r\n        { summary: { updatedAt: number; windowCount: number; tabCount: number } | null }\r\n      >('session:lastSnapshotSummary', {}),\r\n    restore: () =>\r\n      ipcCall<unknown, { restored: boolean; tabCount?: number; error?: string }>(\r\n        'session:restoreLast',\r\n        {}\r\n      ),\r\n  },\r\n  historyGraph: {\r\n    recordNavigation: (fromUrl: string | null, toUrl: string, title?: string) =>\r\n      ipcCall('history-graph:recordNavigation', { fromUrl, toUrl, title }),\r\n    recordCitation: (sourceUrl: string, targetUrl: string) =>\r\n      ipcCall('history-graph:recordCitation', { sourceUrl, targetUrl }),\r\n    recordExport: (sourceUrl: string, exportType: string, filename: string) =>\r\n      ipcCall('history-graph:recordExport', { sourceUrl, exportType, filename }),\r\n    recordNote: (url: string, noteText: string) =>\r\n      ipcCall('history-graph:recordNote', { url, noteText }),\r\n    get: (options?: { startTime?: number; endTime?: number }) =>\r\n      ipcCall<unknown, { graph: any }>('history-graph:get', options || {}),\r\n    export: (format: 'json' | 'graphml') => ipcCall('history-graph:export', { format }),\r\n    clear: () => ipcCall('history-graph:clear', {}),\r\n  },\r\n  omniscript: {\r\n    parse: (command: string) => ipcCall<unknown, { parsed: any }>('omniscript:parse', { command }),\r\n    execute: (commands: string[]) =>\r\n      ipcCall<unknown, { actions: any[] }>('omniscript:execute', { commands }),\r\n  },\r\n  omniBrain: {\r\n    addDocument: (document: { text: string; url?: string; metadata?: Record<string, unknown> }) =>\r\n      ipcCall<unknown, { id: string }>('omni-brain:addDocument', document),\r\n    search: (query: string, limit?: number) =>\r\n      ipcCall<unknown, Array<{ document: any; similarity: number }>>('omni-brain:search', {\r\n        query,\r\n        limit: limit || 10,\r\n      }),\r\n    getDocument: (id: string) =>\r\n      ipcCall<unknown, { document: any }>('omni-brain:getDocument', { id }),\r\n    listDocuments: () => ipcCall<unknown, { documents: any[] }>('omni-brain:listDocuments', {}),\r\n    deleteDocument: (id: string) => ipcCall('omni-brain:deleteDocument', { id }),\r\n    clear: () => ipcCall('omni-brain:clear', {}),\r\n  },\r\n  spiritual: {\r\n    focusMode: {\r\n      enable: (config?: {\r\n        ambientSound?: 'none' | 'nature' | 'rain' | 'ocean' | 'meditation';\r\n        breathingOverlay?: boolean;\r\n        timer?: number;\r\n        notifications?: boolean;\r\n      }) => ipcCall('spiritual:focusMode:enable', config || {}),\r\n      disable: () => ipcCall('spiritual:focusMode:disable', {}),\r\n      status: () =>\r\n        ipcCall<unknown, { active: boolean; config: any }>('spiritual:focusMode:status', {}),\r\n    },\r\n    mood: {\r\n      recordTyping: () => ipcCall('spiritual:mood:recordTyping', {}),\r\n      get: () =>\r\n        ipcCall<unknown, { mood: string; confidence: number; detectedAt: number; colors: any }>(\r\n          'spiritual:mood:get',\r\n          {}\r\n        ),\r\n      reset: () => ipcCall('spiritual:mood:reset', {}),\r\n    },\r\n    balance: {\r\n      start: (intervals?: {\r\n        rest?: number;\r\n        stretch?: number;\r\n        hydrate?: number;\r\n        eyeBreak?: number;\r\n      }) => ipcCall('spiritual:balance:start', intervals || {}),\r\n      stop: () => ipcCall('spiritual:balance:stop', {}),\r\n    },\r\n  },\r\n  pluginMarketplace: {\r\n    list: () => ipcCall<unknown, { plugins: any[] }>('plugin-marketplace:list', {}),\r\n    install: (pluginId: string, verifySignature?: boolean) =>\r\n      ipcCall('plugin-marketplace:install', { pluginId, verifySignature: verifySignature ?? true }),\r\n    uninstall: (pluginId: string) => ipcCall('plugin-marketplace:uninstall', { pluginId }),\r\n    installed: () => ipcCall<unknown, { plugins: string[] }>('plugin-marketplace:installed', {}),\r\n    isInstalled: (pluginId: string) =>\r\n      ipcCall<unknown, { installed: boolean }>('plugin-marketplace:isInstalled', { pluginId }),\r\n  },\r\n  extensionNexus: {\r\n    list: () => ipcCall<unknown, NexusListResponse>('plugins:nexus:list', {}),\r\n    publish: (metadata: {\r\n      pluginId: string;\r\n      name: string;\r\n      version: string;\r\n      description: string;\r\n      author: string;\r\n      sourcePeer: string;\r\n      carbonScore?: number;\r\n      tags?: string[];\r\n    }) => ipcCall<typeof metadata, NexusPluginEntry>('plugins:nexus:publish', metadata),\r\n    trust: (pluginId: string, trusted: boolean) =>\r\n      ipcCall<{ pluginId: string; trusted: boolean }, { plugin: NexusPluginEntry | null }>(\r\n        'plugins:nexus:trust',\r\n        {\r\n          pluginId,\r\n          trusted,\r\n        }\r\n      ),\r\n  },\r\n  performance: {\r\n    battery: {\r\n      update: (payload: {\r\n        level?: number | null;\r\n        charging?: boolean | null;\r\n        chargingTime?: number | null;\r\n        dischargingTime?: number | null;\r\n        carbonIntensity?: number | null;\r\n        regionCode?: string | null;\r\n      }) => ipcCall('performance:battery:update', payload),\r\n    },\r\n    getMetrics: () =>\r\n      ipcCall<\r\n        unknown,\r\n        {\r\n          cpu: number;\r\n          memory: number;\r\n          cpuLoad1: number;\r\n          ramMb: number;\r\n          activeTabs: number;\r\n          timestamp: number;\r\n        }\r\n      >('performance:getMetrics', {}),\r\n    gpu: {\r\n      enableRaster: () =>\r\n        ipcCall<unknown, { success: boolean; config: any }>('performance:gpu:enableRaster', {}),\r\n      disableRaster: () =>\r\n        ipcCall<unknown, { success: boolean; config: any }>('performance:gpu:disableRaster', {}),\r\n      enableHardwareDecode: () =>\r\n        ipcCall<unknown, { success: boolean; config: any }>(\r\n          'performance:gpu:enableHardwareDecode',\r\n          {}\r\n        ),\r\n      disableHardwareDecode: () =>\r\n        ipcCall<unknown, { success: boolean; config: any }>(\r\n          'performance:gpu:disableHardwareDecode',\r\n          {}\r\n        ),\r\n      getConfig: () => ipcCall<unknown, { config: any }>('performance:gpu:getConfig', {}),\r\n    },\r\n    snapshot: {\r\n      create: (snapshot: { windows: any[]; workspace?: string }) =>\r\n        ipcCall<unknown, { snapshotId: string }>('performance:snapshot:create', snapshot),\r\n      restore: (snapshotId: string) =>\r\n        ipcCall<unknown, { snapshot: any }>('performance:snapshot:restore', { snapshotId }),\r\n      latest: () => ipcCall<unknown, { snapshot: any }>('performance:snapshot:latest', {}),\r\n      list: () => ipcCall<unknown, { snapshots: any[] }>('performance:snapshot:list', {}),\r\n    },\r\n  },\r\n  workers: {\r\n    scraping: {\r\n      run: (task: { id: string; urls: string[]; selectors?: string[]; pagination?: any }) =>\r\n        ipcCall<unknown, { taskId: string; results: any[]; completed: number; total: number }>(\r\n          'workers:scraping:run',\r\n          task\r\n        ),\r\n    },\r\n  },\r\n  videoCall: {\r\n    getConfig: () =>\r\n      ipcCall<\r\n        unknown,\r\n        {\r\n          enabled: boolean;\r\n          adaptiveQuality: boolean;\r\n          maxResolution: string;\r\n          maxFrameRate: number;\r\n          bandwidthEstimate: number;\r\n          priorityMode: string;\r\n        }\r\n      >('videoCall:getConfig', {}),\r\n    updateConfig: (config: {\r\n      enabled?: boolean;\r\n      adaptiveQuality?: boolean;\r\n      maxResolution?: '720p' | '480p' | '360p' | '240p';\r\n      maxFrameRate?: number;\r\n      bandwidthEstimate?: number;\r\n      priorityMode?: 'performance' | 'balanced' | 'quality';\r\n    }) => ipcCall('videoCall:updateConfig', config),\r\n    getNetworkQuality: () =>\r\n      ipcCall<unknown, { bandwidth: number; latency: number; packetLoss: number; quality: string }>(\r\n        'videoCall:getNetworkQuality',\r\n        {}\r\n      ),\r\n    updateNetworkQuality: (quality: { bandwidth: number; latency?: number; packetLoss?: number }) =>\r\n      ipcCall('videoCall:updateNetworkQuality', quality),\r\n  },\r\n  sessions: {\r\n    create: (request: { name: string; profileId?: string; color?: string }) =>\r\n      ipcCall<\r\n        { name: string; profileId?: string; color?: string },\r\n        {\r\n          id: string;\r\n          name: string;\r\n          profileId: string;\r\n          createdAt: number;\r\n          tabCount: number;\r\n          color?: string;\r\n        }\r\n      >('sessions:create', request),\r\n    list: () =>\r\n      ipcCall<\r\n        unknown,\r\n        Array<{\r\n          id: string;\r\n          name: string;\r\n          profileId: string;\r\n          createdAt: number;\r\n          tabCount: number;\r\n          color?: string;\r\n        }>\r\n      >('sessions:list', {}),\r\n    getActive: () =>\r\n      ipcCall<\r\n        unknown,\r\n        {\r\n          id: string;\r\n          name: string;\r\n          profileId: string;\r\n          createdAt: number;\r\n          tabCount: number;\r\n          color?: string;\r\n        } | null\r\n      >('sessions:getActive', {}),\r\n    setActive: (request: { sessionId: string }) => ipcCall('sessions:setActive', request),\r\n    get: (request: { sessionId: string }) =>\r\n      ipcCall<\r\n        { sessionId: string },\r\n        {\r\n          id: string;\r\n          name: string;\r\n          profileId: string;\r\n          createdAt: number;\r\n          tabCount: number;\r\n          color?: string;\r\n        }\r\n      >('sessions:get', request),\r\n    delete: (request: { sessionId: string }) => ipcCall('sessions:delete', request),\r\n    update: (request: { sessionId: string; name?: string; color?: string }) =>\r\n      ipcCall('sessions:update', request),\r\n    getPartition: (request: { sessionId: string }) =>\r\n      ipcCall<{ sessionId: string }, { partition: string }>('sessions:getPartition', request),\r\n  },\r\n  private: {\r\n    createWindow: (options?: {\r\n      url?: string;\r\n      autoCloseAfter?: number;\r\n      contentProtection?: boolean;\r\n      ghostMode?: boolean;\r\n    }) =>\r\n      ipcCall<\r\n        { url?: string; autoCloseAfter?: number; contentProtection?: boolean; ghostMode?: boolean },\r\n        { windowId: number }\r\n      >('private:createWindow', options || {}),\r\n    createGhostTab: (options?: { url?: string }) =>\r\n      ipcCall<{ url?: string }, { tabId: string }>('private:createGhostTab', options || {}),\r\n    closeAll: () => ipcCall<unknown, { count: number }>('private:closeAll', {}),\r\n    panicWipe: (options?: { forensic?: boolean }) =>\r\n      ipcCall<{ forensic?: boolean }, { success: boolean }>('private:panicWipe', options || {}),\r\n  },\r\n  crossReality: {\r\n    handoff: (tabId: string, target: 'mobile' | 'xr') =>\r\n      ipcCall<{ tabId: string; target: 'mobile' | 'xr' }, { success: boolean; handoff: any }>(\r\n        'cross-reality:handoff',\r\n        {\r\n          tabId,\r\n          target,\r\n        }\r\n      ),\r\n    queue: () => ipcCall<unknown, { handoffs: any[] }>('cross-reality:queue', {}),\r\n    sendHandoffStatus: (status: { platform: string; lastSentAt: number | null }) =>\r\n      ipcCall<{ platform: string; lastSentAt: number | null }, { success: boolean }>(\r\n        'cross-reality:handoffStatus',\r\n        status\r\n      ).catch(error => {\r\n        if (IS_DEV) {\r\n          console.warn('[IPC] Failed to send handoff status:', error);\r\n        }\r\n        return { success: false };\r\n      }),\r\n  },\r\n  identity: {\r\n    status: () => ipcCall<unknown, IdentityVaultSummary>('identity:status', {}),\r\n    unlock: (passphrase: string) =>\r\n      ipcCall<{ passphrase: string }, IdentityVaultSummary>('identity:unlock', { passphrase }),\r\n    lock: () => ipcCall<unknown, IdentityVaultSummary>('identity:lock', {}),\r\n    list: () => ipcCall<unknown, IdentityCredential[]>('identity:list', {}),\r\n    add: (payload: {\r\n      domain: string;\r\n      username: string;\r\n      secret: string;\r\n      secretHint?: string | null;\r\n      tags?: string[];\r\n    }) => ipcCall<typeof payload, IdentityCredential>('identity:add', payload),\r\n    remove: (id: string) =>\r\n      ipcCall<{ id: string }, { success: boolean }>('identity:remove', { id }),\r\n    reveal: (id: string) =>\r\n      ipcCall<{ id: string }, IdentityRevealPayload>('identity:reveal', { id }),\r\n  },\r\n  consent: {\r\n    createRequest: (action: ConsentAction) =>\r\n      ipcCall<ConsentAction, { consentId: string }>('consent:createRequest', action),\r\n    approve: (consentId: string) =>\r\n      ipcCall<\r\n        { consentId: string },\r\n        {\r\n          success: boolean;\r\n          consent?: ConsentRecord | null;\r\n          receipt?: { receiptId: string; proof: string };\r\n        }\r\n      >('consent:approve', { consentId }),\r\n    revoke: (consentId: string) =>\r\n      ipcCall<{ consentId: string }, { success: boolean }>('consent:revoke', { consentId }),\r\n    check: (action: ConsentAction) =>\r\n      ipcCall<ConsentAction, { hasConsent: boolean }>('consent:check', action),\r\n    get: (consentId: string) =>\r\n      ipcCall<{ consentId: string }, ConsentRecord | undefined>('consent:get', { consentId }),\r\n    list: (filter?: { type?: ConsentAction['type']; approved?: boolean }) =>\r\n      ipcCall<typeof filter, ConsentRecord[]>('consent:list', filter ?? {}),\r\n    export: () => ipcCall<unknown, string>('consent:export', {}),\r\n    vault: {\r\n      export: () => ipcCall<unknown, ConsentVaultSnapshot>('consent:vault:export', {}),\r\n    },\r\n  },\r\n  research: {\r\n    queryEnhanced: (payload: {\r\n      query: string;\r\n      maxSources?: number;\r\n      includeCounterpoints?: boolean;\r\n      recencyWeight?: number;\r\n      authorityWeight?: number;\r\n      language?: string;\r\n    }) => ipcCall<typeof payload, any>('research:queryEnhanced', payload),\r\n    extractContent: (tabId?: string) =>\r\n      ipcCall<{ tabId?: string }, { content: string; title: string; html: string }>(\r\n        'research:extractContent',\r\n        tabId ? { tabId } : {}\r\n      ),\r\n    saveNotes: (url: string, notes: string, highlights?: unknown[]) =>\r\n      ipcCall<{ url: string; notes: string; highlights?: unknown[] }, { success: boolean }>(\r\n        'research:saveNotes',\r\n        {\r\n          url,\r\n          notes,\r\n          highlights,\r\n        }\r\n      ),\r\n    getNotes: (url: string) =>\r\n      ipcCall<{ url: string }, { notes: string; highlights: unknown[] }>('research:getNotes', {\r\n        url,\r\n      }),\r\n    export: (payload: {\r\n      format: 'markdown' | 'obsidian' | 'notion';\r\n      sources: string[];\r\n      includeNotes?: boolean;\r\n    }) => ipcCall<typeof payload, any>('research:export', payload),\r\n    saveSnapshot: (tabId: string) =>\r\n      ipcCall<{ tabId: string }, { snapshotId: string; url: string }>('research:saveSnapshot', {\r\n        tabId,\r\n      }),\r\n    uploadFile: (file: File) => {\r\n      // Convert File to base64 for IPC\r\n      return new Promise<string>((resolve, reject) => {\r\n        const reader = new FileReader();\r\n        reader.onload = async () => {\r\n          const base64 = reader.result as string;\r\n          const result = await ipcCall<\r\n            {\r\n              filename: string;\r\n              content: string;\r\n              mimeType: string;\r\n              size: number;\r\n            },\r\n            { fileId: string }\r\n          >('research:uploadFile', {\r\n            filename: file.name,\r\n            content: base64.split(',')[1], // Remove data URL prefix\r\n            mimeType: file.type,\r\n            size: file.size,\r\n          });\r\n          resolve(result.fileId);\r\n        };\r\n        reader.onerror = reject;\r\n        reader.readAsDataURL(file);\r\n      });\r\n    },\r\n    listDocuments: () =>\r\n      ipcCall<\r\n        unknown,\r\n        {\r\n          documents: Array<{\r\n            id: string;\r\n            type: string;\r\n            title: string;\r\n            uploadedAt: number;\r\n            chunkCount: number;\r\n          }>;\r\n        }\r\n      >('research:listDocuments', {}),\r\n    getDocumentChunks: (documentId: string) =>\r\n      ipcCall<\r\n        { documentId: string },\r\n        { chunks: Array<{ id: string; content: string; metadata: any }> }\r\n      >('research:getDocumentChunks', { documentId }),\r\n    capturePage: (tabId?: string) =>\r\n      ipcCall<\r\n        { tabId?: string },\r\n        {\r\n          snapshotId: string;\r\n          url: string;\r\n          title: string;\r\n          dimensions: { width: number; height: number };\r\n        }\r\n      >('research:capturePage', tabId ? { tabId } : {}),\r\n    captureSelection: (text?: string, tabId?: string) =>\r\n      ipcCall<{ tabId?: string; text?: string }, { clipId: string; url: string; text: string }>(\r\n        'research:captureSelection',\r\n        { tabId, text }\r\n      ),\r\n  },\r\n  reader: {\r\n    summarize: (payload: { url?: string; title?: string; content: string; html?: string }) =>\r\n      ipcCall<typeof payload, any>('reader:summarize', payload),\r\n    export: (payload: { url?: string; title?: string; html: string }) =>\r\n      ipcCall<typeof payload, { success: boolean; path: string }>('reader:export', payload),\r\n  },\r\n  trade: {\r\n    execute: (query: string) =>\r\n      ipcCall<{ query: string }, string>('execute_trade_command', { query }),\r\n    // TradingView API Integration\r\n    tradingviewAuthorize: (login: string, password: string) =>\r\n      ipcCall<\r\n        { login: string; password: string },\r\n        { s: string; d: { access_token: string; expiration: number } }\r\n      >('tradingview_authorize', { login, password }),\r\n    tradingviewQuotes: (accountId: string, symbols: string) =>\r\n      ipcCall<{ accountId: string; symbols: string }, { s: string; d: Array<any> }>(\r\n        'tradingview_quotes',\r\n        { accountId, symbols }\r\n      ),\r\n    tradingviewPlaceOrder: (params: {\r\n      accountId: string;\r\n      instrument: string;\r\n      qty: number;\r\n      side: 'buy' | 'sell';\r\n      orderType: 'market' | 'limit' | 'stop' | 'stoplimit';\r\n      limitPrice?: number;\r\n      stopPrice?: number;\r\n      currentAsk: number;\r\n      currentBid: number;\r\n      stopLoss?: number;\r\n      takeProfit?: number;\r\n    }) =>\r\n      ipcCall<typeof params, { s: string; d: { orderId: string; transactionId?: string } }>(\r\n        'tradingview_place_order',\r\n        params\r\n      ),\r\n    tradingviewGetPositions: (accountId: string) =>\r\n      ipcCall<{ accountId: string }, { s: string; d: Array<any> }>('tradingview_get_positions', {\r\n        accountId,\r\n      }),\r\n    tradingviewGetAccountState: (accountId: string) =>\r\n      ipcCall<\r\n        { accountId: string },\r\n        { s: string; d: { balance: number; unrealizedPl: number; equity: number } }\r\n      >('tradingview_get_account_state', { accountId }),\r\n    placeOrder: (order: {\r\n      symbol: string;\r\n      side: 'buy' | 'sell';\r\n      quantity: number;\r\n      orderType: 'market' | 'limit' | 'stop' | 'stop_limit';\r\n      limitPrice?: number;\r\n      stopPrice?: number;\r\n      timeInForce?: 'day' | 'gtc' | 'ioc' | 'fok';\r\n      bracket?: {\r\n        stopLoss: number;\r\n        takeProfit: number;\r\n        stopLossType?: 'price' | 'percent' | 'atr';\r\n        takeProfitType?: 'price' | 'percent' | 'atr';\r\n      };\r\n      trailingStop?: {\r\n        distance: number;\r\n        distanceType: 'price' | 'percent' | 'atr';\r\n        activationPrice?: number;\r\n      };\r\n      paper?: boolean;\r\n      aiSignalId?: string;\r\n    }) => ipcCall<typeof order, { orderId: string }>('trade:placeOrder', order),\r\n    cancelOrder: (orderId: string) =>\r\n      ipcCall<{ orderId: string }, { success: boolean }>('trade:cancelOrder', { orderId }),\r\n    getOrders: (status?: string) =>\r\n      ipcCall<\r\n        { status?: string },\r\n        {\r\n          orders: Array<{\r\n            id: string;\r\n            symbol: string;\r\n            side: 'buy' | 'sell';\r\n            quantity: number;\r\n            filledQuantity: number;\r\n            orderType: string;\r\n            status: string;\r\n            limitPrice?: number;\r\n            stopPrice?: number;\r\n            averageFillPrice?: number;\r\n            createdAt: number;\r\n            filledAt?: number;\r\n            paper: boolean;\r\n          }>;\r\n        }\r\n      >('trade:getOrders', status ? { status } : {}),\r\n    getPositions: () =>\r\n      ipcCall<\r\n        unknown,\r\n        {\r\n          positions: Array<{\r\n            id: string;\r\n            symbol: string;\r\n            quantity: number;\r\n            averageEntryPrice: number;\r\n            currentPrice: number;\r\n            unrealizedPnL: number;\r\n            realizedPnL: number;\r\n            entryOrderId: string;\r\n            paper: boolean;\r\n          }>;\r\n        }\r\n      >('trade:getPositions', {}),\r\n    closePosition: (symbol: string, quantity?: number) =>\r\n      ipcCall<\r\n        { symbol: string; quantity?: number },\r\n        { success: boolean; orderId?: string; error?: string }\r\n      >('trade:closePosition', { symbol, quantity }),\r\n    getBalance: () =>\r\n      ipcCall<unknown, { cash: number; buyingPower: number; portfolioValue: number }>(\r\n        'trade:getBalance',\r\n        {}\r\n      ),\r\n    connectBroker: (config: {\r\n      brokerId: string;\r\n      apiKey: string;\r\n      apiSecret: string;\r\n      paper: boolean;\r\n    }) => ipcCall<typeof config, { success: boolean }>('trade:connectBroker', config),\r\n    getQuote: (symbol: string) =>\r\n      ipcCall<\r\n        { symbol: string },\r\n        {\r\n          symbol: string;\r\n          bid: number;\r\n          ask: number;\r\n          last: number;\r\n          volume: number;\r\n          timestamp: number;\r\n        }\r\n      >('trade:getQuote', { symbol }),\r\n    getCandles: (params: { symbol: string; timeframe: string; from: number; to: number }) =>\r\n      ipcCall<\r\n        typeof params,\r\n        {\r\n          candles: Array<{\r\n            time: number;\r\n            open: number;\r\n            high: number;\r\n            low: number;\r\n            close: number;\r\n            volume: number;\r\n          }>;\r\n        }\r\n      >('trade:getCandles', params),\r\n  },\r\n  dns: {\r\n    status: () =>\r\n      ipcCall<unknown, { enabled: boolean; provider: 'cloudflare' | 'quad9' }>('dns:status', {}),\r\n    enableDoH: (provider: 'cloudflare' | 'quad9' = 'cloudflare') =>\r\n      ipcCall<{ provider: 'cloudflare' | 'quad9' }>('dns:enableDoH', { provider }),\r\n    disableDoH: () => ipcCall('dns:disableDoH', {}),\r\n  },\r\n  privacy: {\r\n    sentinel: {\r\n      audit: (tabId?: string | null) =>\r\n        ipcCall<{ tabId?: string | null } | undefined, PrivacyAuditSummary>(\r\n          'privacy:sentinel:audit',\r\n          tabId ? { tabId } : {}\r\n        ),\r\n    },\r\n    getStats: () =>\r\n      ipcCall<\r\n        unknown,\r\n        {\r\n          trackersBlocked: number;\r\n          adsBlocked: number;\r\n          cookiesBlocked: number;\r\n          scriptsBlocked: number;\r\n          httpsUpgrades: number;\r\n          fingerprintingEnabled: boolean;\r\n          webrtcBlocked: boolean;\r\n          totalCookies: number;\r\n          totalOrigins: number;\r\n          privacyScore: number;\r\n        }\r\n      >('privacy:getStats', {}),\r\n    getTrackers: (limit?: number) =>\r\n      ipcCall<\r\n        { limit?: number },\r\n        Array<{\r\n          domain: string;\r\n          category: string;\r\n          count: number;\r\n          blocked: boolean;\r\n          lastSeen: number;\r\n        }>\r\n      >('privacy:getTrackers', { limit: limit || 50 }),\r\n    exportReport: (format?: 'json' | 'csv') =>\r\n      ipcCall<\r\n        { format?: 'json' | 'csv' },\r\n        {\r\n          stats: any;\r\n          trackers: any[];\r\n          origins: any[];\r\n          timestamp: number;\r\n          exportFormat: 'json' | 'csv';\r\n        }\r\n      >('privacy:exportReport', { format: format || 'json' }),\r\n  },\r\n  redix: {\r\n    ask: (prompt: string, options?: { sessionId?: string; stream?: boolean }) =>\r\n      ipcCall<\r\n        { prompt: string; sessionId?: string; stream?: boolean },\r\n        {\r\n          success: boolean;\r\n          response?: string;\r\n          tokens?: number;\r\n          cached?: boolean;\r\n          ready?: boolean;\r\n          error?: string;\r\n          streaming?: boolean;\r\n        }\r\n      >('redix:ask', { prompt, ...options }),\r\n    status: () =>\r\n      ipcCall<\r\n        unknown,\r\n        { success: boolean; ready: boolean; backend: string; message: string; error?: string }\r\n      >('redix:status', {}),\r\n    stream: (\r\n      prompt: string,\r\n      options?: { sessionId?: string },\r\n      onChunk?: (chunk: {\r\n        type: string;\r\n        text?: string;\r\n        tokens?: number;\r\n        done?: boolean;\r\n        error?: string;\r\n      }) => void\r\n    ) => {\r\n      // For streaming, we'll use events\r\n      let handler: ((_event: any, data: any) => void) | null = null;\r\n\r\n      if (onChunk && typeof window !== 'undefined' && window.ipc) {\r\n        handler = (\r\n          _event: any,\r\n          data: { type: string; text?: string; tokens?: number; done?: boolean; error?: string }\r\n        ) => {\r\n          try {\r\n            onChunk(data);\r\n            if (data.done || data.error) {\r\n              if (handler && window.ipc?.removeListener) {\r\n                window.ipc.removeListener('redix:chunk', handler);\r\n              }\r\n              handler = null;\r\n            }\r\n          } catch (error) {\r\n            console.error('[Redix] Error in stream handler:', error);\r\n            if (handler && window.ipc?.removeListener) {\r\n              window.ipc.removeListener('redix:chunk', handler);\r\n            }\r\n            handler = null;\r\n          }\r\n        };\r\n\r\n        try {\r\n          window.ipc.on?.('redix:chunk', handler);\r\n        } catch (error) {\r\n          console.error('[Redix] Failed to register stream handler:', error);\r\n        }\r\n      }\r\n\r\n      return ipcCall<\r\n        { prompt: string; sessionId?: string; stream: boolean },\r\n        { success: boolean; error?: string }\r\n      >('redix:stream', { prompt, stream: true, ...options }).catch(error => {\r\n        // Clean up handler on error\r\n        if (handler && typeof window !== 'undefined' && window.ipc?.removeListener) {\r\n          window.ipc.removeListener('redix:chunk', handler);\r\n        }\r\n        throw error;\r\n      });\r\n    },\r\n  },\r\n  system: {\r\n    getStatus: () =>\r\n      ipcCall<\r\n        unknown,\r\n        {\r\n          redisConnected: boolean;\r\n          redixAvailable: boolean;\r\n          workerState: 'running' | 'stopped' | 'error';\r\n          vpn: { connected: boolean; profile?: string; type?: string };\r\n          tor: { running: boolean; bootstrapped: boolean };\r\n          mode: string;\r\n          uptime: number;\r\n          memoryUsage: {\r\n            heapUsed: number;\r\n            heapTotal: number;\r\n            external: number;\r\n            rss: number;\r\n          };\r\n        }\r\n      >('system:getStatus', {}),\r\n  },\r\n  gpu: {\r\n    getStatus: () => ipcCall<unknown, { enabled: boolean }>('gpu:getStatus', {}),\r\n    setEnabled: (payload: { enabled: boolean }) =>\r\n      ipcCall<typeof payload, { success: boolean; enabled: boolean; requiresRestart: boolean }>(\r\n        'gpu:setEnabled',\r\n        payload\r\n      ),\r\n  },\r\n  features: {\r\n    list: () =>\r\n      ipcCall<\r\n        unknown,\r\n        {\r\n          flags: Array<{\r\n            name: string;\r\n            enabled: boolean;\r\n            description?: string;\r\n          }>;\r\n        }\r\n      >('features:list', {}),\r\n    get: (payload: { name: string }) =>\r\n      ipcCall<typeof payload, { enabled: boolean }>('features:get', payload),\r\n    set: (payload: { name: string; enabled: boolean }) =>\r\n      ipcCall<typeof payload, { success: boolean }>('features:set', payload),\r\n  },\r\n  regen: {\r\n    query: (payload: {\r\n      sessionId: string;\r\n      message: string;\r\n      mode?: 'research' | 'trade' | 'browser' | 'automation' | 'handsFree';\r\n      source?: 'text' | 'voice';\r\n      tabId?: string;\r\n      context?: { url?: string; title?: string; dom?: string };\r\n    }) =>\r\n      ipcCall<\r\n        typeof payload,\r\n        {\r\n          intent: string;\r\n          text: string;\r\n          commands?: Array<{ type: string; payload: Record<string, unknown> }>;\r\n          metadata?: Record<string, unknown>;\r\n        }\r\n      >('regen:query', payload),\r\n    getDom: (payload: { tabId: string }) =>\r\n      ipcCall<typeof payload, { success: boolean; data?: unknown; error?: string }>(\r\n        'regen:getDom',\r\n        payload\r\n      ),\r\n    clickElement: (payload: { tabId: string; selector: string }) =>\r\n      ipcCall<typeof payload, { success: boolean; data?: unknown; error?: string }>(\r\n        'regen:clickElement',\r\n        payload\r\n      ),\r\n    scroll: (payload: { tabId: string; amount: number }) =>\r\n      ipcCall<typeof payload, { success: boolean; data?: unknown; error?: string }>(\r\n        'regen:scroll',\r\n        payload\r\n      ),\r\n    openTab: (payload: { url: string; background?: boolean }) =>\r\n      ipcCall<typeof payload, { success: boolean; data?: unknown; error?: string }>(\r\n        'regen:openTab',\r\n        payload\r\n      ),\r\n    typeIntoElement: (payload: { tabId: string; selector: string; text: string }) =>\r\n      ipcCall<typeof payload, { success: boolean; data?: unknown; error?: string }>(\r\n        'regen:typeIntoElement',\r\n        payload\r\n      ),\r\n    goBack: (payload: { tabId: string }) =>\r\n      ipcCall<typeof payload, { success: boolean; data?: unknown; error?: string }>(\r\n        'regen:goBack',\r\n        payload\r\n      ),\r\n    goForward: (payload: { tabId: string }) =>\r\n      ipcCall<typeof payload, { success: boolean; data?: unknown; error?: string }>(\r\n        'regen:goForward',\r\n        payload\r\n      ),\r\n    switchTab: (payload: { index?: number; id?: string }) =>\r\n      ipcCall<typeof payload, { success: boolean; data?: unknown; error?: string }>(\r\n        'regen:switchTab',\r\n        payload\r\n      ),\r\n    closeTab: (payload: { tabId: string }) =>\r\n      ipcCall<typeof payload, { success: boolean; data?: unknown; error?: string }>(\r\n        'regen:closeTab',\r\n        payload\r\n      ),\r\n    readPage: (payload: { tabId: string }) =>\r\n      ipcCall<typeof payload, { success: boolean; data?: unknown; error?: string }>(\r\n        'regen:readPage',\r\n        payload\r\n      ),\r\n    tradeConfirm: (payload: {\r\n      orderId?: string;\r\n      confirmed: boolean;\r\n      pendingOrder: {\r\n        type: 'buy' | 'sell';\r\n        symbol: string;\r\n        quantity: number;\r\n        orderType?: 'market' | 'limit';\r\n        price?: number;\r\n      };\r\n    }) =>\r\n      ipcCall<\r\n        typeof payload,\r\n        {\r\n          success: boolean;\r\n          orderId?: string;\r\n          cancelled?: boolean;\r\n          message?: string;\r\n          error?: string;\r\n        }\r\n      >('regen:trade:confirm', payload),\r\n  },\r\n};\r\n\r\ntype ConsentVaultEntry = {\r\n  consentId: string;\r\n  actionType: ConsentAction['type'];\r\n  approved: boolean;\r\n  timestamp: number;\r\n  signature: string;\r\n  chainHash: string;\r\n  metadata: Record<string, unknown>;\r\n};\r\n\r\ntype ConsentVaultSnapshot = {\r\n  entries: ConsentVaultEntry[];\r\n  anchor: string;\r\n  updatedAt: number;\r\n};\r\n","import { create } from 'zustand';\r\nimport { persist } from 'zustand/middleware';\r\nimport type { AppState } from './appStore';\r\n\r\ntype SearchEngine = 'google' | 'duckduckgo' | 'bing' | 'yahoo' | 'all' | 'mock';\r\n\r\ntype GeneralSettings = {\r\n  defaultMode: AppState['mode'];\r\n  startupBehavior: 'newTab' | 'restore';\r\n  telemetryOptIn: boolean;\r\n  showKeyboardHints: boolean;\r\n  allowBetaUpdates: boolean;\r\n};\r\n\r\ntype PrivacySettings = {\r\n  localOnlyMode: boolean;\r\n  doNotTrack: boolean;\r\n  clearOnExit: boolean;\r\n  blockThirdPartyCookies: boolean;\r\n  safeBrowsing: boolean;\r\n  trackerProtection: boolean;\r\n  adBlockEnabled: boolean;\r\n  malwareProtection: boolean;\r\n  autoUpdateFilters: boolean;\r\n};\r\n\r\ntype AppearanceSettings = {\r\n  theme: 'light' | 'dark' | 'system';\r\n  compactUI: boolean;\r\n  showTabNumbers: boolean;\r\n  accent: 'blue' | 'purple' | 'emerald';\r\n  chromeNewTabPage?: boolean; // Enable Chrome-style new tab page\r\n};\r\n\r\ntype AccountSettings = {\r\n  displayName: string;\r\n  email: string;\r\n  workspace: string;\r\n  avatarUrl?: string;\r\n  avatarColor?: string; // Tier 2: Avatar color for profile\r\n  lastSyncedAt?: number;\r\n};\r\n\r\ntype SettingsData = {\r\n  general: GeneralSettings;\r\n  privacy: PrivacySettings;\r\n  appearance: AppearanceSettings;\r\n  account: AccountSettings;\r\n  videoDownloadConsent: boolean;\r\n  searchEngine: SearchEngine;\r\n  language?: string; // Language code (e.g., 'hi', 'en', 'auto')\r\n};\r\n\r\ntype SettingsState = SettingsData & {\r\n  setConsent: (value: boolean) => void;\r\n  setSearchEngine: (engine: SearchEngine) => void;\r\n  setLanguage: (language: string) => void;\r\n  updateGeneral: (partial: Partial<GeneralSettings>) => void;\r\n  updatePrivacy: (partial: Partial<PrivacySettings>) => void;\r\n  updateAppearance: (partial: Partial<AppearanceSettings>) => void;\r\n  updateAccount: (partial: Partial<AccountSettings>) => void;\r\n  resetSettings: () => void;\r\n};\r\n\r\nconst createDefaults = (): SettingsData => ({\r\n  general: {\r\n    defaultMode: 'Browse',\r\n    startupBehavior: 'newTab',\r\n    telemetryOptIn: false,\r\n    showKeyboardHints: true,\r\n    allowBetaUpdates: false,\r\n  },\r\n  privacy: {\r\n    localOnlyMode: false,\r\n    doNotTrack: true,\r\n    clearOnExit: false,\r\n    blockThirdPartyCookies: true,\r\n    safeBrowsing: true,\r\n    trackerProtection: true,\r\n    adBlockEnabled: true,\r\n    malwareProtection: true,\r\n    autoUpdateFilters: true,\r\n  },\r\n  appearance: {\r\n    theme: 'dark',\r\n    compactUI: false,\r\n    showTabNumbers: true,\r\n    accent: 'purple',\r\n    chromeNewTabPage: true, // Chrome-style new tab page is now the default UI\r\n  },\r\n  account: {\r\n    displayName: 'Explorer',\r\n    email: 'you@regen.app',\r\n    workspace: 'Personal',\r\n    avatarUrl: undefined,\r\n    avatarColor: '#8b5cf6', // Default purple\r\n    lastSyncedAt: Date.now(),\r\n  },\r\n  videoDownloadConsent: false,\r\n  searchEngine: 'duckduckgo',\r\n  language: 'auto',\r\n});\r\n\r\nconst dataKeys: Array<keyof SettingsData> = [\r\n  'general',\r\n  'privacy',\r\n  'appearance',\r\n  'account',\r\n  'videoDownloadConsent',\r\n  'searchEngine',\r\n];\r\n\r\nexport const useSettingsStore = create<SettingsState>()(\r\n  persist(\r\n    (set, _get) => ({\r\n      ...createDefaults(),\r\n      setConsent: value => set({ videoDownloadConsent: value }),\r\n      setSearchEngine: searchEngine => set({ searchEngine }),\r\n      setLanguage: language => set({ language }),\r\n      updateGeneral: partial => set(state => ({ general: { ...state.general, ...partial } })),\r\n      updatePrivacy: partial => set(state => ({ privacy: { ...state.privacy, ...partial } })),\r\n      updateAppearance: partial =>\r\n        set(state => ({ appearance: { ...state.appearance, ...partial } })),\r\n      updateAccount: partial => set(state => ({ account: { ...state.account, ...partial } })),\r\n      resetSettings: () => {\r\n        const defaults = createDefaults();\r\n        set(() => defaults);\r\n      },\r\n    }),\r\n    {\r\n      name: 'regen:settings-v1',\r\n      version: 1,\r\n      partialize: state => {\r\n        const persisted: Partial<SettingsData> = {};\r\n        for (const key of dataKeys) {\r\n          // @ts-ignore - dynamic assignment\r\n          persisted[key] = state[key];\r\n        }\r\n        return persisted;\r\n      },\r\n      merge: (persistedState, currentState) => ({\r\n        ...currentState,\r\n        ...(persistedState as Partial<SettingsData>),\r\n      }),\r\n    }\r\n  )\r\n);\r\n","import { create } from 'zustand';\nimport { persist } from 'zustand/middleware';\n\nexport type StreamStatus = 'idle' | 'connecting' | 'live' | 'complete' | 'error';\n\nexport interface AgentStreamEvent {\n  id: string;\n  type: 'start' | 'step' | 'log' | 'done' | 'consent' | 'error';\n  step?: number;\n  status?: string;\n  content?: string;\n  timestamp: number;\n  risk?: 'low' | 'medium' | 'high';\n  approved?: boolean;\n  // PR: Fix tab switch - track which tab this event belongs to\n  tabId?: string | null;\n  sessionId?: string | null;\n}\n\ninterface AgentStreamState {\n  runId: string | null;\n  status: StreamStatus;\n  transcript: string;\n  events: AgentStreamEvent[];\n  error: string | null;\n  lastGoal: string | null;\n  // PR: Fix tab switch - track active tab for agent operations\n  activeTabId: string | null;\n  setRun: (runId: string, goal: string | null, tabId?: string | null) => void;\n  setStatus: (status: StreamStatus) => void;\n  setError: (error: string | null) => void;\n  appendEvent: (event: AgentStreamEvent) => void;\n  appendTranscript: (delta: string) => void;\n  setActiveTabId: (tabId: string | null) => void;\n  reset: () => void;\n}\n\nexport const useAgentStreamStore = create<AgentStreamState>()(\n  persist(\n    set => ({\n      runId: null,\n      status: 'idle',\n      transcript: '',\n      events: [],\n      error: null,\n      lastGoal: null,\n      activeTabId: null,\n      setRun: (runId, goal, tabId = null) => {\n        console.log('[AGENT_STREAM] setRun', { runId, goal, tabId });\n        set({\n          runId,\n          status: 'live',\n          error: null,\n          transcript: '',\n          events: [],\n          lastGoal: goal,\n          activeTabId: tabId,\n        });\n      },\n      setStatus: status => set({ status }),\n      setError: error => set({ error, status: error ? 'error' : 'idle' }),\n      appendEvent: event => {\n        // PR: Fix tab switch - only append events for current active tab\n        const state = useAgentStreamStore.getState();\n        if (event.tabId && state.activeTabId && event.tabId !== state.activeTabId) {\n          console.log('[AGENT_STREAM] Ignoring event for inactive tab', {\n            eventTabId: event.tabId,\n            activeTabId: state.activeTabId,\n            eventType: event.type,\n          });\n          return;\n        }\n        console.log('[AGENT_STREAM] appendEvent', {\n          eventId: event.id,\n          type: event.type,\n          tabId: event.tabId,\n          activeTabId: state.activeTabId,\n        });\n        set(state => ({\n          events: [...state.events, event],\n        }));\n      },\n      appendTranscript: delta => {\n        const state = useAgentStreamStore.getState();\n        console.log('[AGENT_STREAM] appendTranscript', {\n          deltaLength: delta.length,\n          activeTabId: state.activeTabId,\n        });\n        set(state => ({\n          transcript: state.transcript ? `${state.transcript}${delta}` : delta,\n        }));\n      },\n      setActiveTabId: tabId => {\n        console.log('[AGENT_STREAM] setActiveTabId', { tabId });\n        set({ activeTabId: tabId });\n      },\n      reset: () => {\n        console.log('[AGENT_STREAM] reset');\n        set({\n          runId: null,\n          status: 'idle',\n          transcript: '',\n          events: [],\n          error: null,\n          lastGoal: null,\n          activeTabId: null,\n        });\n      },\n    }),\n    {\n      name: 'regen-agent-stream-storage',\n      // Only persist critical state, not transient streaming data\n      partialize: state => ({\n        runId: state.runId,\n        status: state.status,\n        transcript: state.transcript,\n        events: state.events.slice(-50), // Keep last 50 events\n        lastGoal: state.lastGoal,\n        activeTabId: state.activeTabId, // PR: Fix tab switch - persist active tab\n        // Don't persist error state (should be cleared on restart)\n      }),\n    }\n  )\n);\n","/**\n * LLM Adapter - Unified interface for multiple LLM providers\n * Supports OpenAI, Anthropic, and Mistral with automatic fallback\n */\n\nexport type LLMProvider = 'openai' | 'anthropic' | 'mistral' | 'ollama';\nexport type LLMModel = string;\n\nexport interface LLMOptions {\n  provider?: LLMProvider;\n  model?: LLMModel;\n  maxTokens?: number;\n  temperature?: number;\n  topP?: number;\n  stream?: boolean;\n  systemPrompt?: string;\n  stopSequences?: string[];\n}\n\nexport interface LLMResponse {\n  text: string;\n  raw: any;\n  provider: LLMProvider;\n  model: string;\n  usage?: {\n    promptTokens?: number;\n    completionTokens?: number;\n    totalTokens?: number;\n  };\n  latency?: number;\n}\n\nexport interface LLMError {\n  code: string;\n  message: string;\n  provider: LLMProvider;\n  retryable: boolean;\n}\n\n/**\n * Detect the best available provider based on environment variables\n */\nfunction detectProvider(): LLMProvider | null {\n  if (import.meta.env.VITE_OPENAI_API_KEY || import.meta.env.OPENAI_API_KEY) {\n    return 'openai';\n  }\n  if (import.meta.env.VITE_ANTHROPIC_API_KEY || import.meta.env.ANTHROPIC_API_KEY) {\n    return 'anthropic';\n  }\n  if (import.meta.env.VITE_MISTRAL_API_KEY || import.meta.env.MISTRAL_API_KEY) {\n    return 'mistral';\n  }\n  if (import.meta.env.VITE_OLLAMA_BASE_URL || import.meta.env.OLLAMA_BASE_URL) {\n    return 'ollama';\n  }\n  return null;\n}\n\n/**\n * Get API key for provider\n */\nfunction getApiKey(provider: LLMProvider): string | null {\n  const keys: Record<LLMProvider, string[]> = {\n    openai: ['VITE_OPENAI_API_KEY', 'OPENAI_API_KEY'],\n    anthropic: ['VITE_ANTHROPIC_API_KEY', 'ANTHROPIC_API_KEY'],\n    mistral: ['VITE_MISTRAL_API_KEY', 'MISTRAL_API_KEY'],\n    ollama: [], // No API key needed\n  };\n\n  for (const key of keys[provider] || []) {\n    const value =\n      import.meta.env[key] || (typeof process !== 'undefined' ? process.env[key] : null);\n    if (value) return value;\n  }\n  return null;\n}\n\n/**\n * Get base URL for provider\n */\nfunction getBaseUrl(provider: LLMProvider): string {\n  const baseUrls: Record<LLMProvider, string> = {\n    openai:\n      import.meta.env.VITE_OPENAI_BASE_URL ||\n      import.meta.env.OPENAI_BASE_URL ||\n      'https://api.openai.com/v1',\n    anthropic: 'https://api.anthropic.com/v1',\n    mistral: 'https://api.mistral.ai/v1',\n    ollama:\n      import.meta.env.VITE_OLLAMA_BASE_URL ||\n      import.meta.env.OLLAMA_BASE_URL ||\n      'http://localhost:11434',\n  };\n  return baseUrls[provider] || baseUrls.openai;\n}\n\n/**\n * Get default model for provider\n */\nfunction getDefaultModel(provider: LLMProvider): string {\n  const models: Record<LLMProvider, string> = {\n    openai: 'gpt-4o-mini',\n    anthropic: 'claude-3-5-sonnet-20241022',\n    mistral: 'mistral-large-latest',\n    ollama: 'llama3',\n  };\n  return models[provider] || models.openai;\n}\n\n/**\n * Call OpenAI API\n */\nasync function callOpenAI(\n  prompt: string,\n  options: LLMOptions,\n  _apiKey: string,\n  _baseUrl: string\n): Promise<LLMResponse> {\n  const model = options.model || getDefaultModel('openai');\n  const startTime = Date.now();\n\n  const messages = [];\n  if (options.systemPrompt) {\n    messages.push({ role: 'system', content: options.systemPrompt });\n  }\n  messages.push({ role: 'user', content: prompt });\n\n  const body: any = {\n    model,\n    messages,\n    max_tokens: options.maxTokens || 1000,\n    temperature: options.temperature ?? 0.7,\n  };\n\n  if (options.topP !== undefined) body.top_p = options.topP;\n  if (options.stopSequences) body.stop = options.stopSequences;\n  if (options.stream) body.stream = true;\n\n  // Use backend proxy instead of direct OpenAI API call\n  // This avoids Tracking Prevention and keeps API keys secure\n  const API_BASE = import.meta.env.VITE_API_BASE_URL || 'http://localhost:3000';\n  const proxyUrl = `${API_BASE}/api/proxy/openai`;\n\n  const response = await fetch(proxyUrl, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify(body),\n  });\n\n  if (!response.ok) {\n    const error = await response.json().catch(() => ({ error: { message: response.statusText } }));\n    throw {\n      code: `openai_${response.status}`,\n      message: error.error?.message || `OpenAI API error: ${response.statusText}`,\n      provider: 'openai' as LLMProvider,\n      retryable: response.status >= 500 || response.status === 429,\n    } as LLMError;\n  }\n\n  const data = await response.json();\n  const latency = Date.now() - startTime;\n\n  return {\n    text: data.choices[0]?.message?.content || '',\n    raw: data,\n    provider: 'openai',\n    model: data.model || model,\n    usage: data.usage,\n    latency,\n  };\n}\n\n/**\n * Call Anthropic API\n */\nasync function callAnthropic(\n  prompt: string,\n  options: LLMOptions,\n  _apiKey: string\n): Promise<LLMResponse> {\n  const model = options.model || getDefaultModel('anthropic');\n  const startTime = Date.now();\n\n  const messages = [{ role: 'user', content: prompt }];\n\n  const body: any = {\n    model,\n    messages,\n    max_tokens: options.maxTokens || 1000,\n    temperature: options.temperature ?? 0.7,\n  };\n\n  if (options.systemPrompt) body.system = options.systemPrompt;\n  if (options.topP !== undefined) body.top_p = options.topP;\n  if (options.stopSequences) body.stop_sequences = options.stopSequences;\n\n  // Use backend proxy instead of direct Anthropic API call\n  // This avoids Tracking Prevention and keeps API keys secure\n  const API_BASE = import.meta.env.VITE_API_BASE_URL || 'http://localhost:3000';\n  const proxyUrl = `${API_BASE}/api/proxy/anthropic`;\n\n  const response = await fetch(proxyUrl, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify(body),\n  });\n\n  if (!response.ok) {\n    const error = await response.json().catch(() => ({ error: { message: response.statusText } }));\n    throw {\n      code: `anthropic_${response.status}`,\n      message: error.error?.message || `Anthropic API error: ${response.statusText}`,\n      provider: 'anthropic' as LLMProvider,\n      retryable: response.status >= 500 || response.status === 429,\n    } as LLMError;\n  }\n\n  const data = await response.json();\n  const latency = Date.now() - startTime;\n\n  return {\n    text: data.content[0]?.text || '',\n    raw: data,\n    provider: 'anthropic',\n    model: data.model || model,\n    usage: data.usage,\n    latency,\n  };\n}\n\n/**\n * Call Mistral API\n */\nasync function callMistral(\n  prompt: string,\n  options: LLMOptions,\n  apiKey: string,\n  baseUrl: string\n): Promise<LLMResponse> {\n  const model = options.model || getDefaultModel('mistral');\n  const startTime = Date.now();\n\n  const messages = [];\n  if (options.systemPrompt) {\n    messages.push({ role: 'system', content: options.systemPrompt });\n  }\n  messages.push({ role: 'user', content: prompt });\n\n  const body: any = {\n    model,\n    messages,\n    max_tokens: options.maxTokens || 1000,\n    temperature: options.temperature ?? 0.7,\n  };\n\n  if (options.topP !== undefined) body.top_p = options.topP;\n  if (options.stopSequences) body.stop = options.stopSequences;\n\n  const response = await fetch(`${baseUrl}/chat/completions`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      Authorization: `Bearer ${apiKey}`,\n    },\n    body: JSON.stringify(body),\n  });\n\n  if (!response.ok) {\n    const error = await response.json().catch(() => ({ error: { message: response.statusText } }));\n    throw {\n      code: `mistral_${response.status}`,\n      message: error.error?.message || `Mistral API error: ${response.statusText}`,\n      provider: 'mistral' as LLMProvider,\n      retryable: response.status >= 500 || response.status === 429,\n    } as LLMError;\n  }\n\n  const data = await response.json();\n  const latency = Date.now() - startTime;\n\n  return {\n    text: data.choices[0]?.message?.content || '',\n    raw: data,\n    provider: 'mistral',\n    model: data.model || model,\n    usage: data.usage,\n    latency,\n  };\n}\n\n/**\n * Call Ollama API (local LLM)\n */\nasync function callOllama(\n  prompt: string,\n  options: LLMOptions,\n  baseUrl: string\n): Promise<LLMResponse> {\n  const model = options.model || getDefaultModel('ollama');\n  const startTime = Date.now();\n\n  const messages = [];\n  if (options.systemPrompt) {\n    messages.push({ role: 'system', content: options.systemPrompt });\n  }\n  messages.push({ role: 'user', content: prompt });\n\n  const body: any = {\n    model,\n    messages,\n    options: {\n      num_predict: options.maxTokens || 1000,\n      temperature: options.temperature ?? 0.7,\n    },\n  };\n\n  if (options.topP !== undefined) body.options.top_p = options.topP;\n  if (options.stopSequences) body.options.stop = options.stopSequences;\n\n  const response = await fetch(`${baseUrl}/api/chat`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify(body),\n  });\n\n  if (!response.ok) {\n    throw {\n      code: `ollama_${response.status}`,\n      message: `Ollama API error: ${response.statusText}`,\n      provider: 'ollama' as LLMProvider,\n      retryable: false, // Local service, usually not retryable\n    } as LLMError;\n  }\n\n  const data = await response.json();\n  const latency = Date.now() - startTime;\n\n  return {\n    text: data.message?.content || '',\n    raw: data,\n    provider: 'ollama',\n    model: data.model || model,\n    latency,\n  };\n}\n\n/**\n * Send a prompt to an LLM provider\n * Automatically handles retries, fallbacks, and error recovery\n */\nexport async function sendPrompt(prompt: string, options: LLMOptions = {}): Promise<LLMResponse> {\n  const providers: LLMProvider[] = options.provider\n    ? [options.provider]\n    : (['openai', 'anthropic', 'mistral', 'ollama'] as LLMProvider[]);\n\n  let lastError: LLMError | null = null;\n\n  for (const provider of providers) {\n    try {\n      const apiKey = provider !== 'ollama' ? getApiKey(provider) : null;\n\n      // Skip if API key is required but missing\n      if (provider !== 'ollama' && !apiKey) {\n        continue;\n      }\n\n      const baseUrl = getBaseUrl(provider);\n\n      let response: LLMResponse;\n\n      switch (provider) {\n        case 'openai':\n          response = await callOpenAI(prompt, options, apiKey!, baseUrl);\n          break;\n        case 'anthropic':\n          response = await callAnthropic(prompt, options, apiKey!);\n          break;\n        case 'mistral':\n          response = await callMistral(prompt, options, apiKey!, baseUrl);\n          break;\n        case 'ollama':\n          response = await callOllama(prompt, options, baseUrl);\n          break;\n        default:\n          throw new Error(`Unsupported provider: ${provider}`);\n      }\n\n      // Log metrics\n      if (response.latency) {\n        console.debug(`[LLM] ${provider} response in ${response.latency}ms`, {\n          model: response.model,\n          tokens: response.usage?.totalTokens,\n        });\n      }\n\n      return response;\n    } catch (error: any) {\n      lastError = error;\n      console.warn(`[LLM] ${provider} failed:`, error.message);\n\n      // If error is retryable, try next provider\n      if (error.retryable && providers.length > 1) {\n        continue;\n      }\n\n      // If not retryable or last provider, throw\n      if (provider === providers[providers.length - 1]) {\n        throw error;\n      }\n    }\n  }\n\n  // All providers failed\n  if (!lastError) {\n    const detectedProvider = detectProvider();\n    throw {\n      code: 'no_provider',\n      message: detectedProvider\n        ? `No API key found for ${detectedProvider}. Please set environment variables.`\n        : 'No LLM provider configured. Set OPENAI_API_KEY, ANTHROPIC_API_KEY, MISTRAL_API_KEY, or OLLAMA_BASE_URL.',\n      provider: 'openai' as LLMProvider,\n      retryable: false,\n    } as LLMError;\n  }\n\n  throw lastError;\n}\n\n/**\n * Stream a prompt to an LLM provider (for real-time responses)\n */\nexport async function streamPrompt(\n  prompt: string,\n  options: LLMOptions = {},\n  onChunk: (chunk: string) => void\n): Promise<LLMResponse> {\n  // For streaming, prefer OpenAI or Anthropic\n  const provider = options.provider || detectProvider() || 'openai';\n  const apiKey = getApiKey(provider);\n\n  if (!apiKey && provider !== 'ollama') {\n    throw new Error(`API key required for ${provider}`);\n  }\n\n  // const baseUrl = getBaseUrl(provider); // Unused for now\n\n  // Simplified streaming - for now, use regular sendPrompt and simulate streaming\n  // In production, implement proper SSE/streaming\n  const response = await sendPrompt(prompt, { ...options, provider });\n\n  // Simulate streaming by chunking the response\n  const words = response.text.split(' ');\n  for (let i = 0; i < words.length; i++) {\n    await new Promise(resolve => setTimeout(resolve, 50));\n    onChunk(words[i] + (i < words.length - 1 ? ' ' : ''));\n  }\n\n  return response;\n}\n\n/**\n * Get available providers based on configured API keys\n */\nexport function getAvailableProviders(): LLMProvider[] {\n  const providers: LLMProvider[] = [];\n\n  if (getApiKey('openai')) providers.push('openai');\n  if (getApiKey('anthropic')) providers.push('anthropic');\n  if (getApiKey('mistral')) providers.push('mistral');\n  if (getBaseUrl('ollama')) providers.push('ollama'); // Assume Ollama is available if URL is set\n\n  return providers;\n}\n","import { sendPrompt, type LLMOptions, type LLMResponse, type LLMProvider } from '../llm/adapter';\r\nimport { trackAction } from '../supermemory/tracker';\r\n// @ts-ignore - p-queue types may not be available\r\nimport PQueue from 'p-queue';\r\n\r\nexport type AITaskKind = 'search' | 'agent' | 'chat' | 'summary';\r\n\r\nexport interface AITaskRequest {\r\n  kind: AITaskKind;\r\n  prompt: string;\r\n  context?: Record<string, unknown>;\r\n  mode?: string;\r\n  metadata?: Record<string, string | number | boolean>;\r\n  llm?: LLMOptions;\r\n  stream?: boolean;\r\n  signal?: AbortSignal | null;\r\n}\r\n\r\nexport interface AITaskResult {\r\n  text: string;\r\n  provider: string;\r\n  model: string;\r\n  usage?: LLMResponse['usage'];\r\n  latency?: number;\r\n  citations?: Array<{ title?: string; url?: string; snippet?: string; source?: string }>;\r\n  estimated_cost_usd?: number;\r\n}\r\n\r\ntype StreamHandler = (event: {\r\n  type: 'token' | 'done' | 'error';\r\n  data?: string | AITaskResult;\r\n}) => void;\r\n\r\n/**\r\n * Enhanced AI Engine with provider chaining, rate limiting, and state persistence\r\n */\r\nexport class AIEngine {\r\n  private readonly apiBase =\r\n    import.meta.env.VITE_APP_API_URL ||\r\n    import.meta.env.VITE_API_BASE_URL ||\r\n    (typeof window !== 'undefined' ? window.__OB_API_BASE__ : '');\r\n\r\n  // Rate limiting: max 2 concurrent AI requests to prevent overload\r\n  private readonly requestQueue = new PQueue({ concurrency: 2 });\r\n\r\n  // Provider chain: try in order, fallback to next on failure\r\n  private readonly providerChain: LLMProvider[] = ['openai', 'anthropic', 'ollama'];\r\n\r\n  // State persistence key\r\n  private readonly STATE_KEY = 'regen:ai_engine_state';\r\n\r\n  async runTask(request: AITaskRequest, onStream?: StreamHandler): Promise<AITaskResult> {\r\n    if (!request.prompt?.trim()) {\r\n      throw new Error('Prompt is required for AI tasks');\r\n    }\r\n\r\n    // Save state before running\r\n    this.saveState(request);\r\n\r\n    // Use queue to limit concurrency (max 2 concurrent requests)\r\n    return (await this.requestQueue.add(async (): Promise<AITaskResult> => {\r\n      // Try backend first\r\n      const backendResult = await this.callBackendTask(request, onStream);\r\n      if (backendResult) {\r\n        this.saveState(request, backendResult);\r\n        return backendResult;\r\n      }\r\n\r\n      // Fallback to local LLM with provider chaining\r\n      const localResult = await this.runLocalLLMWithFallback(request, onStream);\r\n      this.saveState(request, localResult);\r\n      return localResult;\r\n    })) as AITaskResult;\r\n  }\r\n\r\n  private async callBackendTask(\r\n    request: AITaskRequest,\r\n    onStream?: StreamHandler\r\n  ): Promise<AITaskResult | null> {\r\n    if (!this.apiBase || typeof fetch === 'undefined') {\r\n      return null;\r\n    }\r\n    const base = this.apiBase.replace(/\\/$/, '');\r\n\r\n    // Create AbortController with timeout (30 seconds default, 60 for streaming)\r\n    const timeoutMs = request.stream ? 60000 : 30000;\r\n    const controller = new AbortController();\r\n    const timeoutId = setTimeout(() => controller.abort(), timeoutMs);\r\n\r\n    // Combine user signal with timeout signal\r\n    const combinedSignal = request.signal\r\n      ? (() => {\r\n          const combined = new AbortController();\r\n          request.signal!.addEventListener('abort', () => combined.abort());\r\n          controller.signal.addEventListener('abort', () => combined.abort());\r\n          return combined.signal;\r\n        })()\r\n      : controller.signal;\r\n\r\n    try {\r\n      const response = await fetch(`${base}/api/ai/task`, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n        },\r\n        body: JSON.stringify({\r\n          kind: request.kind,\r\n          prompt: request.prompt,\r\n          context: request.context,\r\n          mode: request.mode,\r\n          metadata: request.metadata,\r\n          temperature: request.llm?.temperature ?? 0.2,\r\n          max_tokens: request.llm?.maxTokens ?? 800,\r\n        }),\r\n        signal: combinedSignal,\r\n      });\r\n\r\n      if (!response.ok) {\r\n        const errorText = await response.text();\r\n        console.warn('[AIEngine] Backend task failed', response.status, errorText);\r\n        return null;\r\n      }\r\n\r\n      if (response.headers.get('content-type')?.includes('text/event-stream')) {\r\n        const reader = response.body?.getReader();\r\n        if (!reader) {\r\n          return null;\r\n        }\r\n        const decoder = new TextDecoder('utf-8');\r\n        let buffer = '';\r\n        const tokens: string[] = [];\r\n        while (true) {\r\n          // Check if aborted before reading\r\n          if (combinedSignal.aborted) {\r\n            onStream?.({ type: 'error', data: 'Request timeout - please try again' });\r\n            break;\r\n          }\r\n          const { value, done } = await reader.read();\r\n          if (done) break;\r\n          buffer += decoder.decode(value, { stream: true });\r\n          const events = buffer.split('\\n\\n');\r\n          buffer = events.pop() || '';\r\n          for (const event of events) {\r\n            if (event.startsWith('event: error')) {\r\n              try {\r\n                const json = event.replace('event: error', '').replace('data:', '').trim();\r\n                const errorPayload = JSON.parse(json) as {\r\n                  message?: string;\r\n                  type?: string;\r\n                  retryable?: boolean;\r\n                  provider?: string;\r\n                  model?: string;\r\n                };\r\n                const errorMessage = errorPayload.message || 'AI service error occurred';\r\n                onStream?.({ type: 'error', data: errorMessage });\r\n                console.error('[AIEngine] Task error', errorPayload);\r\n              } catch {\r\n                // Fallback to plain text if JSON parsing fails\r\n                const errorText = event.replace('event: error', '').replace('data:', '').trim();\r\n                onStream?.({ type: 'error', data: errorText || 'AI service error occurred' });\r\n              }\r\n            } else if (event.startsWith('event: done')) {\r\n              try {\r\n                const json = event.replace('event: done', '').replace('data:', '').trim();\r\n                const payload = JSON.parse(json) as AITaskResult;\r\n                if (!payload.text) {\r\n                  payload.text = tokens.join('');\r\n                }\r\n                this.trackTelemetry(payload, request);\r\n                onStream?.({ type: 'done', data: payload });\r\n                return payload;\r\n              } catch (error) {\r\n                console.warn('[AIEngine] Failed to parse done payload', error);\r\n                onStream?.({ type: 'done', data: tokens.join('') });\r\n                return { text: tokens.join(''), provider: 'openai', model: 'unknown' };\r\n              }\r\n            } else if (event.startsWith('data:')) {\r\n              const token = event.replace('data:', '').trim();\r\n              tokens.push(token);\r\n              onStream?.({ type: 'token', data: token });\r\n            }\r\n          }\r\n        }\r\n        clearTimeout(timeoutId);\r\n      }\r\n\r\n      const data = (await response.json()) as AITaskResult;\r\n      clearTimeout(timeoutId);\r\n      this.trackTelemetry(data, request);\r\n      onStream?.({ type: 'done', data: data });\r\n      return data;\r\n    } catch (error) {\r\n      clearTimeout(timeoutId);\r\n      if (error instanceof Error && error.name === 'AbortError') {\r\n        console.warn('[AIEngine] Request timeout after', timeoutMs, 'ms');\r\n        onStream?.({ type: 'error', data: 'Request timeout - please try again' });\r\n      } else {\r\n        console.warn('[AIEngine] Backend request error', error);\r\n      }\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Run local LLM with provider chaining (OpenAI  Anthropic  Ollama)\r\n   */\r\n  private async runLocalLLMWithFallback(\r\n    request: AITaskRequest,\r\n    onStream?: StreamHandler\r\n  ): Promise<AITaskResult> {\r\n    let lastError: Error | null = null;\r\n\r\n    // Try each provider in chain\r\n    for (const provider of this.providerChain) {\r\n      try {\r\n        const response = await sendPrompt(request.prompt, {\r\n          ...request.llm,\r\n          provider,\r\n          stream: Boolean(onStream) || request.llm?.stream,\r\n          systemPrompt: request.llm?.systemPrompt ?? this.resolveSystemPrompt(request),\r\n        });\r\n\r\n        const result = {\r\n          text: response.text,\r\n          provider: response.provider,\r\n          model: response.model,\r\n          usage: response.usage,\r\n          latency: response.latency,\r\n        };\r\n\r\n        this.saveState(request, result);\r\n        this.trackTelemetry(result, request);\r\n        onStream?.({ type: 'done', data: result });\r\n        return result;\r\n      } catch (error: any) {\r\n        lastError = error;\r\n        console.warn(`[AIEngine] Provider ${provider} failed:`, error.message);\r\n\r\n        // If not the last provider, try next one\r\n        if (provider !== this.providerChain[this.providerChain.length - 1]) {\r\n          continue;\r\n        }\r\n      }\r\n    }\r\n\r\n    // All providers failed\r\n    const errorMessage = lastError?.message || 'All AI providers failed';\r\n    onStream?.({ type: 'error', data: errorMessage });\r\n    throw new Error(errorMessage);\r\n  }\r\n\r\n  private async runLocalLLM(\r\n    request: AITaskRequest,\r\n    onStream?: StreamHandler\r\n  ): Promise<AITaskResult> {\r\n    // Legacy method - use fallback version instead\r\n    return this.runLocalLLMWithFallback(request, onStream);\r\n  }\r\n\r\n  /**\r\n   * Save AI task state to localStorage for crash recovery\r\n   */\r\n  private saveState(request: AITaskRequest, result?: AITaskResult): void {\r\n    if (typeof window === 'undefined' || !window.localStorage) return;\r\n\r\n    try {\r\n      const state = {\r\n        request: {\r\n          kind: request.kind,\r\n          prompt: request.prompt.substring(0, 200), // Truncate for storage\r\n          mode: request.mode,\r\n          timestamp: Date.now(),\r\n        },\r\n        result: result\r\n          ? {\r\n              provider: result.provider,\r\n              model: result.model,\r\n              textLength: result.text?.length || 0,\r\n            }\r\n          : undefined,\r\n      };\r\n\r\n      // Keep only last 10 states\r\n      const existing = JSON.parse(localStorage.getItem(this.STATE_KEY) || '[]');\r\n      existing.push(state);\r\n      const recent = existing.slice(-10);\r\n      localStorage.setItem(this.STATE_KEY, JSON.stringify(recent));\r\n    } catch (error) {\r\n      console.warn('[AIEngine] Failed to save state:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get last AI task state (for crash recovery)\r\n   */\r\n  getLastState(): { request: AITaskRequest; result?: AITaskResult } | null {\r\n    if (typeof window === 'undefined' || !window.localStorage) return null;\r\n\r\n    try {\r\n      const states = JSON.parse(localStorage.getItem(this.STATE_KEY) || '[]');\r\n      const last = states[states.length - 1];\r\n      if (!last) return null;\r\n\r\n      return {\r\n        request: {\r\n          kind: last.request.kind || 'agent',\r\n          prompt: last.request.prompt || '',\r\n          mode: last.request.mode,\r\n        },\r\n        result: last.result\r\n          ? {\r\n              text: '',\r\n              provider: last.result.provider,\r\n              model: last.result.model,\r\n            }\r\n          : undefined,\r\n      };\r\n    } catch (error) {\r\n      console.warn('[AIEngine] Failed to load state:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  private resolveSystemPrompt(request: AITaskRequest): string | undefined {\r\n    switch (request.kind) {\r\n      case 'search':\r\n        return 'You are ReGens research copilot. Cite sources as [n].';\r\n      case 'agent':\r\n        return 'You are an execution agent. Be concise.';\r\n      default:\r\n        return undefined;\r\n    }\r\n  }\r\n\r\n  private trackTelemetry(result: AITaskResult, request: AITaskRequest) {\r\n    try {\r\n      trackAction('ai_task_success', {\r\n        kind: request.kind,\r\n        provider: result.provider,\r\n        model: result.model,\r\n        latencyMs: result.latency ?? null,\r\n        promptLength: request.prompt.length,\r\n      }).catch(() => {});\r\n    } catch (error) {\r\n      console.warn('[AIEngine] Failed to track telemetry', error);\r\n    }\r\n  }\r\n}\r\n\r\nexport const aiEngine = new AIEngine();\r\n","/**\n * Agent Loop Resume System\n * Saves agent execution state to localStorage and restores on crash/reload\n */\n\nimport { useAgentStreamStore, type AgentStreamEvent } from '../../state/agentStreamStore';\n\nexport interface LoopState {\n  runId: string;\n  goal: string;\n  status: 'idle' | 'connecting' | 'live' | 'complete' | 'error';\n  transcript: string;\n  events: AgentStreamEvent[];\n  error: string | null;\n  lastSaved: number;\n  mode?: 'research' | 'trade' | 'browse' | 'agent';\n  metadata?: {\n    language?: string;\n    [key: string]: unknown;\n  };\n}\n\nconst LOOP_STATE_KEY = 'regen:agent-loops';\nconst MAX_SAVED_LOOPS = 10;\nconst SAVE_INTERVAL_MS = 5000; // Save every 5 seconds\n\n/**\n * Save current agent loop state\n */\nexport function saveLoopState(state: Partial<LoopState>): void {\n  try {\n    const existing = loadAllLoopStates();\n    const currentRunId = useAgentStreamStore.getState().runId;\n\n    if (!currentRunId) return;\n\n    const fullState: LoopState = {\n      runId: currentRunId,\n      goal: useAgentStreamStore.getState().lastGoal || state.goal || '',\n      status: useAgentStreamStore.getState().status,\n      transcript: useAgentStreamStore.getState().transcript,\n      events: useAgentStreamStore.getState().events,\n      error: useAgentStreamStore.getState().error,\n      lastSaved: Date.now(),\n      ...state,\n    };\n\n    // Update or add this loop state\n    const updated = existing.filter(s => s.runId !== currentRunId);\n    updated.unshift(fullState);\n\n    // Keep only recent loops\n    const trimmed = updated.slice(0, MAX_SAVED_LOOPS);\n\n    localStorage.setItem(LOOP_STATE_KEY, JSON.stringify(trimmed));\n  } catch (error) {\n    console.warn('[LoopResume] Failed to save loop state:', error);\n  }\n}\n\n/**\n * Load all saved loop states\n */\nexport function loadAllLoopStates(): LoopState[] {\n  try {\n    const raw = localStorage.getItem(LOOP_STATE_KEY);\n    if (!raw) return [];\n    const parsed = JSON.parse(raw);\n    return Array.isArray(parsed) ? parsed : [];\n  } catch (error) {\n    console.warn('[LoopResume] Failed to load loop states:', error);\n    return [];\n  }\n}\n\n/**\n * Load a specific loop state by runId\n */\nexport function loadLoopState(runId: string): LoopState | null {\n  const all = loadAllLoopStates();\n  return all.find(s => s.runId === runId) || null;\n}\n\n/**\n * Resume a loop from saved state\n */\nexport function resumeLoop(runId: string): boolean {\n  try {\n    const state = loadLoopState(runId);\n    if (!state) {\n      console.warn('[LoopResume] No saved state found for runId:', runId);\n      return false;\n    }\n\n    // Restore to agent stream store\n    const store = useAgentStreamStore.getState();\n    store.setRun(state.runId, state.goal);\n    store.setStatus(state.status);\n    store.setError(state.error);\n\n    // Restore transcript\n    if (state.transcript) {\n      // Clear and restore transcript\n      store.reset();\n      store.setRun(state.runId, state.goal);\n      state.transcript.split('\\n').forEach(line => {\n        if (line.trim()) {\n          store.appendTranscript(line + '\\n');\n        }\n      });\n    }\n\n    // Restore events\n    state.events.forEach(event => {\n      store.appendEvent(event);\n    });\n\n    console.log('[LoopResume] Resumed loop:', runId, 'with', state.events.length, 'events');\n    return true;\n  } catch (error) {\n    console.error('[LoopResume] Failed to resume loop:', error);\n    return false;\n  }\n}\n\n/**\n * Delete a saved loop state\n */\nexport function deleteLoopState(runId: string): void {\n  try {\n    const all = loadAllLoopStates();\n    const filtered = all.filter(s => s.runId !== runId);\n    localStorage.setItem(LOOP_STATE_KEY, JSON.stringify(filtered));\n  } catch (error) {\n    console.warn('[LoopResume] Failed to delete loop state:', error);\n  }\n}\n\n/**\n * Auto-save loop state on interval\n */\nlet saveInterval: NodeJS.Timeout | null = null;\n\nexport function startAutoSave(metadata?: LoopState['metadata']): void {\n  if (saveInterval) {\n    clearInterval(saveInterval);\n  }\n\n  saveInterval = setInterval(() => {\n    const store = useAgentStreamStore.getState();\n    if (store.runId && store.status === 'live') {\n      saveLoopState({ metadata });\n    }\n  }, SAVE_INTERVAL_MS);\n}\n\nexport function stopAutoSave(): void {\n  if (saveInterval) {\n    clearInterval(saveInterval);\n    saveInterval = null;\n  }\n}\n\n/**\n * Check for crashed loops on app start and offer to resume\n */\nexport function checkForCrashedLoops(): LoopState[] {\n  const all = loadAllLoopStates();\n  const now = Date.now();\n  const CRASH_THRESHOLD_MS = 30000; // 30 seconds without update = likely crashed\n\n  return all.filter(loop => {\n    const timeSinceLastSave = now - loop.lastSaved;\n    return (\n      loop.status === 'live' ||\n      loop.status === 'connecting' ||\n      (timeSinceLastSave < CRASH_THRESHOLD_MS && loop.status !== 'complete')\n    );\n  });\n}\n","/**\n * Multi-Agent Handoff System\n * Enables agents to pass data and trigger actions in other modes\n */\n\nimport { ipc } from '../../lib/ipc-typed';\nimport { useSettingsStore } from '../../state/settingsStore';\nimport { toast } from 'react-hot-toast';\n\nexport type HandoffTarget = 'research' | 'trade' | 'browse' | 'agent' | 'n8n';\n\nexport interface HandoffPayload {\n  type: string;\n  data: Record<string, unknown>;\n  sourceMode: string;\n  targetMode: HandoffTarget;\n  language?: string;\n  metadata?: {\n    priority?: 'low' | 'medium' | 'high';\n    autoExecute?: boolean;\n    [key: string]: unknown;\n  };\n}\n\nexport interface HandoffResult {\n  success: boolean;\n  targetId?: string;\n  error?: string;\n  data?: unknown;\n}\n\n/**\n * Send handoff from one agent/mode to another\n */\nexport async function sendHandoff(payload: HandoffPayload): Promise<HandoffResult> {\n  try {\n    const language = payload.language || useSettingsStore.getState().language || 'auto';\n\n    switch (payload.targetMode) {\n      case 'research':\n        return await handoffToResearch(payload, language);\n\n      case 'trade':\n        return await handoffToTrade(payload, language);\n\n      case 'n8n':\n        return await handoffToN8n(payload, language);\n\n      case 'browse':\n        return await handoffToBrowse(payload, language);\n\n      default:\n        return { success: false, error: `Unknown target mode: ${payload.targetMode}` };\n    }\n  } catch (error: any) {\n    console.error('[Handoff] Failed to send handoff:', error);\n    return {\n      success: false,\n      error: error.message || 'Unknown handoff error',\n    };\n  }\n}\n\n/**\n * Handoff to Research mode\n */\nasync function handoffToResearch(\n  payload: HandoffPayload,\n  language: string\n): Promise<HandoffResult> {\n  try {\n    const query = (payload.data.query as string) || (payload.data.summary as string);\n    if (!query) {\n      return { success: false, error: 'No query or summary provided for research' };\n    }\n\n    // Switch to Research mode if not already there\n    try {\n      const { useAppStore } = await import('../../state/appStore');\n      const currentMode = useAppStore.getState().mode;\n      if (currentMode !== 'Research') {\n        useAppStore.getState().setMode('Research');\n        // Small delay to allow mode switch\n        await new Promise(resolve => setTimeout(resolve, 300));\n      }\n    } catch (error) {\n      console.debug('[Handoff] Failed to switch to Research mode:', error);\n    }\n\n    // Dispatch custom event for research mode to handle\n    if (typeof window !== 'undefined') {\n      window.dispatchEvent(\n        new CustomEvent('handoff:research', {\n          detail: {\n            query,\n            language,\n            symbol: payload.data.symbol,\n            sourceMode: payload.sourceMode,\n          },\n        })\n      );\n    }\n\n    // Trigger research query\n    try {\n      const researchResult = await ipc.research.queryEnhanced({\n        query,\n        maxSources: 12,\n        language: language !== 'auto' ? language : undefined,\n      });\n\n      toast.success(`Research complete: ${query.slice(0, 50)}...`, {\n        duration: 3000,\n      });\n\n      return {\n        success: true,\n        data: researchResult,\n      };\n    } catch (error) {\n      // If IPC fails, still return success since we dispatched the event\n      console.debug('[Handoff] Research IPC failed, using event only:', error);\n      return {\n        success: true,\n        data: { query, language },\n      };\n    }\n  } catch (error: any) {\n    return {\n      success: false,\n      error: error.message || 'Research handoff failed',\n    };\n  }\n}\n\n/**\n * Handoff to Trade mode\n */\nasync function handoffToTrade(payload: HandoffPayload, _language: string): Promise<HandoffResult> {\n  try {\n    const symbol = payload.data.symbol as string;\n    const action = payload.data.action as 'alert' | 'analyze' | 'signal';\n    const message = (payload.data.message as string) || (payload.data.summary as string);\n\n    if (!symbol && !message) {\n      return { success: false, error: 'No symbol or message provided for trade' };\n    }\n\n    // Switch to Trade mode if not already there\n    try {\n      const { useAppStore } = await import('../../state/appStore');\n      const currentMode = useAppStore.getState().mode;\n      if (currentMode !== 'Trade') {\n        useAppStore.getState().setMode('Trade');\n        // Small delay to allow mode switch\n        await new Promise(resolve => setTimeout(resolve, 300));\n      }\n    } catch (error) {\n      console.debug('[Handoff] Failed to switch to Trade mode:', error);\n    }\n\n    // Create trade alert or signal\n    if (action === 'alert' || action === 'signal') {\n      const alertMessage = message || `Alert for ${symbol}`;\n\n      // Show toast notification\n      toast.success(alertMessage, {\n        duration: 5000,\n        icon: '',\n      });\n\n      // Dispatch custom event for trade mode to handle\n      if (typeof window !== 'undefined') {\n        window.dispatchEvent(\n          new CustomEvent('handoff:trade', {\n            detail: {\n              symbol,\n              action,\n              message,\n              summary: payload.data.summary,\n              sourceMode: payload.sourceMode,\n            },\n          })\n        );\n      }\n\n      // Optionally trigger IPC event for trade mode\n      try {\n        const activeTab = await ipc.tabs.list().then(tabs => tabs.find(t => t.active) || tabs[0]);\n        if (activeTab) {\n          await ipc.crossReality?.handoff?.(activeTab.id, 'mobile');\n        }\n      } catch {\n        // IPC might not be available, that's okay\n        console.debug('[Handoff] Trade IPC not available, using toast only');\n      }\n    }\n\n    return {\n      success: true,\n      data: { symbol, action, message },\n    };\n  } catch (error: any) {\n    return {\n      success: false,\n      error: error.message || 'Trade handoff failed',\n    };\n  }\n}\n\n/**\n * Handoff to n8n workflow\n */\nexport async function handoffToN8n(\n  payload: HandoffPayload,\n  language: string\n): Promise<HandoffResult> {\n  try {\n    const workflowId = payload.data.workflowId as string;\n    const workflowUrl = payload.data.workflowUrl as string;\n    const isLoop = Boolean(payload.data.loop);\n    const loopInterval = payload.data.loopInterval ? Number(payload.data.loopInterval) : undefined;\n    const maxIterations = payload.data.maxIterations\n      ? Number(payload.data.maxIterations)\n      : undefined;\n\n    if (!workflowId) {\n      return { success: false, error: 'No workflow ID provided' };\n    }\n\n    // Use n8n service\n    const { callN8nWorkflow, runN8nWorkflowLoop } = await import('../../services/n8nService');\n\n    const call = {\n      workflowId,\n      data: payload.data,\n      language,\n      sourceMode: payload.sourceMode,\n      metadata: payload.metadata,\n    };\n\n    const config = workflowUrl ? { baseUrl: workflowUrl } : undefined;\n\n    if (isLoop) {\n      // Run workflow in loop\n      const results = await runN8nWorkflowLoop(\n        call,\n        {\n          workflowId,\n          interval: loopInterval || 1000,\n          maxIterations: maxIterations || 10,\n        },\n        config\n      );\n\n      const lastResult = results[results.length - 1];\n\n      toast.success(`Workflow loop completed: ${workflowId} (${results.length} iterations)`, {\n        duration: 3000,\n      });\n\n      return {\n        success: lastResult?.success || false,\n        targetId: workflowId,\n        data: {\n          iterations: results.length,\n          results,\n          lastResult,\n        },\n      };\n    } else {\n      // Single workflow call\n      const result = await callN8nWorkflow(call, config);\n\n      if (result.success) {\n        toast.success(`Workflow triggered: ${workflowId}`, {\n          duration: 3000,\n        });\n      } else {\n        toast.error(`Workflow failed: ${result.error}`, {\n          duration: 5000,\n        });\n      }\n\n      return {\n        success: result.success,\n        targetId: workflowId,\n        data: result.data,\n        error: result.error,\n      };\n    }\n  } catch (error: any) {\n    return {\n      success: false,\n      error: error.message || 'n8n handoff failed',\n    };\n  }\n}\n\n/**\n * Handoff to Browse mode (open URL in tab)\n */\nasync function handoffToBrowse(payload: HandoffPayload, _language: string): Promise<HandoffResult> {\n  try {\n    const url = payload.data.url as string;\n    if (!url) {\n      return { success: false, error: 'No URL provided for browse' };\n    }\n\n    // Create or navigate to tab\n    const tab = await ipc.tabs.create({\n      url,\n      activate: true,\n    });\n\n    const tabId = typeof tab === 'object' && tab && 'id' in tab ? String(tab.id) : String(tab);\n\n    return {\n      success: true,\n      targetId: tabId,\n      data: tab,\n    };\n  } catch (error: any) {\n    return {\n      success: false,\n      error: error.message || 'Browse handoff failed',\n    };\n  }\n}\n\n/**\n * Helper: Research  Trade handoff\n * Example: \"Research Nifty news\"  \"Alert me when Nifty changes\"\n */\nexport async function researchToTrade(\n  researchSummary: string,\n  symbol?: string,\n  language?: string\n): Promise<HandoffResult> {\n  return sendHandoff({\n    type: 'research-to-trade',\n    data: {\n      summary: researchSummary,\n      symbol: symbol || 'NIFTY',\n      action: 'alert',\n      message: `Research update: ${researchSummary.slice(0, 100)}...`,\n    },\n    sourceMode: 'research',\n    targetMode: 'trade',\n    language: language || useSettingsStore.getState().language || 'auto',\n    metadata: {\n      priority: 'medium',\n      autoExecute: true,\n    },\n  });\n}\n\n/**\n * Helper: Trade  Research handoff\n * Example: \"Analyze AAPL\"  \"Research AAPL fundamentals\"\n */\nexport async function tradeToResearch(\n  symbol: string,\n  query: string,\n  language?: string\n): Promise<HandoffResult> {\n  return sendHandoff({\n    type: 'trade-to-research',\n    data: {\n      symbol,\n      query: `${symbol} ${query}`,\n    },\n    sourceMode: 'trade',\n    targetMode: 'research',\n    language: language || useSettingsStore.getState().language || 'auto',\n    metadata: {\n      priority: 'high',\n      autoExecute: true,\n    },\n  });\n}\n","import { create } from 'zustand';\r\nimport { persist } from 'zustand/middleware';\r\n\r\nexport type AgentMemoryEntry = {\r\n  id: string;\r\n  agentId: string;\r\n  runId?: string;\r\n  prompt: string;\r\n  response?: string;\r\n  error?: string;\r\n  success: boolean;\r\n  createdAt: number;\r\n  tokens?: {\r\n    prompt?: number | null;\r\n    completion?: number | null;\r\n    total?: number | null;\r\n  };\r\n};\r\n\r\ninterface AgentMemoryState {\r\n  entries: AgentMemoryEntry[];\r\n  addEntry: (entry: Omit<AgentMemoryEntry, 'id' | 'createdAt'> & { createdAt?: number }) => void;\r\n  getRecentForAgent: (agentId?: string | null, limit?: number) => AgentMemoryEntry[];\r\n  clearAgent: (agentId?: string | null) => void;\r\n  clearAll: () => void;\r\n}\r\n\r\nconst DEFAULT_LIMIT = 20;\r\n\r\nexport const useAgentMemoryStore = create<AgentMemoryState>()(\r\n  persist(\r\n    (set, get) => ({\r\n      entries: [],\r\n      addEntry: (entry) => {\r\n        const newEntry: AgentMemoryEntry = {\r\n          ...entry,\r\n          id: entry.runId ?? `agent-mem-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`,\r\n          createdAt: entry.createdAt ?? Date.now(),\r\n        };\r\n        set((state) => {\r\n          const filtered = state.entries.filter(\r\n            (existing) => !(existing.runId && existing.runId === newEntry.runId),\r\n          );\r\n          const next = [newEntry, ...filtered];\r\n          return { entries: next.slice(0, 200) };\r\n        });\r\n      },\r\n      getRecentForAgent: (agentId, limit = DEFAULT_LIMIT) => {\r\n        const pool = get().entries;\r\n        if (!agentId) {\r\n          return pool.slice(0, limit);\r\n        }\r\n        return pool.filter((entry) => entry.agentId === agentId).slice(0, limit);\r\n      },\r\n      clearAgent: (agentId) => {\r\n        set((state) => ({\r\n          entries: agentId ? state.entries.filter((entry) => entry.agentId !== agentId) : [],\r\n        }));\r\n      },\r\n      clearAll: () => set({ entries: [] }),\r\n    }),\r\n    {\r\n      name: 'regen:agent-memory',\r\n      version: 1,\r\n    },\r\n  ),\r\n);\r\n\r\n","/**\n * Tauri Streaming Orchestrator\n * Real-time agent  partial  actions  execution\n * Supports both WebSocket and SSE\n */\n\nimport { useAgentStreamStore } from '../../state/agentStreamStore';\nimport type { AgentStreamEvent } from '../../state/agentStreamStore';\n\nexport type StreamTransport = 'websocket' | 'sse' | 'event';\n\nexport interface StreamConfig {\n  transport: StreamTransport;\n  url?: string;\n  reconnect?: boolean;\n  reconnectDelay?: number;\n  maxReconnectAttempts?: number;\n}\n\nexport interface AgentMessage {\n  type: 'start' | 'step' | 'action' | 'done' | 'error';\n  runId: string;\n  tabId?: string | null;\n  sessionId?: string | null;\n  content?: string;\n  step?: number;\n  status?: string;\n  action?: {\n    type: string;\n    args: Record<string, unknown>;\n  };\n  timestamp: number;\n  // Message deduplication\n  id?: string; // Unique message ID for deduplication\n}\n\nclass StreamingOrchestrator {\n  private ws: WebSocket | null = null;\n  private eventSource: EventSource | null = null;\n  private reconnectAttempts = 0;\n  private config: StreamConfig | null = null;\n  private listeners: Map<string, Set<(data: AgentMessage) => void>> = new Map();\n  private isConnected = false;\n  private currentRunId: string | null = null;\n  // Message deduplication\n  private seenMessageIds: Set<string> = new Set();\n  private maxSeenSize = 1000;\n  // Heartbeat\n  private heartbeatInterval: NodeJS.Timeout | null = null;\n  private heartbeatIntervalMs = 20000;\n  // Exponential backoff\n  private baseBackoff = 1000;\n  private maxBackoff = 30000;\n  private reconnectTimer: NodeJS.Timeout | null = null;\n\n  /**\n   * Initialize streaming connection\n   */\n  async connect(config: StreamConfig): Promise<void> {\n    this.config = config;\n    this.reconnectAttempts = 0;\n\n    try {\n      if (config.transport === 'websocket') {\n        // Use the correct WebSocket path from server\n        const wsUrl =\n          config.url ||\n          (typeof window !== 'undefined' && (window as any).__API_BASE_URL\n            ? (window as any).__API_BASE_URL\n                .replace('http://', 'ws://')\n                .replace('https://', 'wss://') + '/agent/stream'\n            : 'ws://127.0.0.1:4000/agent/stream');\n        await this.connectWebSocket(wsUrl);\n      } else if (config.transport === 'sse') {\n        await this.connectSSE(config.url || 'http://127.0.0.1:18080/sse');\n      } else {\n        // Event-based (Tauri events)\n        this.isConnected = true;\n        this.setupTauriEventListeners();\n      }\n    } catch (error) {\n      console.error('[StreamingOrchestrator] Connection failed:', error);\n      this.handleReconnect();\n    }\n  }\n\n  /**\n   * Connect via WebSocket\n   */\n  private async connectWebSocket(url: string): Promise<void> {\n    return new Promise((resolve, reject) => {\n      try {\n        // Add clientId and sessionId to URL for proper connection\n        const urlObj = new URL(url);\n        const clientId = `client-${Date.now()}-${Math.random().toString(36).slice(2, 10)}`;\n        const sessionId = `session-${Date.now()}`;\n        urlObj.searchParams.set('clientId', clientId);\n        urlObj.searchParams.set('sessionId', sessionId);\n        const ws = new WebSocket(urlObj.toString());\n\n        ws.onopen = () => {\n          console.log('[StreamingOrchestrator] WebSocket connected');\n          this.ws = ws;\n          this.isConnected = true;\n          this.reconnectAttempts = 0;\n\n          // Start heartbeat\n          this.startHeartbeat();\n\n          resolve();\n        };\n\n        ws.onmessage = event => {\n          try {\n            const message: AgentMessage = JSON.parse(event.data);\n\n            // Deduplicate messages\n            const messageId = message.id || `${message.runId}-${message.timestamp}-${message.type}`;\n            if (this.seenMessageIds.has(messageId)) {\n              console.log('[StreamingOrchestrator] Duplicate message ignored', { messageId });\n              return;\n            }\n\n            // Add to seen set\n            this.seenMessageIds.add(messageId);\n\n            // Limit seen set size\n            if (this.seenMessageIds.size > this.maxSeenSize) {\n              const firstId = this.seenMessageIds.values().next().value;\n              if (firstId !== undefined) {\n                this.seenMessageIds.delete(firstId);\n              }\n            }\n\n            this.handleMessage(message);\n          } catch (error) {\n            console.error('[StreamingOrchestrator] Failed to parse message:', error);\n          }\n        };\n\n        ws.onerror = error => {\n          console.error('[StreamingOrchestrator] WebSocket error:', error);\n          reject(error);\n        };\n\n        ws.onclose = () => {\n          console.log('[StreamingOrchestrator] WebSocket closed');\n          this.stopHeartbeat();\n          this.ws = null;\n          this.isConnected = false;\n          this.handleReconnect();\n        };\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  /**\n   * Connect via Server-Sent Events (SSE)\n   */\n  private async connectSSE(url: string): Promise<void> {\n    return new Promise((resolve, reject) => {\n      try {\n        const eventSource = new EventSource(url);\n\n        eventSource.onopen = () => {\n          console.log('[StreamingOrchestrator] SSE connected');\n          this.eventSource = eventSource;\n          this.isConnected = true;\n          this.reconnectAttempts = 0;\n          resolve();\n        };\n\n        eventSource.onmessage = event => {\n          try {\n            const message: AgentMessage = JSON.parse(event.data);\n            this.handleMessage(message);\n          } catch (error) {\n            console.error('[StreamingOrchestrator] Failed to parse SSE message:', error);\n          }\n        };\n\n        eventSource.onerror = error => {\n          console.error('[StreamingOrchestrator] SSE error:', error);\n          if (eventSource.readyState === EventSource.CLOSED) {\n            this.eventSource = null;\n            this.isConnected = false;\n            this.handleReconnect();\n          }\n        };\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  /**\n   * Setup Tauri event listeners (for event-based transport)\n   */\n  private setupTauriEventListeners(): void {\n    if (typeof window === 'undefined' || !window.__TAURI__) {\n      console.warn('[StreamingOrchestrator] Tauri not available');\n      return;\n    }\n\n    // Listen for agent events from Tauri backend\n    window.__TAURI__.event.listen('agent-start', (event: any) => {\n      this.handleMessage({\n        type: 'start',\n        runId: event.payload.runId || this.currentRunId || '',\n        tabId: event.payload.tabId,\n        sessionId: event.payload.sessionId,\n        timestamp: Date.now(),\n      });\n    });\n\n    window.__TAURI__.event.listen('agent-token', (event: any) => {\n      this.handleMessage({\n        type: 'step',\n        runId: event.payload.runId || this.currentRunId || '',\n        content: event.payload.content,\n        timestamp: Date.now(),\n      });\n    });\n\n    window.__TAURI__.event.listen('agent-action', (event: any) => {\n      this.handleMessage({\n        type: 'action',\n        runId: event.payload.runId || this.currentRunId || '',\n        action: event.payload.action,\n        timestamp: Date.now(),\n      });\n    });\n\n    window.__TAURI__.event.listen('agent-done', (event: any) => {\n      this.handleMessage({\n        type: 'done',\n        runId: event.payload.runId || this.currentRunId || '',\n        timestamp: Date.now(),\n      });\n    });\n\n    window.__TAURI__.event.listen('agent-error', (event: any) => {\n      this.handleMessage({\n        type: 'error',\n        runId: event.payload.runId || this.currentRunId || '',\n        content: event.payload.error,\n        timestamp: Date.now(),\n      });\n    });\n  }\n\n  /**\n   * Handle incoming message\n   */\n  private handleMessage(message: AgentMessage): void {\n    // Update agent stream store\n    const store = useAgentStreamStore.getState();\n\n    // Only process messages for current active tab\n    if (message.tabId && store.activeTabId && message.tabId !== store.activeTabId) {\n      console.log('[StreamingOrchestrator] Ignoring message for inactive tab', {\n        messageTabId: message.tabId,\n        activeTabId: store.activeTabId,\n      });\n      return;\n    }\n\n    // Convert to AgentStreamEvent\n    const event: AgentStreamEvent = {\n      id: `${message.runId}-${Date.now()}`,\n      type: message.type === 'start' ? 'start' : message.type === 'done' ? 'done' : 'step',\n      step: message.step,\n      status: message.status,\n      content: message.content,\n      timestamp: message.timestamp,\n      tabId: message.tabId,\n      sessionId: message.sessionId,\n    };\n\n    store.appendEvent(event);\n\n    if (message.content) {\n      store.appendTranscript(message.content);\n    }\n\n    // Notify listeners\n    const listeners = this.listeners.get(message.type) || new Set();\n    listeners.forEach(listener => listener(message));\n  }\n\n  /**\n   * Start agent stream\n   */\n  async startAgent(\n    query: string,\n    options?: {\n      tabId?: string | null;\n      sessionId?: string | null;\n      url?: string;\n      context?: string;\n    }\n  ): Promise<string> {\n    const runId = `run-${Date.now()}-${Math.random().toString(36).slice(2, 10)}`;\n    this.currentRunId = runId;\n\n    const store = useAgentStreamStore.getState();\n    store.setRun(runId, query, options?.tabId);\n\n    if (\n      this.config?.transport === 'websocket' &&\n      this.ws &&\n      this.ws.readyState === WebSocket.OPEN\n    ) {\n      // Send via WebSocket\n      this.ws.send(\n        JSON.stringify({\n          type: 'start_agent',\n          query,\n          tabId: options?.tabId,\n          sessionId: options?.sessionId,\n          url: options?.url,\n          context: options?.context,\n          runId,\n        })\n      );\n    } else if (\n      this.config?.transport === 'event' &&\n      typeof window !== 'undefined' &&\n      window.__TAURI__\n    ) {\n      // Invoke Tauri command\n      window.__TAURI__\n        .invoke('start_agent_stream', {\n          query,\n          tabId: options?.tabId,\n          sessionId: options?.sessionId,\n          url: options?.url,\n          context: options?.context,\n          runId,\n        })\n        .catch((error: any) => {\n          console.error('[StreamingOrchestrator] Failed to start agent:', error);\n          store.setError(error.message || 'Failed to start agent');\n        });\n    } else {\n      // Fallback: use HTTP endpoint\n      try {\n        const response = await fetch('http://127.0.0.1:4000/api/agent/stream', {\n          method: 'POST',\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify({\n            query,\n            tabId: options?.tabId,\n            sessionId: options?.sessionId,\n            url: options?.url,\n            context: options?.context,\n            runId,\n          }),\n        });\n\n        if (!response.ok) {\n          throw new Error(`HTTP ${response.status}`);\n        }\n\n        // Handle SSE stream\n        const reader = response.body?.getReader();\n        const decoder = new TextDecoder();\n\n        if (reader) {\n          (async () => {\n            while (true) {\n              const { done, value } = await reader.read();\n              if (done) break;\n\n              const chunk = decoder.decode(value);\n              const lines = chunk.split('\\n');\n\n              for (const line of lines) {\n                if (line.startsWith('data: ')) {\n                  try {\n                    const message: AgentMessage = JSON.parse(line.slice(6));\n                    this.handleMessage(message);\n                  } catch (error) {\n                    console.error('[StreamingOrchestrator] Failed to parse SSE line:', error);\n                  }\n                }\n              }\n            }\n          })();\n        }\n      } catch (error: any) {\n        console.error('[StreamingOrchestrator] Failed to start agent:', error);\n        store.setError(error.message || 'Failed to start agent');\n      }\n    }\n\n    return runId;\n  }\n\n  /**\n   * Stop agent stream\n   */\n  stopAgent(runId: string): void {\n    if (this.ws && this.ws.readyState === WebSocket.OPEN) {\n      this.ws.send(JSON.stringify({ type: 'stop_agent', runId }));\n    }\n\n    const store = useAgentStreamStore.getState();\n    store.setStatus('idle');\n  }\n\n  /**\n   * Start heartbeat (ping/pong)\n   */\n  private startHeartbeat(): void {\n    this.stopHeartbeat();\n\n    this.heartbeatInterval = setInterval(() => {\n      if (this.ws && this.ws.readyState === WebSocket.OPEN) {\n        this.ws.send(\n          JSON.stringify({\n            type: 'ping',\n            timestamp: Date.now(),\n          })\n        );\n      }\n    }, this.heartbeatIntervalMs);\n  }\n\n  /**\n   * Stop heartbeat\n   */\n  private stopHeartbeat(): void {\n    if (this.heartbeatInterval) {\n      clearInterval(this.heartbeatInterval);\n      this.heartbeatInterval = null;\n    }\n  }\n\n  /**\n   * Handle reconnection with exponential backoff\n   */\n  private handleReconnect(): void {\n    if (!this.config?.reconnect) {\n      return;\n    }\n\n    const maxAttempts = this.config.maxReconnectAttempts || 10;\n    if (this.reconnectAttempts >= maxAttempts) {\n      console.error('[StreamingOrchestrator] Max reconnect attempts reached');\n      return;\n    }\n\n    // Clear any existing reconnect timer\n    if (this.reconnectTimer) {\n      clearTimeout(this.reconnectTimer);\n    }\n\n    this.reconnectAttempts++;\n\n    // Exponential backoff: baseBackoff * 2^(attempts-1), capped at maxBackoff\n    const delay = Math.min(\n      this.maxBackoff,\n      this.baseBackoff * Math.pow(2, this.reconnectAttempts - 1)\n    );\n\n    console.log(\n      `[StreamingOrchestrator] Reconnecting in ${delay}ms (attempt ${this.reconnectAttempts}/${maxAttempts})`\n    );\n\n    this.reconnectTimer = setTimeout(() => {\n      this.reconnectTimer = null;\n      if (this.config) {\n        this.connect(this.config).catch(error => {\n          console.error('[StreamingOrchestrator] Reconnect failed:', error);\n        });\n      }\n    }, delay);\n  }\n\n  /**\n   * Add message listener\n   */\n  on(type: string, listener: (data: AgentMessage) => void): () => void {\n    if (!this.listeners.has(type)) {\n      this.listeners.set(type, new Set());\n    }\n    this.listeners.get(type)!.add(listener);\n\n    // Return unsubscribe function\n    return () => {\n      this.listeners.get(type)?.delete(listener);\n    };\n  }\n\n  /**\n   * Disconnect\n   */\n  disconnect(): void {\n    this.stopHeartbeat();\n\n    if (this.reconnectTimer) {\n      clearTimeout(this.reconnectTimer);\n      this.reconnectTimer = null;\n    }\n\n    if (this.ws) {\n      this.ws.close();\n      this.ws = null;\n    }\n    if (this.eventSource) {\n      this.eventSource.close();\n      this.eventSource = null;\n    }\n    this.isConnected = false;\n    this.listeners.clear();\n    this.seenMessageIds.clear();\n    this.reconnectAttempts = 0;\n  }\n\n  /**\n   * Check if connected\n   */\n  get connected(): boolean {\n    return this.isConnected;\n  }\n}\n\n// Singleton instance\nexport const streamingOrchestrator = new StreamingOrchestrator();\n","/**\n * Text Chunker with Progressive Summarization\n * Faster than competitor agents - partial results in 200ms-800ms\n */\n\nexport interface Chunk {\n  id: string;\n  text: string;\n  index: number;\n  startOffset: number;\n  endOffset: number;\n  wordCount: number;\n  summary?: string;\n}\n\nexport interface ChunkOptions {\n  maxChunkSize?: number;\n  overlap?: number;\n  minChunkSize?: number;\n  preserveSentences?: boolean;\n}\n\n/**\n * Chunk text into smaller pieces for processing\n */\nexport function chunkText(text: string, options: ChunkOptions = {}): Chunk[] {\n  const {\n    maxChunkSize = 1000,\n    overlap = 100,\n    minChunkSize = 100,\n    preserveSentences = true,\n  } = options;\n\n  if (text.length <= maxChunkSize) {\n    return [\n      {\n        id: `chunk-0`,\n        text,\n        index: 0,\n        startOffset: 0,\n        endOffset: text.length,\n        wordCount: text.split(/\\s+/).length,\n      },\n    ];\n  }\n\n  const chunks: Chunk[] = [];\n  let currentIndex = 0;\n  let startOffset = 0;\n\n  while (startOffset < text.length) {\n    let endOffset = Math.min(startOffset + maxChunkSize, text.length);\n\n    // If preserving sentences, try to end at sentence boundary\n    if (preserveSentences && endOffset < text.length) {\n      const sentenceEnd = findSentenceEnd(text, endOffset);\n      if (sentenceEnd > startOffset + minChunkSize) {\n        endOffset = sentenceEnd;\n      }\n    }\n\n    const chunkText = text.slice(startOffset, endOffset);\n    const wordCount = chunkText.split(/\\s+/).length;\n\n    chunks.push({\n      id: `chunk-${currentIndex}`,\n      text: chunkText,\n      index: currentIndex,\n      startOffset,\n      endOffset,\n      wordCount,\n    });\n\n    // Move start with overlap\n    startOffset = endOffset - overlap;\n    if (startOffset < 0) startOffset = 0;\n    currentIndex++;\n  }\n\n  return chunks;\n}\n\n/**\n * Find sentence end near offset\n */\nfunction findSentenceEnd(text: string, offset: number): number {\n  const sentenceEnders = /[.!?]\\s+/g;\n  let lastMatch = -1;\n  let match;\n\n  // Reset regex\n  sentenceEnders.lastIndex = 0;\n\n  while ((match = sentenceEnders.exec(text)) !== null) {\n    if (match.index > offset) {\n      return match.index + match[0].length;\n    }\n    lastMatch = match.index + match[0].length;\n  }\n\n  // If no match found after offset, use last match or return offset\n  return lastMatch > offset ? lastMatch : offset;\n}\n\n/**\n * Progressive summarization - summarize chunks incrementally\n */\nexport async function summarizeChunksProgressive(\n  chunks: Chunk[],\n  options: {\n    onProgress?: (chunk: Chunk, summary: string) => void;\n    summarizeFn?: (text: string) => Promise<string>;\n  } = {}\n): Promise<string> {\n  const { onProgress, summarizeFn = defaultSummarize } = options;\n  const summaries: string[] = [];\n\n  for (const chunk of chunks) {\n    try {\n      const summary = await summarizeFn(chunk.text);\n      chunk.summary = summary;\n      summaries.push(summary);\n\n      if (onProgress) {\n        onProgress(chunk, summary);\n      }\n\n      // Small delay to allow UI updates\n      await new Promise(resolve => setTimeout(resolve, 50));\n    } catch (error) {\n      console.error(`[Chunker] Failed to summarize chunk ${chunk.id}:`, error);\n      summaries.push(chunk.text.slice(0, 200) + '...');\n    }\n  }\n\n  return summaries.join('\\n\\n');\n}\n\n/**\n * Default summarization function (can be replaced with LLM call)\n */\nasync function defaultSummarize(text: string): Promise<string> {\n  // Simple extractive summarization (first 3 sentences)\n  const sentences = text.split(/[.!?]+\\s+/).filter(s => s.trim().length > 0);\n  return sentences.slice(0, 3).join('. ') + '.';\n}\n\n/**\n * Extract and chunk page content deterministically\n */\nexport async function extractAndChunkPage(\n  url: string,\n  options: ChunkOptions = {}\n): Promise<{ chunks: Chunk[]; metadata: { url: string; totalWords: number } }> {\n  // Use Tauri fetch for cross-origin safety\n  let text: string;\n\n  if (typeof window !== 'undefined' && window.__TAURI__) {\n    try {\n      const result = await window.__TAURI__!.invoke<{ text?: string }>('extract_page_text', {\n        url,\n      });\n      text = result?.text || '';\n    } catch (error) {\n      console.error('[Chunker] Failed to extract page:', error);\n      text = '';\n    }\n  } else {\n    // Fallback: fetch via proxy\n    try {\n      const response = await fetch(\n        `http://127.0.0.1:4000/api/extract?url=${encodeURIComponent(url)}`\n      );\n      const data = await response.json();\n      text = data.text || '';\n    } catch (error) {\n      console.error('[Chunker] Failed to extract page:', error);\n      text = '';\n    }\n  }\n\n  if (!text || text.trim().length === 0) {\n    return {\n      chunks: [],\n      metadata: { url, totalWords: 0 },\n    };\n  }\n\n  const chunks = chunkText(text, options);\n  const totalWords = text.split(/\\s+/).length;\n\n  return {\n    chunks,\n    metadata: { url, totalWords },\n  };\n}\n\n/**\n * Fast partial summary (200-800ms target)\n */\nexport async function getPartialSummary(chunks: Chunk[], maxChunks: number = 3): Promise<string> {\n  const chunksToSummarize = chunks.slice(0, maxChunks);\n  const summaries: string[] = [];\n\n  // Process in parallel for speed\n  const summaryPromises = chunksToSummarize.map(async chunk => {\n    try {\n      // Use simple extractive summarization for speed\n      const sentences = chunk.text.split(/[.!?]+\\s+/).filter(s => s.trim().length > 0);\n      return sentences.slice(0, 2).join('. ') + '.';\n    } catch {\n      return chunk.text.slice(0, 200) + '...';\n    }\n  });\n\n  const results = await Promise.all(summaryPromises);\n  summaries.push(...results);\n\n  return summaries.join('\\n\\n');\n}\n","/**\n * Local Cache & Queue System\n * Enables offline agent support and deterministic operations\n */\n\nexport interface CacheEntry<T = unknown> {\n  key: string;\n  value: T;\n  timestamp: number;\n  expiresAt?: number;\n  tags?: string[];\n}\n\nexport interface QueueItem<T = unknown> {\n  id: string;\n  type: string;\n  data: T;\n  priority: number;\n  createdAt: number;\n  attempts: number;\n  maxAttempts: number;\n}\n\nclass LocalCache {\n  private cache: Map<string, CacheEntry> = new Map();\n  private queue: QueueItem[] = [];\n  private maxCacheSize: number;\n  private maxQueueSize: number;\n  private db: IDBDatabase | null = null;\n\n  constructor(maxCacheSize = 1000, maxQueueSize = 100) {\n    this.maxCacheSize = maxCacheSize;\n    this.maxQueueSize = maxQueueSize;\n    this.initDB();\n  }\n\n  /**\n   * Initialize IndexedDB for persistent cache\n   */\n  private async initDB(): Promise<void> {\n    return new Promise((resolve, _reject) => {\n      const request = indexedDB.open('regen-cache', 1);\n\n      request.onerror = () => {\n        console.warn('[LocalCache] IndexedDB not available, using memory cache');\n        resolve();\n        // reject intentionally unused - we fallback to memory cache\n      };\n\n      request.onsuccess = () => {\n        this.db = request.result;\n        this.loadFromDB();\n        resolve();\n      };\n\n      request.onupgradeneeded = event => {\n        const db = (event.target as IDBOpenDBRequest).result;\n\n        if (!db.objectStoreNames.contains('cache')) {\n          db.createObjectStore('cache', { keyPath: 'key' });\n        }\n\n        if (!db.objectStoreNames.contains('queue')) {\n          const queueStore = db.createObjectStore('queue', { keyPath: 'id' });\n          queueStore.createIndex('priority', 'priority', { unique: false });\n          queueStore.createIndex('createdAt', 'createdAt', { unique: false });\n        }\n      };\n    });\n  }\n\n  /**\n   * Load cache from IndexedDB\n   */\n  private async loadFromDB(): Promise<void> {\n    if (!this.db) return;\n\n    try {\n      const cacheTx = this.db.transaction('cache', 'readonly');\n      const cacheStore = cacheTx.objectStore('cache');\n      const cacheRequest = cacheStore.getAll();\n\n      cacheRequest.onsuccess = () => {\n        const entries = cacheRequest.result as CacheEntry[];\n        for (const entry of entries) {\n          // Check expiration\n          if (entry.expiresAt && entry.expiresAt < Date.now()) {\n            continue;\n          }\n          this.cache.set(entry.key, entry);\n        }\n      };\n\n      const queueTx = this.db.transaction('queue', 'readonly');\n      const queueStore = queueTx.objectStore('queue');\n      const queueRequest = queueStore.getAll();\n\n      queueRequest.onsuccess = () => {\n        const items = queueRequest.result as QueueItem[];\n        this.queue = items.sort((a, b) => b.priority - a.priority);\n      };\n    } catch (error) {\n      console.error('[LocalCache] Failed to load from DB:', error);\n    }\n  }\n\n  /**\n   * Get value from cache\n   */\n  async get<T = unknown>(key: string): Promise<T | null> {\n    // Check memory cache first\n    const entry = this.cache.get(key);\n    if (entry) {\n      // Check expiration\n      if (entry.expiresAt && entry.expiresAt < Date.now()) {\n        this.cache.delete(key);\n        await this.deleteFromDB(key);\n        return null;\n      }\n      return entry.value as T;\n    }\n\n    // Check IndexedDB\n    if (this.db) {\n      try {\n        const tx = this.db.transaction('cache', 'readonly');\n        const store = tx.objectStore('cache');\n        const request = store.get(key);\n\n        return new Promise(resolve => {\n          request.onsuccess = () => {\n            const entry = request.result as CacheEntry<T> | undefined;\n            if (entry) {\n              // Check expiration\n              if (entry.expiresAt && entry.expiresAt < Date.now()) {\n                this.deleteFromDB(key);\n                resolve(null);\n                return;\n              }\n              // Add to memory cache\n              this.cache.set(key, entry);\n              resolve(entry.value);\n            } else {\n              resolve(null);\n            }\n          };\n          request.onerror = () => resolve(null);\n        });\n      } catch (error) {\n        console.error('[LocalCache] Failed to get from DB:', error);\n        return null;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Set value in cache\n   */\n  async set<T = unknown>(\n    key: string,\n    value: T,\n    options?: { ttl?: number; tags?: string[] }\n  ): Promise<void> {\n    const entry: CacheEntry<T> = {\n      key,\n      value,\n      timestamp: Date.now(),\n      expiresAt: options?.ttl ? Date.now() + options.ttl * 1000 : undefined,\n      tags: options?.tags,\n    };\n\n    // Add to memory cache\n    this.cache.set(key, entry);\n\n    // Enforce max size\n    if (this.cache.size > this.maxCacheSize) {\n      // Remove oldest entry\n      const oldestKey = Array.from(this.cache.entries()).sort(\n        (a, b) => a[1].timestamp - b[1].timestamp\n      )[0][0];\n      this.cache.delete(oldestKey);\n      await this.deleteFromDB(oldestKey);\n    }\n\n    // Save to IndexedDB\n    if (this.db) {\n      try {\n        const tx = this.db.transaction('cache', 'readwrite');\n        const store = tx.objectStore('cache');\n        store.put(entry);\n      } catch (error) {\n        console.error('[LocalCache] Failed to save to DB:', error);\n      }\n    }\n  }\n\n  /**\n   * Delete from cache\n   */\n  async delete(key: string): Promise<void> {\n    this.cache.delete(key);\n    await this.deleteFromDB(key);\n  }\n\n  /**\n   * Delete from IndexedDB\n   */\n  private async deleteFromDB(key: string): Promise<void> {\n    if (!this.db) return;\n\n    try {\n      const tx = this.db.transaction('cache', 'readwrite');\n      const store = tx.objectStore('cache');\n      store.delete(key);\n    } catch (error) {\n      console.error('[LocalCache] Failed to delete from DB:', error);\n    }\n  }\n\n  /**\n   * Clear cache by tags\n   */\n  async clearByTags(tags: string[]): Promise<void> {\n    const keysToDelete: string[] = [];\n\n    for (const [key, entry] of this.cache.entries()) {\n      if (entry.tags && entry.tags.some(tag => tags.includes(tag))) {\n        keysToDelete.push(key);\n      }\n    }\n\n    for (const key of keysToDelete) {\n      await this.delete(key);\n    }\n  }\n\n  /**\n   * Add item to queue\n   */\n  async enqueue<T = unknown>(\n    type: string,\n    data: T,\n    options?: { priority?: number; maxAttempts?: number }\n  ): Promise<string> {\n    const item: QueueItem<T> = {\n      id: `queue-${Date.now()}-${Math.random().toString(36).slice(2, 10)}`,\n      type,\n      data,\n      priority: options?.priority ?? 0,\n      createdAt: Date.now(),\n      attempts: 0,\n      maxAttempts: options?.maxAttempts ?? 3,\n    };\n\n    this.queue.push(item);\n    this.queue.sort((a, b) => b.priority - a.priority);\n\n    // Enforce max size\n    if (this.queue.length > this.maxQueueSize) {\n      this.queue = this.queue.slice(0, this.maxQueueSize);\n    }\n\n    // Save to IndexedDB\n    if (this.db) {\n      try {\n        const tx = this.db.transaction('queue', 'readwrite');\n        const store = tx.objectStore('queue');\n        store.put(item);\n      } catch (error) {\n        console.error('[LocalCache] Failed to save queue item to DB:', error);\n      }\n    }\n\n    return item.id;\n  }\n\n  /**\n   * Get next item from queue\n   */\n  async dequeue<T = unknown>(): Promise<QueueItem<T> | null> {\n    if (this.queue.length === 0) {\n      return null;\n    }\n\n    const item = this.queue.shift() as QueueItem<T>;\n\n    // Delete from IndexedDB\n    if (this.db) {\n      try {\n        const tx = this.db.transaction('queue', 'readwrite');\n        const store = tx.objectStore('queue');\n        store.delete(item.id);\n      } catch (error) {\n        console.error('[LocalCache] Failed to delete queue item from DB:', error);\n      }\n    }\n\n    return item;\n  }\n\n  /**\n   * Peek at next item without removing\n   */\n  peek<T = unknown>(): QueueItem<T> | null {\n    return (this.queue[0] as QueueItem<T>) || null;\n  }\n\n  /**\n   * Get queue length\n   */\n  get queueLength(): number {\n    return this.queue.length;\n  }\n\n  /**\n   * Clear queue\n   */\n  async clearQueue(): Promise<void> {\n    this.queue = [];\n\n    if (this.db) {\n      try {\n        const tx = this.db.transaction('queue', 'readwrite');\n        const store = tx.objectStore('queue');\n        store.clear();\n      } catch (error) {\n        console.error('[LocalCache] Failed to clear queue from DB:', error);\n      }\n    }\n  }\n\n  /**\n   * Get cache stats\n   */\n  getStats(): { cacheSize: number; queueSize: number; memoryUsage: number } {\n    let memoryUsage = 0;\n    for (const entry of this.cache.values()) {\n      memoryUsage += JSON.stringify(entry).length;\n    }\n\n    return {\n      cacheSize: this.cache.size,\n      queueSize: this.queue.length,\n      memoryUsage,\n    };\n  }\n}\n\n// Singleton instance\nexport const localCache = new LocalCache();\n","/**\n * Multi-Agent Layered System\n * Specialized agents for Trade, Research, Dev, Document, and Workflow modes\n */\n\nimport { streamingOrchestrator } from '../streaming/orchestrator';\nimport { type Action, type ActionType } from '../actions/safeExecutor';\nimport { extractAndChunkPage, getPartialSummary } from '../extraction/chunker';\nimport { localCache } from '../cache/localCache';\n\nexport type AgentMode = 'trade' | 'research' | 'dev' | 'document' | 'workflow';\n\nexport interface AgentContext {\n  mode: AgentMode;\n  tabId?: string | null;\n  sessionId?: string | null;\n  url?: string;\n  metadata?: Record<string, unknown>;\n}\n\nexport interface AgentResult {\n  success: boolean;\n  data?: unknown;\n  actions?: Action[];\n  error?: string;\n  runId?: string;\n}\n\n/**\n * Base Agent Class\n */\nabstract class BaseAgent {\n  protected mode: AgentMode;\n  protected context: AgentContext;\n\n  constructor(mode: AgentMode, context: AgentContext) {\n    this.mode = mode;\n    this.context = context;\n  }\n\n  abstract execute(query: string): Promise<AgentResult>;\n  abstract getCapabilities(): string[];\n}\n\n/**\n * Trade Agent - Specialized for trading operations\n */\nexport class TradeAgent extends BaseAgent {\n  constructor(context: AgentContext) {\n    super('trade', context);\n  }\n\n  getCapabilities(): string[] {\n    return [\n      'Real-time market data analysis',\n      'Trade signal generation',\n      'Portfolio optimization',\n      'Risk assessment',\n      'Order execution',\n    ];\n  }\n\n  async execute(query: string): Promise<AgentResult> {\n    const runId = await streamingOrchestrator.startAgent(query, {\n      tabId: this.context.tabId,\n      sessionId: this.context.sessionId,\n      url: this.context.url,\n      context: JSON.stringify({\n        mode: 'trade',\n        capabilities: this.getCapabilities(),\n      }),\n    });\n\n    // Trade-specific processing\n    const actions: Action[] = [];\n\n    // Analyze query for trade intent\n    if (query.toLowerCase().includes('buy') || query.toLowerCase().includes('sell')) {\n      actions.push({\n        type: 'navigate',\n        args: {\n          url: 'https://www.tradingview.com/chart/',\n        },\n        requiresConsent: true,\n        risk: 'high',\n      });\n    }\n\n    // Get market data if requested\n    if (query.toLowerCase().includes('price') || query.toLowerCase().includes('market')) {\n      // Cache market data\n      const cacheKey = `trade:market:${Date.now()}`;\n      const cached = await localCache.get(cacheKey);\n      if (!cached) {\n        // Fetch and cache market data\n        actions.push({\n          type: 'extract',\n          args: {\n            selector: '.market-data',\n            url: this.context.url,\n          },\n          requiresConsent: false,\n          risk: 'low',\n        });\n      }\n    }\n\n    return {\n      success: true,\n      runId,\n      actions,\n    };\n  }\n}\n\n/**\n * Research Agent - Multi-source research with LLM\n */\nexport class ResearchAgent extends BaseAgent {\n  constructor(context: AgentContext) {\n    super('research', context);\n  }\n\n  getCapabilities(): string[] {\n    return [\n      'Multi-source search',\n      'Content extraction',\n      'Progressive summarization',\n      'Citation tracking',\n      'Fact verification',\n      'Cross-reference analysis',\n    ];\n  }\n\n  async execute(query: string): Promise<AgentResult> {\n    const runId = await streamingOrchestrator.startAgent(query, {\n      tabId: this.context.tabId,\n      sessionId: this.context.sessionId,\n      url: this.context.url,\n      context: JSON.stringify({\n        mode: 'research',\n        capabilities: this.getCapabilities(),\n      }),\n    });\n\n    const actions: Action[] = [];\n\n    // Extract and chunk page if URL provided\n    if (this.context.url) {\n      try {\n        const { chunks, metadata } = await extractAndChunkPage(this.context.url);\n\n        // Get fast partial summary\n        const partialSummary = await getPartialSummary(chunks, 3);\n\n        // Cache results\n        await localCache.set(\n          `research:${this.context.url}`,\n          {\n            chunks,\n            metadata,\n            partialSummary,\n          },\n          {\n            ttl: 3600,\n            tags: ['research', 'extraction'],\n          }\n        );\n\n        actions.push({\n          type: 'summarize',\n          args: {\n            text: partialSummary,\n            url: this.context.url,\n          },\n          requiresConsent: false,\n          risk: 'low',\n        });\n      } catch (error: any) {\n        console.error('[ResearchAgent] Extraction failed:', error);\n      }\n    }\n\n    // Multi-source search\n    actions.push({\n      type: 'extract',\n      args: {\n        query,\n        sources: ['web', 'local', 'cache'],\n      },\n      requiresConsent: false,\n      risk: 'low',\n    });\n\n    return {\n      success: true,\n      runId,\n      actions,\n    };\n  }\n}\n\n/**\n * Dev Agent - Auto-debug and code extraction\n */\nexport class DevAgent extends BaseAgent {\n  constructor(context: AgentContext) {\n    super('dev', context);\n  }\n\n  getCapabilities(): string[] {\n    return [\n      'Code extraction',\n      'Auto-debugging',\n      'Error analysis',\n      'Performance profiling',\n      'Code review',\n      'Documentation generation',\n    ];\n  }\n\n  async execute(query: string): Promise<AgentResult> {\n    const runId = await streamingOrchestrator.startAgent(query, {\n      tabId: this.context.tabId,\n      sessionId: this.context.sessionId,\n      url: this.context.url,\n      context: JSON.stringify({\n        mode: 'dev',\n        capabilities: this.getCapabilities(),\n      }),\n    });\n\n    const actions: Action[] = [];\n\n    // Extract code if URL is a code repository or file\n    if (\n      this.context.url &&\n      (this.context.url.includes('github.com') || this.context.url.includes('gitlab.com'))\n    ) {\n      actions.push({\n        type: 'extract',\n        args: {\n          selector: 'pre, code, .code-block',\n          url: this.context.url,\n        },\n        requiresConsent: false,\n        risk: 'low',\n      });\n    }\n\n    // Debug analysis\n    if (query.toLowerCase().includes('error') || query.toLowerCase().includes('debug')) {\n      actions.push({\n        type: 'extract',\n        args: {\n          selector: '.error, .console, .log',\n          url: this.context.url,\n        },\n        requiresConsent: false,\n        risk: 'low',\n      });\n    }\n\n    return {\n      success: true,\n      runId,\n      actions,\n    };\n  }\n}\n\n/**\n * Document Agent - PDF/Doc insights and actions\n */\nexport class DocumentAgent extends BaseAgent {\n  constructor(context: AgentContext) {\n    super('document', context);\n  }\n\n  getCapabilities(): string[] {\n    return [\n      'PDF parsing',\n      'Document summarization',\n      'Key insight extraction',\n      'Table extraction',\n      'Action item identification',\n      'Document comparison',\n    ];\n  }\n\n  async execute(query: string): Promise<AgentResult> {\n    const runId = await streamingOrchestrator.startAgent(query, {\n      tabId: this.context.tabId,\n      sessionId: this.context.sessionId,\n      url: this.context.url,\n      context: JSON.stringify({\n        mode: 'document',\n        capabilities: this.getCapabilities(),\n      }),\n    });\n\n    const actions: Action[] = [];\n\n    // Check if URL is a document\n    if (\n      this.context.url &&\n      (this.context.url.endsWith('.pdf') ||\n        this.context.url.endsWith('.doc') ||\n        this.context.url.endsWith('.docx'))\n    ) {\n      actions.push({\n        type: 'extract',\n        args: {\n          url: this.context.url,\n          type: 'document',\n        },\n        requiresConsent: false,\n        risk: 'low',\n      });\n    }\n\n    // Extract insights\n    actions.push({\n      type: 'summarize',\n      args: {\n        query,\n        documentUrl: this.context.url,\n      },\n      requiresConsent: false,\n      risk: 'low',\n    });\n\n    return {\n      success: true,\n      runId,\n      actions,\n    };\n  }\n}\n\n/**\n * Workflow Agent - Arc-like automated workflows\n */\nexport class WorkflowAgent extends BaseAgent {\n  constructor(context: AgentContext) {\n    super('workflow', context);\n  }\n\n  getCapabilities(): string[] {\n    return [\n      'Multi-step automation',\n      'Workflow orchestration',\n      'Conditional logic',\n      'Error recovery',\n      'Progress tracking',\n      'Workflow templates',\n    ];\n  }\n\n  async execute(query: string): Promise<AgentResult> {\n    const runId = await streamingOrchestrator.startAgent(query, {\n      tabId: this.context.tabId,\n      sessionId: this.context.sessionId,\n      url: this.context.url,\n      context: JSON.stringify({\n        mode: 'workflow',\n        capabilities: this.getCapabilities(),\n      }),\n    });\n\n    // Parse workflow from query\n    const workflow = this.parseWorkflow(query);\n    const actions: Action[] = [];\n\n    // Execute workflow steps\n    for (const step of workflow.steps) {\n      actions.push({\n        type: step.type as ActionType,\n        args: step.args,\n        requiresConsent: step.requiresConsent || false,\n        risk: step.risk || 'low',\n      });\n    }\n\n    return {\n      success: true,\n      runId,\n      actions,\n    };\n  }\n\n  private parseWorkflow(query: string): {\n    steps: Array<{\n      type: string;\n      args: Record<string, unknown>;\n      requiresConsent?: boolean;\n      risk?: 'low' | 'medium' | 'high';\n    }>;\n  } {\n    // Simple workflow parser (can be enhanced with LLM)\n    const steps: Array<{\n      type: string;\n      args: Record<string, unknown>;\n      requiresConsent?: boolean;\n      risk?: 'low' | 'medium' | 'high';\n    }> = [];\n\n    // Example: \"Open example.com, extract content, summarize\"\n    if (query.includes('open') && query.includes('extract')) {\n      const urlMatch = query.match(/https?:\\/\\/[^\\s]+/);\n      if (urlMatch) {\n        steps.push({\n          type: 'navigate',\n          args: { url: urlMatch[0] },\n          requiresConsent: false,\n          risk: 'low',\n        });\n        steps.push({\n          type: 'extract',\n          args: { url: urlMatch[0] },\n          requiresConsent: false,\n          risk: 'low',\n        });\n        steps.push({\n          type: 'summarize',\n          args: { url: urlMatch[0] },\n          requiresConsent: false,\n          risk: 'low',\n        });\n      }\n    }\n\n    return { steps };\n  }\n}\n\n/**\n * Multi-Agent System Manager\n */\nclass MultiAgentSystem {\n  private agents: Map<AgentMode, BaseAgent> = new Map();\n\n  /**\n   * Get or create agent for mode\n   */\n  getAgent(mode: AgentMode, context: AgentContext): BaseAgent {\n    if (!this.agents.has(mode)) {\n      let agent: BaseAgent;\n\n      switch (mode) {\n        case 'trade':\n          agent = new TradeAgent(context);\n          break;\n        case 'research':\n          agent = new ResearchAgent(context);\n          break;\n        case 'dev':\n          agent = new DevAgent(context);\n          break;\n        case 'document':\n          agent = new DocumentAgent(context);\n          break;\n        case 'workflow':\n          agent = new WorkflowAgent(context);\n          break;\n        default:\n          agent = new ResearchAgent(context); // Default fallback\n      }\n\n      this.agents.set(mode, agent);\n    }\n\n    return this.agents.get(mode)!;\n  }\n\n  /**\n   * Execute query with appropriate agent\n   */\n  async execute(mode: AgentMode, query: string, context: AgentContext): Promise<AgentResult> {\n    const agent = this.getAgent(mode, context);\n    return await agent.execute(query);\n  }\n\n  /**\n   * Get agent capabilities\n   */\n  getCapabilities(mode: AgentMode, context: AgentContext): string[] {\n    const agent = this.getAgent(mode, context);\n    return agent.getCapabilities();\n  }\n\n  /**\n   * Execute batch with multiple agents\n   */\n  async executeBatch(\n    tasks: Array<{ mode: AgentMode; query: string; context: AgentContext }>\n  ): Promise<AgentResult[]> {\n    const results = await Promise.all(\n      tasks.map(task => this.execute(task.mode, task.query, task.context))\n    );\n    return results;\n  }\n}\n\n// Singleton instance\nexport const multiAgentSystem = new MultiAgentSystem();\n","/**\n * Lightweight nanoid-style generator (no dependency).\n */\nconst alphabet = '0123456789abcdefghijklmnopqrstuvwxyz';\n\nexport function nanoid(length: number = 16): string {\n  let id = '';\n  for (let i = 0; i < length; i++) {\n    const idx = Math.floor(Math.random() * alphabet.length);\n    id += alphabet[idx];\n  }\n  return id;\n}\n","import { semanticSearchMemories } from '../supermemory/search';\nimport { processMemoryEvent } from '../supermemory/pipeline';\nimport type { AgentTool } from './types';\nimport { dispatch } from '../redix/runtime';\nimport { aiEngine } from '../ai';\n\nasync function defaultRedixAsk(prompt: string): Promise<string> {\n  // First attempt via Sprint 2 AI orchestrator\n  try {\n    const result = await aiEngine.runTask({ kind: 'agent', prompt });\n    if (result.text?.trim()) {\n      return result.text;\n    }\n  } catch (error) {\n    console.warn('[AgentTools] aiEngine redixAsk fallback triggered:', error);\n  }\n\n  // Fallback to legacy Redix dispatch\n  try {\n    const response = await dispatch({\n      type: 'redix:agent:query',\n      payload: { prompt },\n      source: 'agent-runtime',\n    });\n    return (response as any)?.payload?.text || '';\n  } catch (error) {\n    console.warn('[AgentTools] legacy redixAsk failed:', error);\n    return '';\n  }\n}\n\nasync function defaultFetch(url: string, init?: RequestInit) {\n  const safeUrl = new URL(url);\n  if (!['http:', 'https:'].includes(safeUrl.protocol)) {\n    throw new Error('Only http/https allowed');\n  }\n  const controller = new AbortController();\n  const timeout = setTimeout(() => controller.abort(), 12_000);\n  try {\n    const res = await fetch(safeUrl.toString(), {\n      ...init,\n      signal: controller.signal,\n      headers: {\n        'User-Agent': 'RedixAgent/1.0',\n        ...(init?.headers || {}),\n      },\n    });\n    return res;\n  } finally {\n    clearTimeout(timeout);\n  }\n}\n\nexport const agentTools: Record<string, AgentTool> = {\n  'memory.search': {\n    id: 'memory.search',\n    description: 'Search personal SuperMemory for relevant context.',\n    requiredCapabilities: ['memory:read'],\n    async run(input, _ctx) {\n      const query = String(input.query || input.prompt || '');\n      if (!query) return [];\n      const results = await semanticSearchMemories(query, { limit: Number(input.limit) || 8 });\n      return results.map(result => ({\n        id: result.event.id,\n        similarity: result.similarity,\n        title: result.event.metadata?.title,\n        url: result.event.metadata?.url,\n        tags: result.event.metadata?.tags,\n        snippet: result.chunkText,\n      }));\n    },\n  },\n  'memory.saveNote': {\n    id: 'memory.saveNote',\n    description: 'Save a note to SuperMemory',\n    requiredCapabilities: ['memory:write'],\n    async run(input, _ctx) {\n      const value = String(input.title || input.prompt || input.text || '');\n      if (!value) throw new Error('Note text required');\n      const eventId = await processMemoryEvent({\n        type: 'note',\n        value,\n        metadata: {\n          url: input.url ? String(input.url) : undefined,\n          notePreview: String(input.text || value).slice(0, 280),\n          tags: Array.isArray(input.tags) ? input.tags.map(String) : undefined,\n        },\n      }).then(res => res.eventId);\n      return { eventId };\n    },\n  },\n  'redix.ask': {\n    id: 'redix.ask',\n    description: 'Ask the Redix core workflow for an answer.',\n    requiredCapabilities: ['redix:ask'],\n    async run(input, ctx) {\n      const prompt = String(input.prompt || input.query || '');\n      if (!prompt) return '';\n      const answer = await (ctx?.redixAsk ? ctx.redixAsk(prompt) : defaultRedixAsk(prompt));\n      return answer;\n    },\n  },\n  'web.fetch': {\n    id: 'web.fetch',\n    description: 'Make a safe HTTP GET request for public data.',\n    requiredCapabilities: ['web:fetch'],\n    async run(input, ctx) {\n      const url = String(input.url);\n      const response = await (ctx.safeFetch || defaultFetch)(url);\n      const text = await response.text();\n      const headerPairs: Array<[string, string]> = [];\n      response.headers.forEach((value: string, key: string) => {\n        headerPairs.push([key, value]);\n      });\n      return {\n        status: response.status,\n        headers: Object.fromEntries(headerPairs),\n        text,\n      };\n    },\n  },\n  'trade.fetchQuote': {\n    id: 'trade.fetchQuote',\n    description: 'Fetch real-time stock quote data for a symbol (e.g., AAPL, TSLA).',\n    requiredCapabilities: ['web:fetch'],\n    async run(input, _ctx) {\n      const symbol = String(input.symbol || '').toUpperCase();\n      if (!symbol) throw new Error('Stock symbol required');\n\n      try {\n        const { fetchTradeQuote } = await import('../trade/dataService');\n        const quote = await fetchTradeQuote(symbol);\n        return {\n          symbol: quote.symbol,\n          price: quote.price,\n          change: quote.change,\n          changePercent: quote.changePercent,\n          volume: quote.volume,\n          sentiment: quote.sentiment,\n          updatedAt: quote.updatedAt,\n        };\n      } catch (error) {\n        console.warn('[AgentTools] trade.fetchQuote failed:', error);\n        throw new Error(\n          `Failed to fetch quote for ${symbol}: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    },\n  },\n  'image.search': {\n    id: 'image.search',\n    description: 'Search for images based on a query. Returns image URLs and metadata.',\n    requiredCapabilities: ['web:fetch'],\n    async run(input, _ctx) {\n      const query = String(input.query || input.prompt || '');\n      if (!query) throw new Error('Image search query required');\n\n      // For now, use a mock/placeholder implementation\n      // In production, this would call an image search API\n      try {\n        const { MockImageEngine } = await import('../../modes/images/engines');\n        const engine = new MockImageEngine();\n        const imageUrls = engine.generate(query);\n        return {\n          query,\n          images: imageUrls.map((url, idx) => ({\n            url,\n            index: idx,\n            thumbnail: url,\n          })),\n          count: imageUrls.length,\n        };\n      } catch (error) {\n        console.warn('[AgentTools] image.search failed:', error);\n        return {\n          query,\n          images: [],\n          count: 0,\n          error: error instanceof Error ? error.message : String(error),\n        };\n      }\n    },\n  },\n  'threat.scan': {\n    id: 'threat.scan',\n    description: 'Scan a URL for security threats, vulnerabilities, and malware indicators.',\n    requiredCapabilities: ['web:fetch'],\n    async run(input, ctx) {\n      const url = String(input.url || '');\n      if (!url) throw new Error('URL required for threat scan');\n\n      try {\n        // Try IPC threat scan if available\n        const scanResult = await (window as any).api?.threats?.scanUrl?.(url);\n        if (scanResult) {\n          return scanResult;\n        }\n\n        // Fallback: Basic security check via fetch\n        try {\n          const response = await ((ctx as any).safeFetch || defaultFetch)(url, {\n            method: 'HEAD',\n          });\n\n          return {\n            url,\n            riskLevel: response.status >= 400 ? 'high' : 'medium',\n            threats: [\n              {\n                type: 'HTTP Status Check',\n                severity: response.status >= 400 ? 'high' : 'low',\n                description: `HTTP status: ${response.status}`,\n                recommendation:\n                  response.status >= 400 ? 'URL returned an error status' : 'URL is accessible',\n              },\n            ],\n            scannedAt: Date.now(),\n          };\n        } catch {\n          return {\n            url,\n            riskLevel: 'high',\n            threats: [\n              {\n                type: 'Connection Error',\n                severity: 'high',\n                description: 'Failed to connect to URL',\n                recommendation: 'URL may be unreachable or blocked',\n              },\n            ],\n            scannedAt: Date.now(),\n          };\n        }\n      } catch (error) {\n        console.warn('[AgentTools] threat.scan failed:', error);\n        throw new Error(\n          `Threat scan failed: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    },\n  },\n  'graph.query': {\n    id: 'graph.query',\n    description: 'Query the knowledge graph for nodes, edges, and relationships.',\n    requiredCapabilities: ['memory:read'],\n    async run(input, _ctx) {\n      const query = String(input.query || input.prompt || '');\n      if (!query) throw new Error('Graph query required');\n\n      try {\n        // Search SuperMemory for related content\n        const memoryResults = await semanticSearchMemories(query, { limit: 10 });\n\n        // Try to get graph data from IPC if available\n        const graphData = await (window as any).api?.graph?.all?.();\n\n        // Build graph nodes from memory results\n        const nodes = memoryResults.map(result => ({\n          key: result.event.id,\n          title: result.event.metadata?.title || result.event.value?.slice(0, 50),\n          type: result.event.type,\n          similarity: result.similarity,\n        }));\n\n        // Build edges from relationships (simplified)\n        const edges: Array<{ src: string; dst: string; rel?: string }> = [];\n        for (let i = 0; i < nodes.length - 1; i++) {\n          if (nodes[i].similarity && nodes[i + 1].similarity && nodes[i].similarity > 0.7) {\n            edges.push({\n              src: nodes[i].key,\n              dst: nodes[i + 1].key,\n              rel: 'related',\n            });\n          }\n        }\n\n        return {\n          query,\n          nodes: graphData?.nodes || nodes,\n          edges: graphData?.edges || edges,\n          nodeCount: (graphData?.nodes || nodes).length,\n          edgeCount: (graphData?.edges || edges).length,\n        };\n      } catch (error) {\n        console.warn('[AgentTools] graph.query failed:', error);\n        return {\n          query,\n          nodes: [],\n          edges: [],\n          nodeCount: 0,\n          edgeCount: 0,\n          error: error instanceof Error ? error.message : String(error),\n        };\n      }\n    },\n  },\n  'doc.summarize': {\n    id: 'doc.summarize',\n    description: 'Summarize a document or text content. Extracts key points and main ideas.',\n    requiredCapabilities: ['redix:ask'],\n    async run(input, ctx) {\n      const text = String(input.text || input.content || '');\n      const url = input.url ? String(input.url) : undefined;\n\n      if (!text && !url) throw new Error('Text content or URL required');\n\n      try {\n        let content = text;\n\n        // If URL provided, fetch content\n        if (url && !text) {\n          const response = await ((ctx as any).safeFetch || defaultFetch)(url);\n          content = await response.text();\n        }\n\n        // Use Redix to summarize\n        const summaryPrompt = `Summarize the following document. Provide:\n1. Key points (3-5 bullet points)\n2. Main ideas\n3. Important details\n\nDocument:\n${content.slice(0, 4000)}`; // Limit to 4000 chars\n\n        const summary = await ((ctx as any).redixAsk\n          ? (ctx as any).redixAsk(summaryPrompt)\n          : defaultRedixAsk(summaryPrompt));\n\n        return {\n          summary,\n          keyPoints: summary\n            .split('\\n')\n            .filter((line: string) => line.trim().startsWith('-') || line.trim().startsWith('')),\n          wordCount: content.split(/\\s+/).length,\n          url,\n        };\n      } catch (error) {\n        console.warn('[AgentTools] doc.summarize failed:', error);\n        throw new Error(\n          `Document summarization failed: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    },\n  },\n  'n8n.workflow': {\n    id: 'n8n.workflow',\n    description: 'Call an n8n workflow via webhook. Supports single calls and loops.',\n    requiredCapabilities: ['web:fetch'],\n    async run(input, _ctx) {\n      const workflowId = String(input.workflowId || '');\n      if (!workflowId) throw new Error('Workflow ID is required');\n\n      try {\n        const { callN8nWorkflow, runN8nWorkflowLoop } = await import('../../services/n8nService');\n\n        const call = {\n          workflowId,\n          data: (input.data as Record<string, unknown>) || {},\n          language: input.language ? String(input.language) : undefined,\n          sourceMode: input.sourceMode ? String(input.sourceMode) : undefined,\n          metadata: (input.metadata as Record<string, unknown>) || {},\n        };\n\n        // Check if this is a loop request\n        const isLoop = Boolean(input.loop);\n        const loopInterval = input.loopInterval ? Number(input.loopInterval) : undefined;\n        const maxIterations = input.maxIterations ? Number(input.maxIterations) : undefined;\n\n        if (isLoop) {\n          // Run workflow in loop\n          const results = await runN8nWorkflowLoop(call, {\n            workflowId,\n            interval: loopInterval,\n            maxIterations: maxIterations || 10,\n            condition: input.loopCondition\n              ? result => {\n                  // Simple condition: continue if successful\n                  // Can be enhanced with custom condition logic\n                  return result.success;\n                }\n              : undefined,\n          });\n\n          return {\n            workflowId,\n            loop: true,\n            iterations: results.length,\n            results: results.map(r => ({\n              success: r.success,\n              data: r.data,\n              error: r.error,\n            })),\n            lastResult: results[results.length - 1],\n          };\n        } else {\n          // Single workflow call\n          const result = await callN8nWorkflow(call);\n          return {\n            workflowId,\n            success: result.success,\n            data: result.data,\n            executionId: result.executionId,\n            error: result.error,\n          };\n        }\n      } catch (error) {\n        console.warn('[AgentTools] n8n.workflow failed:', error);\n        throw new Error(\n          `n8n workflow call failed: ${error instanceof Error ? error.message : String(error)}`\n        );\n      }\n    },\n  },\n  'n8n.list': {\n    id: 'n8n.list',\n    description: 'List available n8n workflows (requires API key).',\n    requiredCapabilities: ['web:fetch'],\n    async run(_input, _ctx) {\n      try {\n        const { listN8nWorkflows } = await import('../../services/n8nService');\n        const workflows = await listN8nWorkflows();\n        return {\n          workflows: workflows.map(w => ({\n            id: w.id,\n            name: w.name,\n            description: w.description,\n          })),\n          count: workflows.length,\n        };\n      } catch (error) {\n        console.warn('[AgentTools] n8n.list failed:', error);\n        return {\n          workflows: [],\n          count: 0,\n          error: error instanceof Error ? error.message : String(error),\n        };\n      }\n    },\n  },\n};\n","import { nanoid } from '../utils/nanoid';\nimport { dispatch } from '../redix/runtime';\nimport { agentTools } from './tools';\nimport { MemoryStoreInstance } from '../supermemory/store';\nimport { useAgentMemoryStore } from '../../state/agentMemoryStore';\nimport type {\n  AgentConfig,\n  AgentExecutionInput,\n  AgentExecutionResult,\n  AgentRunRecord,\n  AgentEnvironment,\n  AgentToolExecutor,\n  AgentToolContext,\n} from './types';\nimport { semanticSearchMemories } from '../supermemory/search';\nimport { processMemoryEvent } from '../supermemory/pipeline';\n\ntype AgentMap = Map<string, AgentConfig>;\n\nclass AgentRuntime {\n  private agents: AgentMap = new Map();\n  private runs = new Map<string, AgentRunRecord>();\n  private listeners = new Set<(run: AgentRunRecord) => void>();\n\n  constructor() {\n    this.registerDefaultAgents();\n  }\n\n  registerAgent(config: AgentConfig): void {\n    if (this.agents.has(config.id)) {\n      throw new Error(`Agent with id ${config.id} already registered`);\n    }\n    this.agents.set(config.id, config);\n  }\n\n  getAgents(): AgentConfig[] {\n    return Array.from(this.agents.values());\n  }\n\n  getAgent(id: string): AgentConfig | undefined {\n    return this.agents.get(id);\n  }\n\n  onRunUpdate(cb: (run: AgentRunRecord) => void): () => void {\n    this.listeners.add(cb);\n    return () => this.listeners.delete(cb);\n  }\n\n  async execute(request: AgentExecutionInput & { agentId?: string; signal?: AbortSignal }): Promise<AgentExecutionResult> {\n    const agent = request.agentId ? this.agents.get(request.agentId) : this.selectAgentForPrompt(request.prompt);\n    if (!agent) {\n      return { success: false, error: 'No agent available for this request.' };\n    }\n\n    const runId = nanoid();\n    const runRecord: AgentRunRecord = {\n      id: runId,\n      agentId: agent.id,\n      prompt: request.prompt,\n      status: 'pending',\n    };\n    this.updateRun(runRecord);\n\n    const recentRuns = useAgentMemoryStore.getState().getRecentForAgent(agent.id, 5);\n\n    const env: AgentEnvironment = {\n      tools: this.buildToolset(agent),\n      dispatchEvent: (type, payload) => dispatch({ type, payload, source: `agent:${agent.id}` }),\n      capabilities: agent.capabilities,\n      signal: request.signal,\n      recentRuns,\n    };\n\n    try {\n      runRecord.status = 'running';\n      runRecord.startedAt = Date.now();\n      this.updateRun(runRecord);\n\n      dispatch({\n        type: 'redix:agent:started',\n        payload: { runId, agentId: agent.id, prompt: request.prompt },\n        source: 'agent-runtime',\n      });\n\n      const result = await agent.entryPoint(request, env);\n      runRecord.status = result.success ? 'succeeded' : 'failed';\n      runRecord.finishedAt = Date.now();\n      runRecord.result = result;\n      this.updateRun(runRecord);\n\n      await this.persistAgentMemory({\n        agentId: agent.id,\n        runId,\n        prompt: request.prompt,\n        success: true,\n        output: result.output,\n        durationMs: (runRecord.finishedAt ?? 0) - (runRecord.startedAt ?? 0),\n      });\n\n      dispatch({\n        type: 'redix:agent:finished',\n        payload: { runId, agentId: agent.id, success: result.success },\n        source: 'agent-runtime',\n      });\n\n      return result;\n    } catch (error) {\n      runRecord.status = 'failed';\n      runRecord.finishedAt = Date.now();\n      const errorMessage = error instanceof Error ? error.message : String(error);\n      runRecord.result = { success: false, error: errorMessage };\n      this.updateRun(runRecord);\n\n      await this.persistAgentMemory({\n        agentId: agent.id,\n        runId,\n        prompt: request.prompt,\n        success: false,\n        error: errorMessage,\n        durationMs: (runRecord.finishedAt ?? 0) - (runRecord.startedAt ?? 0),\n      });\n\n      dispatch({\n        type: 'redix:agent:error',\n        payload: { runId, agentId: agent.id, error: runRecord.result.error },\n        source: 'agent-runtime',\n      });\n\n      return runRecord.result;\n    }\n  }\n\n  private updateRun(run: AgentRunRecord) {\n    this.runs.set(run.id, run);\n    this.listeners.forEach((listener) => {\n      try {\n        listener(run);\n      } catch (error) {\n        console.warn('[AgentRuntime] listener failed:', error);\n      }\n    });\n  }\n\n  private selectAgentForPrompt(prompt: string): AgentConfig | undefined {\n    const lower = prompt.toLowerCase();\n    for (const agent of this.agents.values()) {\n      if (agent.trigger?.keywords?.some((kw) => lower.includes(kw))) {\n        return agent;\n      }\n    }\n    // fallback default\n    return this.agents.get('research.agent') || this.agents.values().next().value;\n  }\n\n  private buildToolset(agent: AgentConfig): Record<string, AgentToolExecutor> {\n    const toolset: Record<string, AgentToolExecutor> = {};\n    for (const toolId of agent.tools) {\n      const tool = agentTools[toolId];\n      if (!tool) continue;\n      const missing = tool.requiredCapabilities.filter((cap) => !agent.capabilities.includes(cap));\n      if (missing.length > 0) {\n        console.warn(`[AgentRuntime] Agent ${agent.id} missing capabilities for tool ${toolId}: ${missing.join(',')}`);\n        continue;\n      }\n      toolset[toolId] = async (input, overrides = {}) => {\n        const ctx = this.createToolContext({\n          signal: overrides.signal,\n          memorySearch: overrides.memorySearch,\n          saveMemory: overrides.saveMemory,\n          redixAsk: overrides.redixAsk,\n          safeFetch: overrides.safeFetch,\n        });\n        return tool.run(input, ctx);\n      };\n    }\n    return toolset;\n  }\n\n  private registerDefaultAgents() {\n    this.registerAgent({\n      id: 'research.agent',\n      name: 'Research Agent',\n      description: 'Multi-step researcher that combines SuperMemory with Redix answers.',\n      version: '1.0.0',\n      capabilities: ['memory:read', 'memory:write', 'redix:ask', 'web:fetch'],\n      tools: ['memory.search', 'memory.saveNote', 'redix.ask', 'web.fetch'],\n      trigger: {\n        keywords: ['research', 'compare', 'investigate'],\n        intent: ['research', 'comparison'],\n      },\n      maxSteps: 4,\n      async entryPoint(input, env) {\n        const steps = [];\n        const memoryExecutor = env.tools['memory.search'];\n        const memoryResults = memoryExecutor ? ((await memoryExecutor({ query: input.prompt })) as any[]) : [];\n\n        steps.push({\n          toolId: 'memory.search',\n          input: { query: input.prompt },\n          output: memoryResults,\n          startedAt: Date.now(),\n          finishedAt: Date.now(),\n        });\n\n        const redixExecutor = env.tools['redix.ask'];\n        const redixAnswer = redixExecutor\n          ? await redixExecutor({ prompt: buildContextPrompt(input.prompt, memoryResults) })\n          : '';\n\n        if (typeof redixAnswer === 'string' && redixAnswer.trim().length > 0) {\n          const saveExecutor = env.tools['memory.saveNote'];\n          await saveExecutor?.({\n            title: `Research: ${input.prompt}`,\n            text: redixAnswer,\n            tags: ['research', 'agent'],\n          });\n        }\n\n        return {\n          success: true,\n          output: typeof redixAnswer === 'string' ? redixAnswer : '',\n          steps,\n        };\n      },\n    });\n    this.registerAgent({\n      id: 'trade.agent',\n      name: 'Trade Agent',\n      description: 'Provides market context, price action, and risk notes for Trade mode queries.',\n      version: '1.0.0',\n      capabilities: ['memory:read', 'web:fetch', 'redix:ask'],\n      tools: ['memory.search', 'redix.ask', 'web.fetch', 'trade.fetchQuote'],\n      trigger: {\n        keywords: ['trade', 'stock', 'ticker', 'invest', 'price', 'market', 'AAPL', 'TSLA', 'NVDA', 'MSFT', 'GOOGL'],\n        intent: ['comparison', 'fact'],\n      },\n      maxSteps: 5,\n      async entryPoint(input, env) {\n        const steps = [];\n        const prompt = input.prompt || '';\n        \n        // Extract stock symbols from the query (simple regex for common tickers)\n        const tickerRegex = /\\b([A-Z]{1,5})\\b/g;\n        const matches = prompt.match(tickerRegex) || [];\n        const potentialSymbols = matches.filter((m) => m.length >= 1 && m.length <= 5);\n        \n        // Try to fetch trade data for detected symbols using tool\n        let tradeDataContext = '';\n        if (potentialSymbols.length > 0) {\n          try {\n            const tradeTool = env.tools['trade.fetchQuote'];\n            if (tradeTool) {\n              const quotes = await Promise.allSettled(\n                potentialSymbols.slice(0, 3).map((symbol) => tradeTool({ symbol }))\n              );\n              \n              const successfulQuotes = quotes\n                .filter((r): r is PromiseFulfilledResult<any> => r.status === 'fulfilled')\n                .map((r) => r.value);\n              \n              if (successfulQuotes.length > 0) {\n                tradeDataContext = successfulQuotes\n                  .map((quote: any) => {\n                    const changeSign = quote.change >= 0 ? '+' : '';\n                    return `${quote.symbol}: $${quote.price.toFixed(2)} (${changeSign}${quote.change.toFixed(2)}, ${changeSign}${quote.changePercent.toFixed(2)}%) - ${quote.sentiment} sentiment`;\n                  })\n                  .join('\\n');\n                \n                steps.push({\n                  toolId: 'trade.fetchQuote',\n                  input: { symbols: potentialSymbols.slice(0, 3) },\n                  output: successfulQuotes,\n                  startedAt: Date.now(),\n                  finishedAt: Date.now(),\n                });\n              }\n            }\n          } catch (error) {\n            console.warn('[TradeAgent] Failed to fetch trade data:', error);\n          }\n        }\n        \n        // Build enhanced prompt with trade data\n        const enhancedPrompt = `You are the Trade Mode assistant. Provide price action, key levels, and risk notes for trading queries.\n\n${tradeDataContext ? `Current Market Data:\\n${tradeDataContext}\\n\\n` : ''}User Query: ${prompt}\n\nProvide a concise analysis with:\n1. Current price action and trend\n2. Key support/resistance levels (if applicable)\n3. Risk considerations\n4. Market sentiment`;\n\n        const redixExecutor = env.tools['redix.ask'];\n        if (!redixExecutor) {\n          return { success: false, error: 'Trade agent missing redix.ask tool' };\n        }\n        \n        const output = await redixExecutor({ prompt: enhancedPrompt });\n        steps.push({\n          toolId: 'redix.ask',\n          input: { prompt: enhancedPrompt },\n          output,\n          startedAt: Date.now(),\n          finishedAt: Date.now(),\n        });\n        \n        return {\n          success: true,\n          output: typeof output === 'string' ? output : JSON.stringify(output),\n          steps,\n        };\n      },\n    });\n    \n    // GraphMind Agent - Knowledge graph queries and visualization\n    this.registerAgent({\n      id: 'graphmind.agent',\n      name: 'GraphMind Agent',\n      description: 'Queries and visualizes the personal knowledge graph from SuperMemory.',\n      version: '1.0.0',\n      capabilities: ['memory:read', 'redix:ask'],\n      tools: ['memory.search', 'redix.ask', 'graph.query'],\n      trigger: {\n        keywords: ['graph', 'knowledge', 'connect', 'relationship', 'visualize'],\n        intent: ['research'],\n      },\n      maxSteps: 3,\n      async entryPoint(input, env) {\n        const steps = [];\n        const memoryExecutor = env.tools['memory.search'];\n        const memoryResults = memoryExecutor ? ((await memoryExecutor({ query: input.prompt })) as any[]) : [];\n        \n        steps.push({\n          toolId: 'memory.search',\n          input: { query: input.prompt },\n          output: memoryResults,\n          startedAt: Date.now(),\n          finishedAt: Date.now(),\n        });\n        \n        const redixExecutor = env.tools['redix.ask'];\n        const context = memoryResults.length > 0 \n          ? `Found ${memoryResults.length} related memories. Use these to build connections in the knowledge graph.\\n\\nUser query: ${input.prompt}`\n          : input.prompt;\n        \n        const output = redixExecutor\n          ? await redixExecutor({ prompt: `You are the GraphMind assistant. Help users explore their knowledge graph by identifying connections, relationships, and patterns in their SuperMemory.\\n\\n${context}` })\n          : 'GraphMind agent requires Redix connection.';\n        \n        return {\n          success: true,\n          output: typeof output === 'string' ? output : JSON.stringify(output),\n          steps,\n        };\n      },\n    });\n    \n    // Docs Agent - Document summarization and search\n    this.registerAgent({\n      id: 'docs.agent',\n      name: 'Docs Agent',\n      description: 'Summarizes documents, extracts key information, and helps with documentation queries.',\n      version: '1.0.0',\n      capabilities: ['memory:read', 'memory:write', 'redix:ask'],\n      tools: ['memory.search', 'memory.saveNote', 'redix.ask', 'doc.summarize'],\n      trigger: {\n        keywords: ['document', 'doc', 'summarize', 'extract', 'key points'],\n        intent: ['research', 'fact'],\n      },\n      maxSteps: 3,\n      async entryPoint(input, env) {\n        const steps = [];\n        const redixExecutor = env.tools['redix.ask'];\n        if (!redixExecutor) {\n          return { success: false, error: 'Docs agent missing redix.ask tool' };\n        }\n        \n        const prompt = `You are the Docs Mode assistant. Summarize documents, extract key information, and help with documentation queries.\\n\\nUser query: ${input.prompt}\\n\\nProvide a structured summary with:\\n1. Key points\\n2. Important details\\n3. Action items (if any)`;\n        \n        const output = await redixExecutor({ prompt });\n        steps.push({\n          toolId: 'redix.ask',\n          input: { prompt },\n          output,\n          startedAt: Date.now(),\n          finishedAt: Date.now(),\n        });\n        \n        return {\n          success: true,\n          output: typeof output === 'string' ? output : JSON.stringify(output),\n          steps,\n        };\n      },\n    });\n    \n    // Images Agent - Image search and analysis\n    this.registerAgent({\n      id: 'images.agent',\n      name: 'Images Agent',\n      description: 'Helps with visual search, image analysis, and inspiration boards.',\n      version: '1.0.0',\n      capabilities: ['web:fetch', 'redix:ask'],\n      tools: ['web.fetch', 'redix.ask', 'image.search'],\n      trigger: {\n        keywords: ['image', 'picture', 'visual', 'photo', 'find images'],\n        intent: ['research'],\n      },\n      maxSteps: 3,\n      async entryPoint(input, env) {\n        const steps = [];\n        const redixExecutor = env.tools['redix.ask'];\n        if (!redixExecutor) {\n          return { success: false, error: 'Images agent missing redix.ask tool' };\n        }\n        \n        const prompt = `You are the Images Mode assistant. Help users find and analyze images, create inspiration boards, and work with visual content.\\n\\nUser query: ${input.prompt}`;\n        \n        const output = await redixExecutor({ prompt });\n        steps.push({\n          toolId: 'redix.ask',\n          input: { prompt },\n          output,\n          startedAt: Date.now(),\n          finishedAt: Date.now(),\n        });\n        \n        return {\n          success: true,\n          output: typeof output === 'string' ? output : JSON.stringify(output),\n          steps,\n        };\n      },\n    });\n    \n    // Threats Agent - Security analysis and threat detection\n    this.registerAgent({\n      id: 'threats.agent',\n      name: 'Threats Agent',\n      description: 'Analyzes security threats, provides threat intelligence, and helps with network isolation.',\n      version: '1.0.0',\n      capabilities: ['web:fetch', 'redix:ask'],\n      tools: ['web.fetch', 'redix.ask', 'threat.scan'],\n      trigger: {\n        keywords: ['threat', 'security', 'vulnerability', 'malware', 'phishing', 'scan'],\n        intent: ['research', 'fact'],\n      },\n      maxSteps: 4,\n      async entryPoint(input, env) {\n        const steps = [];\n        const redixExecutor = env.tools['redix.ask'];\n        if (!redixExecutor) {\n          return { success: false, error: 'Threats agent missing redix.ask tool' };\n        }\n        \n        const prompt = `You are the Threats Mode assistant. Analyze security threats, provide threat intelligence, and help with security analysis.\\n\\nUser query: ${input.prompt}\\n\\nProvide:\\n1. Threat assessment\\n2. Risk level\\n3. Recommended actions\\n4. Security best practices`;\n        \n        const output = await redixExecutor({ prompt });\n        steps.push({\n          toolId: 'redix.ask',\n          input: { prompt },\n          output,\n          startedAt: Date.now(),\n          finishedAt: Date.now(),\n        });\n        \n        return {\n          success: true,\n          output: typeof output === 'string' ? output : JSON.stringify(output),\n          steps,\n        };\n      },\n    });\n  }\n\n  private async persistAgentMemory(params: {\n    agentId: string;\n    runId: string;\n    prompt: string;\n    success: boolean;\n    output?: string;\n    error?: string;\n    durationMs?: number;\n  }) {\n    try {\n      useAgentMemoryStore\n        .getState()\n        .addEntry({\n          agentId: params.agentId,\n          runId: params.runId,\n          prompt: params.prompt,\n          response: params.output,\n          error: params.error,\n          success: params.success,\n          tokens: undefined,\n        });\n    } catch (storeError) {\n      console.warn('[AgentRuntime] Failed to update agent memory store:', storeError);\n    }\n\n    if (typeof window === 'undefined') {\n      return;\n    }\n\n    try {\n      await MemoryStoreInstance.saveEvent({\n        type: 'agent',\n        value: params.output || params.error || params.prompt,\n        metadata: {\n          action: params.prompt,\n          runId: params.runId,\n          skill: params.agentId,\n          result: params.output,\n          error: params.error,\n          duration: params.durationMs,\n          success: params.success,\n        },\n      });\n    } catch (error) {\n      console.warn('[AgentRuntime] Failed to persist run in SuperMemory:', error);\n    }\n  }\n\n  private createToolContext(overrides?: Partial<AgentToolContext>): AgentToolContext {\n    return {\n      signal: overrides?.signal,\n      memorySearch:\n        overrides?.memorySearch ||\n        (async (query: string) => {\n          const results = await semanticSearchMemories(query, { limit: 12 });\n          return results.map((r) => r.event);\n        }),\n      saveMemory:\n        overrides?.saveMemory ||\n        (async (event) => {\n          const result = await processMemoryEvent(event);\n          return result.eventId;\n        }),\n      redixAsk: overrides?.redixAsk || (async () => ''),\n      safeFetch: overrides?.safeFetch || fetch,\n    };\n  }\n}\n\nfunction buildContextPrompt(prompt: string, memoryResults?: any[]): string {\n  if (!memoryResults || memoryResults.length === 0) return prompt;\n  const contextLines = memoryResults.slice(0, 5).map((result) => `- ${result.title || result.snippet || result.id}`);\n  return `Context:\\n${contextLines.join('\\n')}\\n\\nUser Prompt: ${prompt}`;\n}\n\nexport const agentRuntime = new AgentRuntime();\n\n\n","import { useEffect, useState, useCallback } from 'react';\r\nimport { agentRuntime } from './runtime';\r\nimport type { AgentRunRecord, AgentExecutionInput, AgentExecutionResult } from './types';\r\n\r\nexport function useAgentRuns(limit = 10): AgentRunRecord[] {\r\n  const [runs, setRuns] = useState<AgentRunRecord[]>([]);\r\n\r\n  useEffect(() => {\r\n    const update = (run: AgentRunRecord) => {\r\n      setRuns((prev) => {\r\n        const updated = [run, ...prev.filter((r) => r.id !== run.id)];\r\n        return updated.slice(0, limit);\r\n      });\r\n    };\r\n    const unsubscribe = agentRuntime.onRunUpdate(update);\r\n    return unsubscribe;\r\n  }, [limit]);\r\n\r\n  return runs;\r\n}\r\n\r\nexport function useAgentExecutor(agentId?: string) {\r\n  return useCallback(\r\n    (input: AgentExecutionInput & { signal?: AbortSignal }): Promise<AgentExecutionResult> =>\r\n      agentRuntime.execute({ ...input, agentId }),\r\n    [agentId]\r\n  );\r\n}\r\n\r\n\r\n"],"file":"core-ai-yFIunLTZ.js"}