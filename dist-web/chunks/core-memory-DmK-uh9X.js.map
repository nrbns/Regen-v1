{"version":3,"mappings":"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","names":["STORAGE_PREFIX","MAX_EVENTS","MemoryStore","__publicField","superMemoryDB","__vitePreload","db","error","key","item","value","arr","event","fullEvent","filters","filtered","e","eventTags","tag","index","cutoff","range","resolve","reject","request","cursor","events","eventId","eventIds","allEvents","map","id","memoryStoreInstance","MemoryStoreInstance","DEFAULT_DIMENSIONS","CHECK_INTERVAL_MS","API_BASE","__vite_import_meta_env__","EmbeddingService","text","options","provider","cached","now","status","start","response","latencyMs","signal","vector","_signal","generateHuggingFaceEmbedding","checkHuggingFaceAvailable","words","i","word","hash","j","dim","magnitude","sum","val","embeddingService","generateEmbeddingVector","embeddingCache","CHUNK_SIZE","CHUNK_OVERLAP","chunkText","chunkSize","overlap","chunks","end","chunk","lastPeriod","lastNewline","breakPoint","generateEmbedding","embedMemoryEvent","embeddingIds","textToEmbed","embedding","DB_NAME","DB_VERSION","SuperMemoryDB","oldVersion","eventsStore","embeddingsStore","upgradeTx","store","updates","getRequest","putRequest","tags","limit","embeddings","maxLimit","daysToKeep","eventsIndex","eventsRange","embeddingsIndex","embeddingsRange","eventCount","embeddingCount","sampleEvents","sampleEmbeddings","avgEventSize","avgEmbeddingSize","totalSize","transaction","ids","results","VectorStore","recentEmbeddings","entries","a","b","toRemove","dbEmbedding","deleted","toDelete","query","maxVectors","minSimilarity","queryVector","allEmbeddings","dbEmbeddings","similarity","r","dotProduct","normA","normB","batch","total","totalDimensions","count","avgDimension","vectorStore","searchVectors","semanticSearchMemories","vectorResults","hydrateEvents","uniqueEventIds","seen","result","eventMap","matches","STOP_WORDS","TAG_LIMIT","extractTagsFromText","tokens","token","counts","extractTagsFromEvent","candidateTexts","combined","processMemoryEvent","enrichedEvent","applyAutoTags","embedError","errorMessage","existing","mergedTags","recentEvents","DEDUP_WINDOW_MS","getDedupKey","isDuplicate","lastTime","k","t","trackUserEvent","trackVisit","url","title","metadata","trackBookmark","trackNote","noteText","trackAction","action","trackTask","task","trackAgent","HUGGINGFACE_API_URL","DEFAULT_MODEL","EMBEDDING_DIMENSIONS","model","generateFallbackEmbedding","summarizeEventsWithAI","eventsByType","type","contextParts","typeEvents","context","apiUrl","define_process_env_default","data","summary","openaiResponse","openaiData","openaiError","generateFallbackSummary","urls","queries","parts","compressEvents","summaryType","sortedEvents","periodStart","periodEnd","summaryText","allTags","saveSummary","summaryEvent","summaries","getSummaries","sorted","runNightlySummarization","oneDayAgo","oneWeekAgo","oneMonthAgo","eventsToCompress","dailyEvents","weeklyEvents","monthlyEvents","summariesCreated","eventsCompressed","eventsByDay","dayStart","dayEvents","eventsByWeek","weekStart","weekStartTs","weekEvents","eventsByMonth","monthStart","monthStartTs","monthEvents","initNightlySummarization","lastRun","oneDayMs","delay","nextRun","triggerSummarization"],"ignoreList":[],"sources":["../../src/core/supermemory/store.ts","../../src/core/supermemory/embeddingService.ts","../../src/core/supermemory/embedding.ts","../../src/core/supermemory/db.ts","../../src/core/supermemory/vectorStore.ts","../../src/core/supermemory/search.ts","../../src/core/supermemory/tag-extractor.ts","../../src/core/supermemory/pipeline.ts","../../src/core/supermemory/tracker.ts","../../src/core/supermemory/huggingface-embedding.ts","../../src/core/supermemory/summarizer.ts"],"sourcesContent":["/**\n * SuperMemory Store - Personal long-term memory & personalization layer\n * Uses localStorage with IndexedDB fallback for larger data\n */\n\nimport type { MemoryEvent } from './event-types';\n\n// Re-export for convenience\nexport type { MemoryEvent } from './event-types';\n\nconst STORAGE_PREFIX = 'sm-';\nconst MAX_EVENTS = 10000; // Limit total events\n// const MAX_EVENTS_PER_TYPE = 1000; // Limit per event type // Unused for now\n\nclass MemoryStore {\n  private db: IDBDatabase | null = null;\n  private useIndexedDB = false;\n\n  /**\n   * Initialize IndexedDB if available\n   * Now uses the enhanced database with migrations\n   */\n  async init(): Promise<void> {\n    if (!('indexedDB' in window)) {\n      this.useIndexedDB = false;\n      return;\n    }\n\n    try {\n      // Use enhanced database\n      const { superMemoryDB } = await import('./db');\n      await superMemoryDB.init();\n      this.useIndexedDB = true;\n      \n      // Get database instance for backward compatibility\n      this.db = (superMemoryDB as any).db;\n    } catch (error) {\n      console.warn('[SuperMemory] IndexedDB unavailable, using localStorage:', error);\n      this.useIndexedDB = false;\n    }\n  }\n\n  /**\n   * Get value from storage\n   */\n  get<T = any>(key: string): T | null {\n    try {\n      if (typeof window === 'undefined' || !window.localStorage) {\n        return null;\n      }\n      const item = localStorage.getItem(STORAGE_PREFIX + key);\n      return item ? JSON.parse(item) : null;\n    } catch (error) {\n      console.error('[SuperMemory] Failed to get:', key, error);\n      return null;\n    }\n  }\n\n  /**\n   * Set value in storage\n   */\n  set(key: string, value: any): void {\n    try {\n      if (typeof window === 'undefined' || !window.localStorage) {\n        return;\n      }\n      localStorage.setItem(STORAGE_PREFIX + key, JSON.stringify(value));\n    } catch (error) {\n      console.error('[SuperMemory] Failed to set:', key, error);\n    }\n  }\n\n  /**\n   * Push item to array in storage\n   */\n  push(key: string, item: any): void {\n    try {\n      if (typeof window === 'undefined' || !window.localStorage) {\n        return;\n      }\n      const arr = this.get<any[]>(key) || [];\n      arr.unshift(item); // Add to beginning\n      \n      // Limit array size\n      if (arr.length > MAX_EVENTS) {\n        arr.splice(MAX_EVENTS);\n      }\n      \n      this.set(key, arr);\n    } catch (error) {\n      console.error('[SuperMemory] Failed to push:', key, error);\n    }\n  }\n\n  /**\n   * Save a memory event\n   * Uses enhanced database with proper write→embed→store pipeline\n   */\n  async saveEvent(event: Omit<MemoryEvent, 'id' | 'ts' | 'score'>): Promise<string> {\n    const fullEvent: MemoryEvent = {\n      ...event,\n      id: `mem-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n      ts: Date.now(),\n      score: this.calculateScore(event),\n    };\n\n    if (this.useIndexedDB) {\n      try {\n        const { superMemoryDB } = await import('./db');\n        await superMemoryDB.saveEvent(fullEvent);\n        return fullEvent.id;\n      } catch (error) {\n        console.warn('[SuperMemory] IndexedDB save failed, falling back to localStorage:', error);\n        this.useIndexedDB = false;\n      }\n    }\n\n    // Fallback to localStorage\n    this.push('events', fullEvent);\n    this.cleanupOldEventsSync();\n    return fullEvent.id;\n  }\n\n  /**\n   * Get events with optional filters\n   */\n  async getEvents(filters?: {\n    type?: MemoryEvent['type'];\n    limit?: number;\n    since?: number;\n    until?: number;\n    pinned?: boolean;\n    tags?: string[];\n  }): Promise<MemoryEvent[]> {\n    if (this.useIndexedDB) {\n      try {\n        const { superMemoryDB } = await import('./db');\n        return await superMemoryDB.getEvents(filters);\n      } catch (error) {\n        console.warn('[SuperMemory] IndexedDB read failed, falling back to localStorage:', error);\n        this.useIndexedDB = false;\n      }\n    }\n\n    // Fallback to localStorage\n    const allEvents = this.get<MemoryEvent[]>('events') || [];\n    let filtered = allEvents;\n\n    if (filters?.type) {\n      filtered = filtered.filter(e => e.type === filters.type);\n    }\n    if (filters?.since) {\n      filtered = filtered.filter(e => e.ts >= filters.since!);\n    }\n    if (filters?.until) {\n      filtered = filtered.filter(e => e.ts <= filters.until!);\n    }\n    if (filters?.pinned !== undefined) {\n      filtered = filtered.filter(e => Boolean(e.metadata?.pinned) === filters.pinned);\n    }\n    if (filters?.tags && filters.tags.length > 0) {\n      filtered = filtered.filter((e) => {\n        const eventTags = e.metadata?.tags || [];\n        return filters.tags!.every((tag) => eventTags.includes(tag));\n      });\n    }\n\n    return filtered.slice(0, filters?.limit || 100);\n  }\n\n  /**\n   * Calculate recency + frequency score\n   */\n  private calculateScore(event: Omit<MemoryEvent, 'id' | 'ts' | 'score'>): number {\n    const allEvents = this.get<MemoryEvent[]>('events') || [];\n    \n    // Frequency: how many times this value appeared\n    const frequency = allEvents.filter(e => \n      e.type === event.type && \n      JSON.stringify(e.value) === JSON.stringify(event.value)\n    ).length;\n    \n    // Recency: newer events get higher score (decay over time)\n    // const now = Date.now(); // Unused for now\n    const recency = 1; // Current event is most recent\n    \n    // Combined score (frequency * 0.6 + recency * 0.4)\n    return frequency * 0.6 + recency * 0.4;\n  }\n\n  /**\n   * Cleanup old events (IndexedDB)\n   */\n  private async cleanupOldEvents(): Promise<void> {\n    if (!this.db) return;\n\n    try {\n      const transaction = this.db.transaction(['events'], 'readwrite');\n      const store = transaction.objectStore('events');\n      const index = store.index('ts');\n      \n      // Delete events older than 90 days\n      const cutoff = Date.now() - (90 * 24 * 60 * 60 * 1000);\n      const range = IDBKeyRange.upperBound(cutoff);\n      \n      return new Promise((resolve, reject) => {\n        const request = index.openCursor(range);\n        request.onsuccess = (e) => {\n          const cursor = (e.target as IDBRequest).result;\n          if (cursor) {\n            cursor.delete();\n            cursor.continue();\n          } else {\n            resolve();\n          }\n        };\n        request.onerror = () => reject(request.error);\n      });\n    } catch (error) {\n      console.warn('[SuperMemory] Cleanup failed:', error);\n    }\n  }\n\n  /**\n   * Cleanup old events (localStorage)\n   */\n  private cleanupOldEventsSync(): void {\n    if (typeof window === 'undefined' || !window.localStorage) {\n      return;\n    }\n    const events = this.get<MemoryEvent[]>('events') || [];\n    \n    // Remove events older than 90 days\n    const cutoff = Date.now() - (90 * 24 * 60 * 60 * 1000);\n    const filtered = events.filter(e => e.ts >= cutoff);\n    \n    // Limit total events\n    if (filtered.length > MAX_EVENTS) {\n      filtered.splice(MAX_EVENTS);\n    }\n    \n    this.set('events', filtered);\n  }\n\n  /**\n   * Delete all events\n   */\n  async forgetAll(): Promise<void> {\n    if (this.useIndexedDB && this.db) {\n      try {\n        const transaction = this.db.transaction(['events'], 'readwrite');\n        const store = transaction.objectStore('events');\n        await store.clear();\n      } catch (error) {\n        console.warn('[SuperMemory] Failed to clear IndexedDB:', error);\n      }\n    }\n    \n    if (typeof window !== 'undefined' && window.localStorage) {\n      localStorage.removeItem(STORAGE_PREFIX + 'events');\n    }\n  }\n\n  /**\n   * Export all events (for user export)\n   */\n  async export(): Promise<MemoryEvent[]> {\n    return this.getEvents({ limit: MAX_EVENTS });\n  }\n\n  /**\n   * Get single event by ID\n   */\n  async getEventById(eventId: string): Promise<MemoryEvent | null> {\n    if (this.useIndexedDB) {\n      try {\n        const { superMemoryDB } = await import('./db');\n        return await superMemoryDB.getEvent(eventId);\n      } catch (error) {\n        console.warn('[SuperMemory] IndexedDB getEvent failed, falling back to localStorage:', error);\n        this.useIndexedDB = false;\n      }\n    }\n\n    const allEvents = this.get<MemoryEvent[]>('events') || [];\n    return allEvents.find((event) => event.id === eventId) || null;\n  }\n\n  /**\n   * Get events by ID list (preserves order)\n   */\n  async getEventsByIds(eventIds: string[]): Promise<MemoryEvent[]> {\n    if (eventIds.length === 0) return [];\n\n    if (this.useIndexedDB) {\n      try {\n        const { superMemoryDB } = await import('./db');\n        return await superMemoryDB.getEventsByIds(eventIds);\n      } catch (error) {\n        console.warn('[SuperMemory] IndexedDB getEventsByIds failed, falling back to localStorage:', error);\n        this.useIndexedDB = false;\n      }\n    }\n\n    const allEvents = this.get<MemoryEvent[]>('events') || [];\n    const map = new Map(allEvents.map((event) => [event.id, event]));\n    return eventIds\n      .map((id) => map.get(id))\n      .filter((event): event is MemoryEvent => Boolean(event));\n  }\n}\n\n// Singleton instance\nconst memoryStoreInstance = new MemoryStore();\nexport const MemoryStoreInstance = memoryStoreInstance; // Export instance\nexport { MemoryStore }; // Export class for type usage\n\n// Initialize on load\nif (typeof window !== 'undefined') {\n  memoryStoreInstance.init().catch(console.error);\n}\n\n","/**\n * EmbeddingService - orchestrates local + remote embedding providers\n * Falls back automatically so SuperMemory stays local-first.\n */\n\ntype EmbeddingProvider = 'openai' | 'huggingface' | 'local';\n\ninterface ProviderStatus {\n  provider: EmbeddingProvider;\n  available: boolean;\n  latencyMs?: number;\n  lastChecked?: number;\n  error?: string;\n}\n\ninterface GenerateOptions {\n  provider?: EmbeddingProvider;\n  signal?: AbortSignal;\n}\n\nconst DEFAULT_DIMENSIONS = 384;\nconst CHECK_INTERVAL_MS = 60_000;\nconst API_BASE =\n  (typeof window !== 'undefined' && (window as any).__superMemoryApiBase) ||\n  (typeof import.meta !== 'undefined' && (import.meta as any).env?.VITE_SUPER_MEMORY_API_BASE) ||\n  'http://localhost:8000';\n\nexport class EmbeddingService {\n  private statusCache: Record<EmbeddingProvider, ProviderStatus> = {\n    openai: { provider: 'openai', available: false },\n    huggingface: { provider: 'huggingface', available: false },\n    local: { provider: 'local', available: true },\n  };\n\n  private preferredOrder: EmbeddingProvider[] = ['openai', 'huggingface', 'local'];\n\n  async generateEmbedding(text: string, options?: GenerateOptions): Promise<number[]> {\n    const provider = options?.provider || (await this.getPreferredProvider());\n    switch (provider) {\n      case 'openai':\n        return this.generateOpenAIEmbedding(text, options?.signal);\n      case 'huggingface':\n        return this.generateHuggingFaceEmbedding(text, options?.signal);\n      case 'local':\n      default:\n        return this.generateLocalEmbedding(text);\n    }\n  }\n\n  async getPreferredProvider(): Promise<EmbeddingProvider> {\n    // Skip backend checks in web mode - use local only\n    const isWebMode =\n      typeof window !== 'undefined' && !(window as any).__ELECTRON__ && !(window as any).__TAURI__;\n\n    if (isWebMode) {\n      return 'local';\n    }\n\n    for (const provider of this.preferredOrder) {\n      const status = await this.checkProvider(provider);\n      if (status.available) {\n        return provider;\n      }\n    }\n    return 'local';\n  }\n\n  private async checkProvider(provider: EmbeddingProvider): Promise<ProviderStatus> {\n    const cached = this.statusCache[provider];\n    const now = Date.now();\n    if (cached.lastChecked && now - cached.lastChecked < CHECK_INTERVAL_MS) {\n      return cached;\n    }\n\n    try {\n      if (provider === 'openai') {\n        const status = await this.checkOpenAI();\n        this.statusCache[provider] = status;\n        return status;\n      }\n      if (provider === 'huggingface') {\n        const status = await this.checkHuggingFace();\n        this.statusCache[provider] = status;\n        return status;\n      }\n      this.statusCache[provider] = {\n        provider: 'local',\n        available: true,\n        lastChecked: now,\n      };\n      return this.statusCache[provider];\n    } catch (error) {\n      this.statusCache[provider] = {\n        provider,\n        available: false,\n        lastChecked: now,\n        error: error instanceof Error ? error.message : String(error),\n      };\n      return this.statusCache[provider];\n    }\n  }\n\n  private async checkOpenAI(): Promise<ProviderStatus> {\n    // Skip backend checks in web mode - no backend available\n    const isWebMode =\n      typeof window !== 'undefined' && !(window as any).__ELECTRON__ && !(window as any).__TAURI__;\n\n    if (isWebMode) {\n      return {\n        provider: 'openai',\n        available: false,\n        lastChecked: Date.now(),\n      };\n    }\n\n    const start = performance.now();\n    try {\n      const response = await fetch(`${API_BASE}/openai/status`, { method: 'GET' });\n      const latencyMs = performance.now() - start;\n      if (!response.ok) {\n        throw new Error(`OpenAI status ${response.status}`);\n      }\n      const data = await response.json();\n      return {\n        provider: 'openai',\n        available: data.available ?? true,\n        latencyMs,\n        lastChecked: Date.now(),\n      };\n    } catch (error) {\n      return {\n        provider: 'openai',\n        available: false,\n        error: error instanceof Error ? error.message : String(error),\n        lastChecked: Date.now(),\n      };\n    }\n  }\n\n  private async checkHuggingFace(): Promise<ProviderStatus> {\n    // Skip backend checks in web mode - no backend available\n    const isWebMode =\n      typeof window !== 'undefined' && !(window as any).__ELECTRON__ && !(window as any).__TAURI__;\n\n    if (isWebMode) {\n      return {\n        provider: 'huggingface',\n        available: false,\n        lastChecked: Date.now(),\n      };\n    }\n\n    const start = performance.now();\n    try {\n      const response = await fetch(`${API_BASE}/huggingface/status`, { method: 'GET' });\n      const latencyMs = performance.now() - start;\n      if (!response.ok) {\n        throw new Error(`HuggingFace status ${response.status}`);\n      }\n      const data = await response.json();\n      return {\n        provider: 'huggingface',\n        available: data.available ?? true,\n        latencyMs,\n        lastChecked: Date.now(),\n      };\n    } catch (error) {\n      return {\n        provider: 'huggingface',\n        available: false,\n        error: error instanceof Error ? error.message : String(error),\n        lastChecked: Date.now(),\n      };\n    }\n  }\n\n  private async generateOpenAIEmbedding(text: string, signal?: AbortSignal): Promise<number[]> {\n    try {\n      const response = await fetch(`${API_BASE}/openai/embedding`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ text, model: 'text-embedding-3-small' }),\n        signal,\n      });\n      if (!response.ok) {\n        throw new Error(`OpenAI embedding failed: ${response.status}`);\n      }\n      const data = await response.json();\n      const vector = data.embedding as number[];\n      if (!Array.isArray(vector)) {\n        throw new Error('OpenAI embedding malformed');\n      }\n      return vector;\n    } catch (error) {\n      this.statusCache.openai = {\n        provider: 'openai',\n        available: false,\n        error: error instanceof Error ? error.message : String(error),\n        lastChecked: Date.now(),\n      };\n      return this.generateHuggingFaceEmbedding(text, signal);\n    }\n  }\n\n  private async generateHuggingFaceEmbedding(\n    text: string,\n    _signal?: AbortSignal\n  ): Promise<number[]> {\n    try {\n      const { generateHuggingFaceEmbedding, checkHuggingFaceAvailable } =\n        await import('./huggingface-embedding');\n      const available = await checkHuggingFaceAvailable();\n      if (!available) {\n        throw new Error('HuggingFace inference unavailable');\n      }\n      const vector = await generateHuggingFaceEmbedding(text);\n      return vector;\n    } catch (error) {\n      this.statusCache.huggingface = {\n        provider: 'huggingface',\n        available: false,\n        error: error instanceof Error ? error.message : String(error),\n        lastChecked: Date.now(),\n      };\n      return this.generateLocalEmbedding(text);\n    }\n  }\n\n  private async generateLocalEmbedding(text: string): Promise<number[]> {\n    const normalized = text.toLowerCase();\n    const words = normalized.split(/\\s+/).filter(Boolean);\n    const vector = new Array(DEFAULT_DIMENSIONS).fill(0);\n\n    for (let i = 0; i < words.length; i++) {\n      const word = words[i];\n      let hash = 0;\n      for (let j = 0; j < word.length; j++) {\n        hash = (hash << 5) - hash + word.charCodeAt(j);\n        hash |= 0; // Convert to 32-bit int\n      }\n      const dim = Math.abs(hash) % DEFAULT_DIMENSIONS;\n      vector[dim] += 1 / Math.sqrt(i + 1);\n    }\n\n    const magnitude = Math.sqrt(vector.reduce((sum, val) => sum + val * val, 0));\n    if (magnitude > 0) {\n      for (let i = 0; i < vector.length; i++) {\n        vector[i] = vector[i] / magnitude;\n      }\n    }\n\n    return vector;\n  }\n}\n\nexport const embeddingService = new EmbeddingService();\n\nexport const generateEmbeddingVector = (text: string, options?: GenerateOptions) =>\n  embeddingService.generateEmbedding(text, options);\n","/**\r\n * Embedding Pipeline for SuperMemory\r\n * Generates and stores vector embeddings for semantic search\r\n */\r\n\r\nimport { MemoryStoreInstance } from './store';\r\nimport { MemoryEvent } from './tracker';\r\nimport { generateEmbeddingVector } from './embeddingService';\r\n\r\nexport interface Embedding {\r\n  id: string;\r\n  eventId: string;\r\n  vector: number[]; // 384-dimensional vector (using all-MiniLM-L6-v2 model size)\r\n  text: string;\r\n  metadata?: Record<string, any>;\r\n  timestamp: number;\r\n}\r\n\r\n// Simple embedding cache (in production, use IndexedDB or vector DB)\r\nconst embeddingCache = new Map<string, Embedding>();\r\n\r\n// Chunk size for text splitting\r\nconst CHUNK_SIZE = 512; // tokens/characters\r\nconst CHUNK_OVERLAP = 50;\r\n\r\n/**\r\n * Split text into chunks for embedding\r\n */\r\nexport function chunkText(text: string, chunkSize: number = CHUNK_SIZE, overlap: number = CHUNK_OVERLAP): string[] {\r\n  if (text.length <= chunkSize) {\r\n    return [text];\r\n  }\r\n\r\n  const chunks: string[] = [];\r\n  let start = 0;\r\n\r\n  while (start < text.length) {\r\n    const end = Math.min(start + chunkSize, text.length);\r\n    let chunk = text.slice(start, end);\r\n\r\n    // Try to break at sentence boundaries\r\n    if (end < text.length) {\r\n      const lastPeriod = chunk.lastIndexOf('.');\r\n      const lastNewline = chunk.lastIndexOf('\\n');\r\n      const breakPoint = Math.max(lastPeriod, lastNewline);\r\n      \r\n      if (breakPoint > chunkSize * 0.5) {\r\n        chunk = text.slice(start, start + breakPoint + 1);\r\n        start += breakPoint + 1;\r\n      } else {\r\n        start = end - overlap;\r\n      }\r\n    } else {\r\n      start = end;\r\n    }\r\n\r\n    chunks.push(chunk.trim());\r\n  }\r\n\r\n  return chunks.filter(chunk => chunk.length > 0);\r\n}\r\n\r\n/**\r\n * Generate embedding for text using Hugging Face API (with fallback)\r\n * Uses Hugging Face Inference API for semantic embeddings\r\n */\r\nexport async function generateEmbedding(text: string): Promise<number[]> {\r\n  return generateEmbeddingVector(text);\r\n}\r\n\r\n/**\r\n * Generate and store embeddings for a memory event\r\n */\r\nexport async function embedMemoryEvent(event: MemoryEvent): Promise<string[]> {\r\n  const embeddingIds: string[] = [];\r\n\r\n  try {\r\n    // Extract text to embed based on event type\r\n    let textToEmbed = '';\r\n    \r\n    if (event.type === 'search') {\r\n      textToEmbed = event.value; // Search query\r\n    } else if (event.type === 'visit') {\r\n      textToEmbed = `${event.metadata?.title || ''} ${event.value}`.trim(); // Page title + URL\r\n    } else if (event.type === 'note') {\r\n      textToEmbed = event.value; // Note content\r\n    } else {\r\n      textToEmbed = event.value || JSON.stringify(event.metadata || {});\r\n    }\r\n\r\n    if (!textToEmbed || textToEmbed.length < 10) {\r\n      return embeddingIds; // Skip very short text\r\n    }\r\n\r\n    // Chunk text if needed\r\n    const chunks = chunkText(textToEmbed);\r\n    \r\n    // Generate embeddings for each chunk\r\n    for (let i = 0; i < chunks.length; i++) {\r\n      const chunk = chunks[i];\r\n      const vector = await generateEmbedding(chunk);\r\n      \r\n      const embedding: Embedding = {\r\n        id: `${event.id}-chunk-${i}`,\r\n        eventId: event.id,\r\n        vector,\r\n        text: chunk,\r\n        metadata: {\r\n          chunkIndex: i,\r\n          totalChunks: chunks.length,\r\n          eventType: event.type,\r\n          ...event.metadata,\r\n        },\r\n        timestamp: event.ts,\r\n      };\r\n\r\n      // Store in cache\r\n      embeddingCache.set(embedding.id, embedding);\r\n      \r\n      // Store in IndexedDB (enhanced database)\r\n      try {\r\n        const { superMemoryDB } = await import('./db');\r\n        await superMemoryDB.saveEmbedding({\r\n          id: embedding.id,\r\n          eventId: embedding.eventId,\r\n          vector: embedding.vector,\r\n          text: embedding.text,\r\n          metadata: embedding.metadata,\r\n          timestamp: embedding.timestamp,\r\n        });\r\n      } catch (error) {\r\n        // Fallback to localStorage\r\n        console.warn('[Embedding] Failed to save to IndexedDB, using localStorage:', error);\r\n        MemoryStoreInstance.set(`embedding:${embedding.id}`, embedding);\r\n      }\r\n      \r\n      embeddingIds.push(embedding.id);\r\n    }\r\n  } catch (error) {\r\n    console.error('[Embedding] Failed to embed memory event:', error);\r\n  }\r\n\r\n  return embeddingIds;\r\n}\r\n\r\n/**\r\n * Search embeddings by similarity\r\n */\r\nexport async function searchEmbeddings(query: string, limit: number = 10): Promise<Array<{ embedding: Embedding; similarity: number }>> {\r\n  try {\r\n    // Generate query embedding\r\n    const queryVector = await generateEmbedding(query);\r\n    \r\n    // Get all embeddings from store\r\n    const allEmbeddings: Embedding[] = [];\r\n    \r\n    // Load from cache first\r\n    for (const embedding of embeddingCache.values()) {\r\n      allEmbeddings.push(embedding);\r\n    }\r\n    \r\n    // Load from IndexedDB (enhanced database)\r\n    try {\r\n      const { superMemoryDB } = await import('./db');\r\n      const dbEmbeddings = await superMemoryDB.getAllEmbeddings(1000);\r\n      \r\n      for (const dbEmbedding of dbEmbeddings) {\r\n        const embedding: Embedding = {\r\n          id: dbEmbedding.id,\r\n          eventId: dbEmbedding.eventId,\r\n          vector: dbEmbedding.vector,\r\n          text: dbEmbedding.text,\r\n          metadata: dbEmbedding.metadata,\r\n          timestamp: dbEmbedding.timestamp,\r\n        };\r\n        \r\n        if (!embeddingCache.has(embedding.id)) {\r\n          embeddingCache.set(embedding.id, embedding);\r\n          allEmbeddings.push(embedding);\r\n        }\r\n      }\r\n    } catch (error) {\r\n      // Fallback to localStorage\r\n      console.warn('[Embedding] Failed to load from IndexedDB, using localStorage:', error);\r\n      const storedEvents = await MemoryStoreInstance.getEvents({ limit: 1000 });\r\n      for (const event of storedEvents) {\r\n        try {\r\n          const embedding = MemoryStoreInstance.get<Embedding>(`embedding:${event.id}-chunk-0`);\r\n          if (embedding && !embeddingCache.has(embedding.id)) {\r\n            embeddingCache.set(embedding.id, embedding);\r\n            allEmbeddings.push(embedding);\r\n          }\r\n        } catch {\r\n          // Skip if embedding doesn't exist\r\n        }\r\n      }\r\n    }\r\n\r\n    // Calculate cosine similarity\r\n    const results = allEmbeddings.map(embedding => {\r\n      const similarity = cosineSimilarity(queryVector, embedding.vector);\r\n      return { embedding, similarity };\r\n    });\r\n\r\n    // Sort by similarity and return top results\r\n    results.sort((a, b) => b.similarity - a.similarity);\r\n    return results.slice(0, limit);\r\n  } catch (error) {\r\n    console.error('[Embedding] Failed to search embeddings:', error);\r\n    return [];\r\n  }\r\n}\r\n\r\n/**\r\n * Calculate cosine similarity between two vectors\r\n */\r\nfunction cosineSimilarity(a: number[], b: number[]): number {\r\n  if (a.length !== b.length) {\r\n    return 0;\r\n  }\r\n\r\n  let dotProduct = 0;\r\n  let normA = 0;\r\n  let normB = 0;\r\n\r\n  for (let i = 0; i < a.length; i++) {\r\n    dotProduct += a[i] * b[i];\r\n    normA += a[i] * a[i];\r\n    normB += b[i] * b[i];\r\n  }\r\n\r\n  if (normA === 0 || normB === 0) {\r\n    return 0;\r\n  }\r\n\r\n  return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));\r\n}\r\n\r\n/**\r\n * Batch embed multiple events\r\n */\r\nexport async function batchEmbedEvents(events: MemoryEvent[]): Promise<void> {\r\n  for (const event of events) {\r\n    await embedMemoryEvent(event);\r\n  }\r\n}\r\n\r\n/**\r\n * Clear embeddings for an event\r\n */\r\nexport async function clearEventEmbeddings(eventId: string): Promise<void> {\r\n  // Find all embeddings for this event\r\n  const toDelete: string[] = [];\r\n  \r\n  for (const [id, embedding] of embeddingCache.entries()) {\r\n    if (embedding.eventId === eventId) {\r\n      toDelete.push(id);\r\n    }\r\n  }\r\n\r\n  // Delete from cache and store\r\n  for (const id of toDelete) {\r\n    embeddingCache.delete(id);\r\n    MemoryStoreInstance.set(`embedding:${id}`, null); // Clear from store\r\n  }\r\n}\r\n\r\n","/**\n * SuperMemory Database - IndexedDB implementation with migrations\n * Handles events, embeddings, and vector storage\n */\n\nimport type { MemoryEvent } from './event-types';\n\n// Re-export for convenience\nexport type { MemoryEvent } from './event-types';\n\nexport interface EmbeddingRecord {\n  id: string;\n  eventId: string;\n  vector: number[]; // Vector embedding\n  text: string;\n  metadata?: Record<string, any>;\n  timestamp: number;\n}\n\nconst DB_NAME = 'supermemory';\nconst DB_VERSION = 2; // Increment for migrations\n\nclass SuperMemoryDB {\n  private db: IDBDatabase | null = null;\n  private initPromise: Promise<void> | null = null;\n\n  /**\n   * Initialize database with migrations\n   */\n  async init(): Promise<void> {\n    if (this.initPromise) {\n      return this.initPromise;\n    }\n\n    if (!('indexedDB' in window)) {\n      throw new Error('IndexedDB not available');\n    }\n\n    this.initPromise = new Promise((resolve, reject) => {\n      const request = indexedDB.open(DB_NAME, DB_VERSION);\n\n      request.onerror = () => reject(request.error);\n      request.onsuccess = () => {\n        this.db = request.result;\n        resolve();\n      };\n\n      request.onupgradeneeded = event => {\n        const db = (event.target as IDBOpenDBRequest).result;\n        const oldVersion = event.oldVersion || 0;\n\n        // Migration: Version 0 → 1 (initial schema)\n        if (oldVersion < 1) {\n          // Create events store\n          if (!db.objectStoreNames.contains('events')) {\n            const eventsStore = db.createObjectStore('events', { keyPath: 'id' });\n            eventsStore.createIndex('type', 'type', { unique: false });\n            eventsStore.createIndex('ts', 'ts', { unique: false });\n            eventsStore.createIndex('score', 'score', { unique: false });\n          }\n        }\n\n        // Migration: Version 1 → 2 (add embeddings store and tags index)\n        if (oldVersion < 2) {\n          // Create embeddings store\n          if (!db.objectStoreNames.contains('embeddings')) {\n            const embeddingsStore = db.createObjectStore('embeddings', { keyPath: 'id' });\n            embeddingsStore.createIndex('eventId', 'eventId', { unique: false });\n            embeddingsStore.createIndex('timestamp', 'timestamp', { unique: false });\n            // Note: Vector similarity search would require a vector index (not natively supported in IndexedDB)\n            // For now, we'll do in-memory similarity search after loading vectors\n          }\n\n          // Add pinned index to events store using the existing upgrade transaction\n          if (db.objectStoreNames.contains('events')) {\n            const upgradeTx = (event.target as IDBOpenDBRequest).transaction;\n            if (upgradeTx) {\n              const eventsStore = upgradeTx.objectStore('events');\n              if (!eventsStore.indexNames.contains('pinned')) {\n                // IndexedDB requires indexes to be created during the upgrade transaction.\n                // We intentionally skip creating a new index to avoid schema churn;\n                // pinned filtering is handled in application code.\n              }\n            }\n          }\n        }\n      };\n    });\n\n    return this.initPromise;\n  }\n\n  /**\n   * Get database instance (ensure initialized)\n   */\n  private async getDB(): Promise<IDBDatabase> {\n    if (!this.db) {\n      await this.init();\n    }\n    if (!this.db) {\n      throw new Error('Database not initialized');\n    }\n    return this.db;\n  }\n\n  /**\n   * Save event to database\n   */\n  async saveEvent(event: MemoryEvent): Promise<void> {\n    const db = await this.getDB();\n    const transaction = db.transaction(['events'], 'readwrite');\n    const store = transaction.objectStore('events');\n\n    return new Promise((resolve, reject) => {\n      const request = store.put(event);\n      request.onsuccess = () => resolve();\n      request.onerror = () => reject(request.error);\n    });\n  }\n\n  /**\n   * Update event metadata (pin, tags, etc.)\n   */\n  async updateEventMetadata(\n    eventId: string,\n    updates: Partial<MemoryEvent['metadata']>\n  ): Promise<void> {\n    const db = await this.getDB();\n    const transaction = db.transaction(['events'], 'readwrite');\n    const store = transaction.objectStore('events');\n\n    return new Promise((resolve, reject) => {\n      const getRequest = store.get(eventId);\n      getRequest.onsuccess = () => {\n        const event = getRequest.result as MemoryEvent;\n        if (!event) {\n          reject(new Error('Event not found'));\n          return;\n        }\n\n        // Merge metadata updates\n        event.metadata = {\n          ...event.metadata,\n          ...updates,\n        };\n\n        const putRequest = store.put(event);\n        putRequest.onsuccess = () => resolve();\n        putRequest.onerror = () => reject(putRequest.error);\n      };\n      getRequest.onerror = () => reject(getRequest.error);\n    });\n  }\n\n  /**\n   * Get all unique tags\n   */\n  async getAllTags(): Promise<string[]> {\n    const db = await this.getDB();\n    const transaction = db.transaction(['events'], 'readonly');\n    const store = transaction.objectStore('events');\n\n    const tags = new Set<string>();\n\n    return new Promise((resolve, reject) => {\n      const request = store.openCursor();\n      request.onsuccess = e => {\n        const cursor = (e.target as IDBRequest).result;\n        if (cursor) {\n          const event = cursor.value as MemoryEvent;\n          if (event.metadata?.tags) {\n            for (const tag of event.metadata.tags) {\n              tags.add(tag);\n            }\n          }\n          cursor.continue();\n        } else {\n          resolve(Array.from(tags).sort());\n        }\n      };\n      request.onerror = () => reject(request.error);\n    });\n  }\n\n  /**\n   * Get events with filters\n   */\n  async getEvents(filters?: {\n    type?: MemoryEvent['type'];\n    limit?: number;\n    since?: number;\n    until?: number;\n    pinned?: boolean;\n    tags?: string[];\n  }): Promise<MemoryEvent[]> {\n    const db = await this.getDB();\n    const transaction = db.transaction(['events'], 'readonly');\n    const store = transaction.objectStore('events');\n    const index = store.index('ts');\n\n    const events: MemoryEvent[] = [];\n    let range: IDBKeyRange | null = null;\n\n    // Build key range\n    if (filters?.since && filters?.until) {\n      range = IDBKeyRange.bound(filters.since, filters.until);\n    } else if (filters?.since) {\n      range = IDBKeyRange.lowerBound(filters.since);\n    } else if (filters?.until) {\n      range = IDBKeyRange.upperBound(filters.until);\n    }\n\n    return new Promise((resolve, reject) => {\n      const request = index.openCursor(range, 'prev'); // Most recent first\n      const limit = filters?.limit || 100;\n\n      request.onsuccess = e => {\n        const cursor = (e.target as IDBRequest).result;\n        if (cursor && events.length < limit) {\n          const event = cursor.value as MemoryEvent;\n\n          // Apply filters\n          if (filters?.type && event.type !== filters.type) {\n            cursor.continue();\n            return;\n          }\n\n          if (\n            filters?.pinned !== undefined &&\n            (event.metadata?.pinned || false) !== filters.pinned\n          ) {\n            cursor.continue();\n            return;\n          }\n\n          if (filters?.tags && filters.tags.length > 0) {\n            const eventTags = event.metadata?.tags || [];\n            const hasAllTags = filters.tags.every(tag => eventTags.includes(tag));\n            if (!hasAllTags) {\n              cursor.continue();\n              return;\n            }\n          }\n\n          events.push(event);\n          cursor.continue();\n        } else {\n          resolve(events);\n        }\n      };\n\n      request.onerror = () => reject(request.error);\n    });\n  }\n\n  /**\n   * Save embedding to database\n   */\n  async saveEmbedding(embedding: EmbeddingRecord): Promise<void> {\n    const db = await this.getDB();\n    const transaction = db.transaction(['embeddings'], 'readwrite');\n    const store = transaction.objectStore('embeddings');\n\n    return new Promise((resolve, reject) => {\n      const request = store.put(embedding);\n      request.onsuccess = () => resolve();\n      request.onerror = () => reject(request.error);\n    });\n  }\n\n  /**\n   * Get embeddings for an event\n   */\n  async getEmbeddingsForEvent(eventId: string): Promise<EmbeddingRecord[]> {\n    const db = await this.getDB();\n    const transaction = db.transaction(['embeddings'], 'readonly');\n    const store = transaction.objectStore('embeddings');\n    const index = store.index('eventId');\n\n    const embeddings: EmbeddingRecord[] = [];\n\n    return new Promise((resolve, reject) => {\n      const request = index.openCursor(IDBKeyRange.only(eventId));\n\n      request.onsuccess = e => {\n        const cursor = (e.target as IDBRequest).result;\n        if (cursor) {\n          embeddings.push(cursor.value as EmbeddingRecord);\n          cursor.continue();\n        } else {\n          resolve(embeddings);\n        }\n      };\n\n      request.onerror = () => reject(request.error);\n    });\n  }\n\n  /**\n   * Get all embeddings (for vector search)\n   * Note: In production, use a proper vector database for efficient similarity search\n   */\n  async getAllEmbeddings(limit?: number): Promise<EmbeddingRecord[]> {\n    const db = await this.getDB();\n    const transaction = db.transaction(['embeddings'], 'readonly');\n    const store = transaction.objectStore('embeddings');\n    const index = store.index('timestamp');\n\n    const embeddings: EmbeddingRecord[] = [];\n    const maxLimit = limit || 1000;\n\n    return new Promise((resolve, reject) => {\n      const request = index.openCursor(null, 'prev'); // Most recent first\n\n      request.onsuccess = e => {\n        const cursor = (e.target as IDBRequest).result;\n        if (cursor && embeddings.length < maxLimit) {\n          embeddings.push(cursor.value as EmbeddingRecord);\n          cursor.continue();\n        } else {\n          resolve(embeddings);\n        }\n      };\n\n      request.onerror = () => reject(request.error);\n    });\n  }\n\n  /**\n   * Delete embeddings for an event\n   */\n  async deleteEmbeddingsForEvent(eventId: string): Promise<void> {\n    const db = await this.getDB();\n    const transaction = db.transaction(['embeddings'], 'readwrite');\n    const store = transaction.objectStore('embeddings');\n    const index = store.index('eventId');\n\n    return new Promise((resolve, reject) => {\n      const request = index.openCursor(IDBKeyRange.only(eventId));\n\n      request.onsuccess = e => {\n        const cursor = (e.target as IDBRequest).result;\n        if (cursor) {\n          cursor.delete();\n          cursor.continue();\n        } else {\n          resolve();\n        }\n      };\n\n      request.onerror = () => reject(request.error);\n    });\n  }\n\n  /**\n   * Get a single embedding by ID\n   */\n  async getEmbedding(id: string): Promise<EmbeddingRecord | null> {\n    const db = await this.getDB();\n    const transaction = db.transaction(['embeddings'], 'readonly');\n    const store = transaction.objectStore('embeddings');\n\n    return new Promise((resolve, reject) => {\n      const request = store.get(id);\n      request.onsuccess = () => {\n        resolve((request.result as EmbeddingRecord) || null);\n      };\n      request.onerror = () => reject(request.error);\n    });\n  }\n\n  /**\n   * Delete a single embedding by ID\n   */\n  async deleteEmbedding(id: string): Promise<void> {\n    const db = await this.getDB();\n    const transaction = db.transaction(['embeddings'], 'readwrite');\n    const store = transaction.objectStore('embeddings');\n\n    return new Promise((resolve, reject) => {\n      const request = store.delete(id);\n      request.onsuccess = () => resolve();\n      request.onerror = () => reject(request.error);\n    });\n  }\n\n  /**\n   * Delete embeddings by event ID (alias for deleteEmbeddingsForEvent)\n   */\n  async deleteEmbeddingsByEventId(eventId: string): Promise<void> {\n    await this.deleteEmbeddingsForEvent(eventId);\n  }\n\n  /**\n   * Get total embedding count\n   */\n  async getEmbeddingCount(): Promise<number> {\n    const db = await this.getDB();\n    const transaction = db.transaction(['embeddings'], 'readonly');\n    const store = transaction.objectStore('embeddings');\n\n    return new Promise((resolve, reject) => {\n      const request = store.count();\n      request.onsuccess = () => resolve(request.result);\n      request.onerror = () => reject(request.error);\n    });\n  }\n\n  /**\n   * Clear all embeddings\n   */\n  async clearEmbeddings(): Promise<void> {\n    const db = await this.getDB();\n    const transaction = db.transaction(['embeddings'], 'readwrite');\n    const store = transaction.objectStore('embeddings');\n\n    return new Promise((resolve, reject) => {\n      const request = store.clear();\n      request.onsuccess = () => resolve();\n      request.onerror = () => reject(request.error);\n    });\n  }\n\n  /**\n   * Delete event and its embeddings\n   */\n  async deleteEvent(eventId: string): Promise<void> {\n    const db = await this.getDB();\n\n    // Delete embeddings first\n    await this.deleteEmbeddingsForEvent(eventId);\n\n    // Delete event\n    const transaction = db.transaction(['events'], 'readwrite');\n    const store = transaction.objectStore('events');\n\n    return new Promise((resolve, reject) => {\n      const request = store.delete(eventId);\n      request.onsuccess = () => resolve();\n      request.onerror = () => reject(request.error);\n    });\n  }\n\n  /**\n   * Cleanup old events and embeddings\n   */\n  async cleanupOldData(daysToKeep: number = 90): Promise<void> {\n    const db = await this.getDB();\n    const cutoff = Date.now() - daysToKeep * 24 * 60 * 60 * 1000;\n\n    // Cleanup old events\n    const eventsTransaction = db.transaction(['events'], 'readwrite');\n    const eventsStore = eventsTransaction.objectStore('events');\n    const eventsIndex = eventsStore.index('ts');\n    const eventsRange = IDBKeyRange.upperBound(cutoff);\n\n    await new Promise<void>((resolve, reject) => {\n      const request = eventsIndex.openCursor(eventsRange);\n      request.onsuccess = e => {\n        const cursor = (e.target as IDBRequest).result;\n        if (cursor) {\n          const event = cursor.value as MemoryEvent;\n          // Delete embeddings for this event\n          this.deleteEmbeddingsForEvent(event.id).catch(console.warn);\n          cursor.delete();\n          cursor.continue();\n        } else {\n          resolve();\n        }\n      };\n      request.onerror = () => reject(request.error);\n    });\n\n    // Cleanup old embeddings\n    const embeddingsTransaction = db.transaction(['embeddings'], 'readwrite');\n    const embeddingsStore = embeddingsTransaction.objectStore('embeddings');\n    const embeddingsIndex = embeddingsStore.index('timestamp');\n    const embeddingsRange = IDBKeyRange.upperBound(cutoff);\n\n    await new Promise<void>((resolve, reject) => {\n      const request = embeddingsIndex.openCursor(embeddingsRange);\n      request.onsuccess = e => {\n        const cursor = (e.target as IDBRequest).result;\n        if (cursor) {\n          cursor.delete();\n          cursor.continue();\n        } else {\n          resolve();\n        }\n      };\n      request.onerror = () => reject(request.error);\n    });\n  }\n\n  /**\n   * Get database statistics\n   */\n  async getStats(): Promise<{\n    eventCount: number;\n    embeddingCount: number;\n    totalSize: number; // Approximate size in bytes\n  }> {\n    const db = await this.getDB();\n\n    // Count events\n    const eventsTransaction = db.transaction(['events'], 'readonly');\n    const eventsStore = eventsTransaction.objectStore('events');\n    const eventCount = await new Promise<number>((resolve, reject) => {\n      const request = eventsStore.count();\n      request.onsuccess = () => resolve(request.result);\n      request.onerror = () => reject(request.error);\n    });\n\n    // Count embeddings\n    const embeddingsTransaction = db.transaction(['embeddings'], 'readonly');\n    const embeddingsStore = embeddingsTransaction.objectStore('embeddings');\n    const embeddingCount = await new Promise<number>((resolve, reject) => {\n      const request = embeddingsStore.count();\n      request.onsuccess = () => resolve(request.result);\n      request.onerror = () => reject(request.error);\n    });\n\n    // Estimate size (rough calculation)\n    const sampleEvents = await this.getEvents({ limit: 10 });\n    const sampleEmbeddings = await this.getAllEmbeddings(10);\n    const avgEventSize = sampleEvents.length > 0 ? JSON.stringify(sampleEvents[0]).length : 500;\n    const avgEmbeddingSize =\n      sampleEmbeddings.length > 0 ? JSON.stringify(sampleEmbeddings[0]).length : 2000;\n\n    const totalSize = eventCount * avgEventSize + embeddingCount * avgEmbeddingSize;\n\n    return { eventCount, embeddingCount, totalSize };\n  }\n\n  /**\n   * Clear all data\n   */\n  async clearAll(): Promise<void> {\n    const db = await this.getDB();\n\n    const transaction = db.transaction(['events', 'embeddings'], 'readwrite');\n    await Promise.all([\n      new Promise<void>((resolve, reject) => {\n        const request = transaction.objectStore('events').clear();\n        request.onsuccess = () => resolve();\n        request.onerror = () => reject(request.error);\n      }),\n      new Promise<void>((resolve, reject) => {\n        const request = transaction.objectStore('embeddings').clear();\n        request.onsuccess = () => resolve();\n        request.onerror = () => reject(request.error);\n      }),\n    ]);\n  }\n\n  /**\n   * Get a single event by ID\n   */\n  async getEvent(eventId: string): Promise<MemoryEvent | null> {\n    const db = await this.getDB();\n    const transaction = db.transaction(['events'], 'readonly');\n    const store = transaction.objectStore('events');\n\n    return new Promise((resolve, reject) => {\n      const request = store.get(eventId);\n      request.onsuccess = () => resolve((request.result as MemoryEvent) || null);\n      request.onerror = () => reject(request.error);\n    });\n  }\n\n  /**\n   * Get multiple events by IDs (preserves order of IDs)\n   */\n  async getEventsByIds(ids: string[]): Promise<MemoryEvent[]> {\n    if (ids.length === 0) return [];\n    const db = await this.getDB();\n    const transaction = db.transaction(['events'], 'readonly');\n    const store = transaction.objectStore('events');\n    const results = new Map<string, MemoryEvent>();\n\n    await Promise.all(\n      ids.map(\n        id =>\n          new Promise<void>((resolve, reject) => {\n            const request = store.get(id);\n            request.onsuccess = () => {\n              if (request.result) {\n                results.set(id, request.result as MemoryEvent);\n              }\n              resolve();\n            };\n            request.onerror = () => reject(request.error);\n          })\n      )\n    );\n\n    return ids.map(id => results.get(id)).filter((event): event is MemoryEvent => Boolean(event));\n  }\n}\n\n// Singleton instance\nexport const superMemoryDB = new SuperMemoryDB();\n\n// Initialize on load\nif (typeof window !== 'undefined') {\n  superMemoryDB.init().catch(error => {\n    console.warn('[SuperMemoryDB] Failed to initialize:', error);\n  });\n}\n","/**\n * Vector Store - Efficient storage and retrieval of vector embeddings\n * Supports similarity search with optional indexing for large datasets\n */\n\nimport type { Embedding } from './embedding';\nimport { generateEmbedding } from './embedding';\n// import { searchEmbeddings as searchEmbeddingsBase } from './embedding'; // Unused for now\nimport { superMemoryDB } from './db';\n\nexport interface VectorSearchResult {\n  embedding: Embedding;\n  similarity: number;\n  metadata?: Record<string, any>;\n}\n\nexport interface VectorStoreOptions {\n  maxVectors?: number; // Maximum vectors to load for search\n  minSimilarity?: number; // Minimum similarity threshold (0-1)\n  chunkSize?: number; // Batch size for operations\n}\n\nclass VectorStore {\n  private cache: Map<string, Embedding> = new Map();\n  private cacheSizeLimit = 1000; // Keep top 1000 most recent in memory\n  private isInitialized = false;\n\n  /**\n   * Initialize vector store\n   */\n  async init(): Promise<void> {\n    if (this.isInitialized) return;\n\n    try {\n      // Pre-load recent embeddings into cache\n      const recentEmbeddings = await superMemoryDB.getAllEmbeddings(100);\n      for (const embedding of recentEmbeddings) {\n        this.cache.set(embedding.id, embedding as Embedding);\n      }\n\n      this.isInitialized = true;\n    } catch (error) {\n      console.warn('[VectorStore] Initialization failed:', error);\n    }\n  }\n\n  /**\n   * Save embedding to store\n   */\n  async save(embedding: Embedding): Promise<void> {\n    // Update cache\n    this.cache.set(embedding.id, embedding);\n\n    // Enforce cache size limit\n    if (this.cache.size > this.cacheSizeLimit) {\n      // Remove oldest entries (FIFO)\n      const entries = Array.from(this.cache.entries());\n      entries.sort((a, b) => a[1].timestamp - b[1].timestamp);\n      \n      const toRemove = entries.slice(0, this.cache.size - this.cacheSizeLimit);\n      for (const [id] of toRemove) {\n        this.cache.delete(id);\n      }\n    }\n\n    // Persist to IndexedDB\n    try {\n      await superMemoryDB.saveEmbedding({\n        id: embedding.id,\n        eventId: embedding.eventId,\n        vector: embedding.vector,\n        text: embedding.text,\n        metadata: embedding.metadata,\n        timestamp: embedding.timestamp,\n      });\n    } catch (error) {\n      console.error('[VectorStore] Failed to save embedding:', error);\n    }\n  }\n\n  /**\n   * Get embedding by ID\n   */\n  async get(id: string): Promise<Embedding | null> {\n    // Check cache first\n    if (this.cache.has(id)) {\n      return this.cache.get(id)!;\n    }\n\n    // Load from IndexedDB\n    try {\n      const dbEmbedding = await superMemoryDB.getEmbedding(id);\n      if (dbEmbedding) {\n        const embedding: Embedding = {\n          id: dbEmbedding.id,\n          eventId: dbEmbedding.eventId,\n          vector: dbEmbedding.vector,\n          text: dbEmbedding.text,\n          metadata: dbEmbedding.metadata,\n          timestamp: dbEmbedding.timestamp,\n        };\n        \n        // Cache it\n        this.cache.set(id, embedding);\n        return embedding;\n      }\n    } catch (error) {\n      console.error('[VectorStore] Failed to get embedding:', error);\n    }\n\n    return null;\n  }\n\n  /**\n   * Delete embedding by ID\n   */\n  async delete(id: string): Promise<boolean> {\n    // Remove from cache\n    this.cache.delete(id);\n\n    // Delete from IndexedDB\n    try {\n      await superMemoryDB.deleteEmbedding(id);\n      return true;\n    } catch (error) {\n      console.error('[VectorStore] Failed to delete embedding:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Delete all embeddings for an event\n   */\n  async deleteByEventId(eventId: string): Promise<number> {\n    let deleted = 0;\n\n    // Find and delete from cache\n    const toDelete: string[] = [];\n    for (const [id, embedding] of this.cache.entries()) {\n      if (embedding.eventId === eventId) {\n        toDelete.push(id);\n      }\n    }\n\n    for (const id of toDelete) {\n      this.cache.delete(id);\n      deleted++;\n    }\n\n    // Delete from IndexedDB\n    try {\n      await superMemoryDB.deleteEmbeddingsByEventId(eventId);\n      deleted++;\n    } catch (error) {\n      console.error('[VectorStore] Failed to delete embeddings by event ID:', error);\n    }\n\n    return deleted;\n  }\n\n  /**\n   * Search for similar vectors\n   * Uses cosine similarity with optional filtering\n   */\n  async search(\n    query: string | number[],\n    options: VectorStoreOptions = {}\n  ): Promise<VectorSearchResult[]> {\n    const { maxVectors = 1000, minSimilarity = 0.0 } = options;\n\n    // Generate query embedding if string provided\n    let queryVector: number[];\n    if (typeof query === 'string') {\n      queryVector = await generateEmbedding(query);\n    } else {\n      queryVector = query;\n    }\n\n    // Load embeddings (with limit for performance)\n    const allEmbeddings: Embedding[] = [];\n\n    // Load from cache first\n    for (const embedding of this.cache.values()) {\n      allEmbeddings.push(embedding);\n    }\n\n    // Load additional from IndexedDB if needed\n    if (allEmbeddings.length < maxVectors) {\n      try {\n        const dbEmbeddings = await superMemoryDB.getAllEmbeddings(maxVectors);\n        for (const dbEmbedding of dbEmbeddings) {\n          const embedding: Embedding = {\n            id: dbEmbedding.id,\n            eventId: dbEmbedding.eventId,\n            vector: dbEmbedding.vector,\n            text: dbEmbedding.text,\n            metadata: dbEmbedding.metadata,\n            timestamp: dbEmbedding.timestamp,\n          };\n\n          // Avoid duplicates\n          if (!this.cache.has(embedding.id)) {\n            this.cache.set(embedding.id, embedding);\n            allEmbeddings.push(embedding);\n          }\n\n          if (allEmbeddings.length >= maxVectors) {\n            break;\n          }\n        }\n      } catch (error) {\n        console.warn('[VectorStore] Failed to load embeddings from IndexedDB:', error);\n      }\n    }\n\n    // Calculate similarities\n    const results: VectorSearchResult[] = allEmbeddings.map((embedding) => {\n      const similarity = this.cosineSimilarity(queryVector, embedding.vector);\n      return {\n        embedding,\n        similarity,\n        metadata: embedding.metadata,\n      };\n    });\n\n    // Filter by minimum similarity and sort\n    const filtered = results\n      .filter((r) => r.similarity >= minSimilarity)\n      .sort((a, b) => b.similarity - a.similarity);\n\n    return filtered;\n  }\n\n  /**\n   * Calculate cosine similarity between two vectors\n   */\n  private cosineSimilarity(a: number[], b: number[]): number {\n    if (a.length !== b.length) {\n      return 0;\n    }\n\n    let dotProduct = 0;\n    let normA = 0;\n    let normB = 0;\n\n    for (let i = 0; i < a.length; i++) {\n      dotProduct += a[i] * b[i];\n      normA += a[i] * a[i];\n      normB += b[i] * b[i];\n    }\n\n    if (normA === 0 || normB === 0) {\n      return 0;\n    }\n\n    return dotProduct / (Math.sqrt(normA) * Math.sqrt(normB));\n  }\n\n  /**\n   * Get vector count\n   */\n  async count(): Promise<number> {\n    try {\n      // Get count from IndexedDB\n      const count = await superMemoryDB.getEmbeddingCount();\n      return count || this.cache.size;\n    } catch {\n      // Fallback to cache size\n      return this.cache.size;\n    }\n  }\n\n  /**\n   * Batch save embeddings\n   */\n  async batchSave(embeddings: Embedding[]): Promise<void> {\n    const batch = embeddings.slice(0, 100); // Process in batches\n\n    for (const embedding of batch) {\n      await this.save(embedding);\n    }\n\n    if (embeddings.length > 100) {\n      // Process remaining in next batch\n      await this.batchSave(embeddings.slice(100));\n    }\n  }\n\n  /**\n   * Clear all embeddings (use with caution)\n   */\n  async clear(): Promise<void> {\n    this.cache.clear();\n\n    try {\n      await superMemoryDB.clearEmbeddings();\n    } catch (error) {\n      console.error('[VectorStore] Failed to clear embeddings:', error);\n    }\n  }\n\n  /**\n   * Get statistics\n   */\n  async getStats(): Promise<{\n    totalVectors: number;\n    cachedVectors: number;\n    avgVectorDimension: number;\n  }> {\n    const total = await this.count();\n    const cached = this.cache.size;\n\n    // Calculate average dimension from cache\n    let totalDimensions = 0;\n    let count = 0;\n    for (const embedding of this.cache.values()) {\n      totalDimensions += embedding.vector.length;\n      count++;\n    }\n\n    const avgDimension = count > 0 ? totalDimensions / count : 0;\n\n    return {\n      totalVectors: total,\n      cachedVectors: cached,\n      avgVectorDimension: avgDimension,\n    };\n  }\n}\n\n// Singleton instance\nexport const vectorStore = new VectorStore();\n\n// Initialize on module load\nvectorStore.init().catch(console.warn);\n\n// Export convenience functions\nexport const searchVectors = (\n  query: string | number[],\n  options?: VectorStoreOptions\n) => vectorStore.search(query, options);\nexport const saveVector = (embedding: Embedding) => vectorStore.save(embedding);\nexport const getVector = (id: string) => vectorStore.get(id);\nexport const deleteVector = (id: string) => vectorStore.delete(id);\nexport const getVectorCount = () => vectorStore.count();\nexport const getVectorStats = () => vectorStore.getStats();\n\n","import type { MemoryEvent } from './event-types';\r\nimport { MemoryStoreInstance } from './store';\r\nimport { searchVectors, VectorSearchResult } from './vectorStore';\r\n\r\nexport interface SemanticMemoryMatch {\r\n  event: MemoryEvent;\r\n  similarity: number;\r\n  embeddingId: string;\r\n  chunkText?: string;\r\n}\r\n\r\nexport interface SemanticSearchOptions {\r\n  limit?: number;\r\n  minSimilarity?: number;\r\n}\r\n\r\nexport async function semanticSearchMemories(\r\n  query: string,\r\n  options: SemanticSearchOptions = {}\r\n): Promise<SemanticMemoryMatch[]> {\r\n  const { limit = 12, minSimilarity = 0.55 } = options;\r\n  const vectorResults = await searchVectors(query, {\r\n    maxVectors: limit * 4,\r\n    minSimilarity,\r\n  });\r\n\r\n  if (vectorResults.length === 0) {\r\n    return [];\r\n  }\r\n\r\n  const events = await hydrateEvents(vectorResults, limit);\r\n  return events;\r\n}\r\n\r\nasync function hydrateEvents(\r\n  vectorResults: VectorSearchResult[],\r\n  limit: number\r\n): Promise<SemanticMemoryMatch[]> {\r\n  const uniqueEventIds: string[] = [];\r\n  const seen = new Set<string>();\r\n  for (const result of vectorResults) {\r\n    if (!seen.has(result.embedding.eventId)) {\r\n      uniqueEventIds.push(result.embedding.eventId);\r\n      seen.add(result.embedding.eventId);\r\n      if (uniqueEventIds.length >= limit) {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  const events = await MemoryStoreInstance.getEventsByIds(uniqueEventIds);\r\n  const eventMap = new Map(events.map(event => [event.id, event]));\r\n\r\n  const matches: SemanticMemoryMatch[] = [];\r\n  for (const result of vectorResults) {\r\n    if (matches.length >= limit) break;\r\n    const event = eventMap.get(result.embedding.eventId);\r\n    if (!event) continue;\r\n    matches.push({\r\n      event,\r\n      similarity: result.similarity,\r\n      embeddingId: result.embedding.id,\r\n      chunkText: result.embedding.text,\r\n    });\r\n  }\r\n\r\n  return matches;\r\n}\r\n\r\n\r\n","/**\r\n * Tag extractor for SuperMemory events.\r\n * Lightweight keyword extraction for local-first tagging.\r\n */\r\n\r\nimport type { MemoryEvent } from './event-types';\r\n\r\nconst STOP_WORDS = new Set([\r\n  'the','and','for','with','this','that','from','about','into','there','their','them',\r\n  'your','have','more','will','what','when','where','which','using','used','been',\r\n  'than','then','over','after','before','because','while','within','without','such',\r\n  'also','only','even','much','many','some','any','each','most','very','like','just',\r\n  'onto','upon','here','time','date','page','tab','mode','note','visit'\r\n]);\r\n\r\nconst TAG_LIMIT = 6;\r\n\r\nexport function extractTagsFromText(text: string, limit: number = TAG_LIMIT): string[] {\r\n  if (!text) return [];\r\n  const tokens = text\r\n    .toLowerCase()\r\n    .replace(/[^a-z0-9\\s]/g, ' ')\r\n    .split(/\\s+/)\r\n    .filter(Boolean)\r\n    .filter(token => token.length > 2 && !STOP_WORDS.has(token));\r\n\r\n  const counts = new Map<string, number>();\r\n  for (const token of tokens) {\r\n    counts.set(token, (counts.get(token) || 0) + 1);\r\n  }\r\n\r\n  return Array.from(counts.entries())\r\n    .sort((a, b) => b[1] - a[1])\r\n    .slice(0, limit)\r\n    .map(([token]) => token);\r\n}\r\n\r\nexport function extractTagsFromEvent(event: Omit<MemoryEvent, 'id' | 'ts' | 'score'>): string[] {\r\n  const candidateTexts: string[] = [];\r\n  if (typeof event.value === 'string') {\r\n    candidateTexts.push(event.value);\r\n  }\r\n  if (typeof event.metadata?.title === 'string') {\r\n    candidateTexts.push(event.metadata.title);\r\n  }\r\n  if (typeof event.metadata?.notePreview === 'string') {\r\n    candidateTexts.push(event.metadata.notePreview);\r\n  }\r\n  if (typeof event.metadata?.url === 'string') {\r\n    candidateTexts.push(event.metadata.url.replace(/^https?:\\/\\//, '').split(/[/?#]/)[0]);\r\n  }\r\n\r\n  const combined = candidateTexts.join(' ');\r\n  return extractTagsFromText(combined);\r\n}\r\n\r\n\r\n","/**\r\n * SuperMemory Pipeline - Write → Embed → Store\r\n * Orchestrates the complete flow of saving events and generating embeddings\r\n */\r\n\r\nimport { MemoryEvent } from './tracker';\r\nimport { MemoryStoreInstance } from './store';\r\nimport { embedMemoryEvent } from './embedding';\r\nimport { superMemoryDB } from './db';\r\nimport { extractTagsFromEvent } from './tag-extractor';\r\n\r\nexport interface PipelineResult {\r\n  eventId: string;\r\n  embeddingIds: string[];\r\n  success: boolean;\r\n  error?: string;\r\n}\r\n\r\n/**\r\n * Complete pipeline: Save event → Generate embeddings → Store vectors\r\n */\r\nexport async function processMemoryEvent(\r\n  event: Omit<MemoryEvent, 'id' | 'ts' | 'score'>\r\n): Promise<PipelineResult> {\r\n  try {\r\n    const enrichedEvent = applyAutoTags(event);\r\n\r\n    // Step 1: Save event to database\r\n    const eventId = await MemoryStoreInstance.saveEvent(enrichedEvent);\r\n    \r\n    // Step 2: Retrieve stored event for embedding (ensures ts/score match)\r\n    const fullEvent =\r\n      (await MemoryStoreInstance.getEventById(eventId)) ??\r\n      ({\r\n        ...enrichedEvent,\r\n        id: eventId,\r\n        ts: Date.now(),\r\n        score: 0,\r\n      } as MemoryEvent);\r\n    \r\n    // Step 3: Generate and store embeddings\r\n    let embeddingIds: string[] = [];\r\n    try {\r\n      embeddingIds = await embedMemoryEvent(fullEvent);\r\n    } catch (embedError) {\r\n      console.warn('[Pipeline] Failed to generate embeddings, continuing without them:', embedError);\r\n      // Continue even if embedding fails - event is still saved\r\n    }\r\n    \r\n    return {\r\n      eventId,\r\n      embeddingIds,\r\n      success: true,\r\n    };\r\n  } catch (error) {\r\n    const errorMessage = error instanceof Error ? error.message : String(error);\r\n    console.error('[Pipeline] Failed to process memory event:', error);\r\n    \r\n    return {\r\n      eventId: '',\r\n      embeddingIds: [],\r\n      success: false,\r\n      error: errorMessage,\r\n    };\r\n  }\r\n}\r\n\r\n/**\r\n * Batch process multiple events\r\n */\r\nexport async function batchProcessEvents(\r\n  events: Array<Omit<MemoryEvent, 'id' | 'ts' | 'score'>>\r\n): Promise<PipelineResult[]> {\r\n  const results: PipelineResult[] = [];\r\n  \r\n  // Process in parallel (with concurrency limit to avoid overwhelming the system)\r\n  const CONCURRENCY = 5;\r\n  for (let i = 0; i < events.length; i += CONCURRENCY) {\r\n    const batch = events.slice(i, i + CONCURRENCY);\r\n    const batchResults = await Promise.all(\r\n      batch.map(event => processMemoryEvent(event))\r\n    );\r\n    results.push(...batchResults);\r\n  }\r\n  \r\n  return results;\r\n}\r\n\r\n/**\r\n * Re-embed existing events (useful for migration or when embedding model changes)\r\n */\r\nexport async function reembedEvents(\r\n  eventIds?: string[],\r\n  filters?: { type?: MemoryEvent['type']; since?: number }\r\n): Promise<{ processed: number; errors: number }> {\r\n  try {\r\n    // Get events to re-embed\r\n    const events = await MemoryStoreInstance.getEvents(filters);\r\n    const eventsToProcess = eventIds\r\n      ? events.filter((e: MemoryEvent) => eventIds.includes(e.id))\r\n      : events;\r\n    \r\n    let processed = 0;\r\n    let errors = 0;\r\n    \r\n    // Delete old embeddings and regenerate\r\n    for (const event of eventsToProcess) {\r\n      try {\r\n        // Delete old embeddings\r\n        await superMemoryDB.deleteEmbeddingsForEvent(event.id);\r\n        \r\n        // Generate new embeddings\r\n        await embedMemoryEvent(event);\r\n        processed++;\r\n      } catch (error) {\r\n        console.warn(`[Pipeline] Failed to re-embed event ${event.id}:`, error);\r\n        errors++;\r\n      }\r\n    }\r\n    \r\n    return { processed, errors };\r\n  } catch (error) {\r\n    console.error('[Pipeline] Failed to re-embed events:', error);\r\n    return { processed: 0, errors: 1 };\r\n  }\r\n}\r\n\r\n/**\r\n * Cleanup pipeline: Remove old events and their embeddings\r\n */\r\nexport async function cleanupOldData(daysToKeep: number = 90): Promise<void> {\r\n  try {\r\n    await superMemoryDB.cleanupOldData(daysToKeep);\r\n  } catch (error) {\r\n    console.error('[Pipeline] Failed to cleanup old data:', error);\r\n  }\r\n}\r\n\r\nfunction applyAutoTags(event: Omit<MemoryEvent, 'id' | 'ts' | 'score'>): Omit<MemoryEvent, 'id' | 'ts' | 'score'> {\r\n  const tags = extractTagsFromEvent(event);\r\n  if (tags.length === 0) {\r\n    return event;\r\n  }\r\n\r\n  const existing = Array.isArray(event.metadata?.tags) ? event.metadata!.tags : [];\r\n  const mergedTags = Array.from(new Set([...existing, ...tags])).slice(0, 10);\r\n\r\n  return {\r\n    ...event,\r\n    metadata: {\r\n      ...(event.metadata || {}),\r\n      tags: mergedTags,\r\n    },\r\n  };\r\n}\r\n\r\n/**\r\n * Get pipeline statistics\r\n */\r\nexport async function getPipelineStats(): Promise<{\r\n  eventCount: number;\r\n  embeddingCount: number;\r\n  totalSize: number;\r\n  avgEmbeddingsPerEvent: number;\r\n}> {\r\n  try {\r\n    const stats = await superMemoryDB.getStats();\r\n    const events = await MemoryStoreInstance.getEvents({ limit: 100 });\r\n    \r\n    // Calculate average embeddings per event\r\n    let totalEmbeddings = 0;\r\n    for (const event of events) {\r\n      const embeddings = await superMemoryDB.getEmbeddingsForEvent(event.id);\r\n      totalEmbeddings += embeddings.length;\r\n    }\r\n    const avgEmbeddingsPerEvent = events.length > 0\r\n      ? totalEmbeddings / events.length\r\n      : 0;\r\n    \r\n    return {\r\n      ...stats,\r\n      avgEmbeddingsPerEvent,\r\n    };\r\n  } catch (error) {\r\n    console.error('[Pipeline] Failed to get stats:', error);\r\n    return {\r\n      eventCount: 0,\r\n      embeddingCount: 0,\r\n      totalSize: 0,\r\n      avgEmbeddingsPerEvent: 0,\r\n    };\r\n  }\r\n}\r\n\r\n","/**\n * SuperMemory Event Tracker\n * Tracks user behavior events for personalization\n */\n\n// import { MemoryStore } from './store'; // Unused for now\nimport { processMemoryEvent } from './pipeline';\nimport type { MemoryEvent, SearchEventMetadata, VisitEventMetadata, HighlightEventMetadata, ScreenshotEventMetadata, NoteEventMetadata } from './event-types';\n\n// Re-export types for convenience\nexport type { MemoryEvent, SearchEventMetadata, VisitEventMetadata, HighlightEventMetadata, ScreenshotEventMetadata, NoteEventMetadata } from './event-types';\n\n// Deduplication: track recent events to prevent duplicates\nconst recentEvents = new Map<string, number>(); // key -> timestamp\nconst DEDUP_WINDOW_MS = 1000; // 1 second window for deduplication\n\n/**\n * Generate deduplication key for an event\n */\nfunction getDedupKey(event: Omit<MemoryEvent, 'id' | 'ts' | 'score'>): string {\n  return `${event.type}:${JSON.stringify(event.value)}:${JSON.stringify(event.metadata || {})}`;\n}\n\n/**\n * Check if event is a duplicate (same event within dedup window)\n */\nfunction isDuplicate(event: Omit<MemoryEvent, 'id' | 'ts' | 'score'>): boolean {\n  const key = getDedupKey(event);\n  const lastTime = recentEvents.get(key);\n  const now = Date.now();\n  \n  if (lastTime && (now - lastTime) < DEDUP_WINDOW_MS) {\n    return true; // Duplicate within window\n  }\n  \n  // Update last seen time\n  recentEvents.set(key, now);\n  \n  // Cleanup old entries (older than 5 seconds)\n  for (const [k, t] of recentEvents.entries()) {\n    if (now - t > 5000) {\n      recentEvents.delete(k);\n    }\n  }\n  \n  return false;\n}\n\n/**\n * Track a user event\n */\nexport async function trackUserEvent(event: Omit<MemoryEvent, 'id' | 'ts' | 'score'>): Promise<string> {\n  // Check for duplicates\n  if (isDuplicate(event)) {\n    // Return existing event ID (we'd need to look it up, but for now just skip)\n    return '';\n  }\n  \n  // Use pipeline for complete write→embed→store flow\n  const result = await processMemoryEvent(event);\n  \n  if (!result.success) {\n    console.warn('[SuperMemory] Failed to process event:', result.error);\n    return '';\n  }\n  \n  return result.eventId;\n}\n\n/**\n * Track a search query\n */\nexport async function trackSearch(\n  query: string, \n  metadata?: Partial<SearchEventMetadata>\n): Promise<string> {\n  return trackUserEvent({\n    type: 'search',\n    value: query,\n    metadata: {\n      query,\n      ...metadata,\n    } as SearchEventMetadata,\n  });\n}\n\n/**\n * Track a page visit\n * Enhanced with duration and interaction tracking\n */\nexport async function trackVisit(\n  url: string, \n  title?: string, \n  metadata?: Partial<VisitEventMetadata>\n): Promise<string> {\n  return trackUserEvent({\n    type: 'visit',\n    value: url,\n    metadata: {\n      url,\n      title,\n      ...metadata,\n    } as VisitEventMetadata,\n  });\n}\n\n/**\n * Track a mode switch\n */\nexport async function trackModeSwitch(mode: string): Promise<string> {\n  return trackUserEvent({\n    type: 'mode_switch',\n    value: mode,\n    metadata: { mode },\n  });\n}\n\n/**\n * Track a bookmark\n */\nexport async function trackBookmark(url: string, metadata?: { title?: string }): Promise<string> {\n  return trackUserEvent({\n    type: 'bookmark',\n    value: url,\n    metadata: { url, ...metadata },\n  });\n}\n\n/**\n * Track a note\n * Enhanced with preview and tags\n */\nexport async function trackNote(\n  url: string, \n  metadata?: Partial<NoteEventMetadata>\n): Promise<string> {\n  const noteText = metadata?.notePreview || '';\n  return trackUserEvent({\n    type: 'note',\n    value: url,\n    metadata: {\n      url,\n      noteLength: noteText.length,\n      notePreview: noteText.substring(0, 200),\n      ...metadata,\n    } as NoteEventMetadata,\n  });\n}\n\n/**\n * Track a prefetch action\n */\nexport async function trackPrefetch(url: string, metadata?: { success?: boolean }): Promise<string> {\n  return trackUserEvent({\n    type: 'prefetch',\n    value: url,\n    metadata: { url, ...metadata },\n  });\n}\n\n/**\n * Track a custom action\n */\nexport async function trackAction(action: string, metadata?: Record<string, any>): Promise<string> {\n  return trackUserEvent({\n    type: 'action',\n    value: action,\n    metadata,\n  });\n}\n\n/**\n * Track a text highlight\n * Enhanced with position and context tracking\n */\nexport async function trackHighlight(\n  url: string,\n  text: string,\n  metadata?: Partial<HighlightEventMetadata>\n): Promise<string> {\n  return trackUserEvent({\n    type: 'highlight',\n    value: text,\n    metadata: {\n      url,\n      text,\n      ...metadata,\n    } as HighlightEventMetadata,\n  });\n}\n\n/**\n * Track a screenshot capture\n * Enhanced with size and format tracking\n */\nexport async function trackScreenshot(\n  url: string,\n  metadata?: Partial<ScreenshotEventMetadata>\n): Promise<string> {\n  return trackUserEvent({\n    type: 'screenshot',\n    value: url,\n    metadata: {\n      url,\n      ...metadata,\n    } as ScreenshotEventMetadata,\n  });\n}\n\n/**\n * Track a task (todo item)\n */\nexport async function trackTask(\n  task: string,\n  metadata?: { completed?: boolean; priority?: 'low' | 'medium' | 'high'; dueDate?: number; url?: string }\n): Promise<string> {\n  return trackUserEvent({\n    type: 'task',\n    value: task,\n    metadata: { ...metadata },\n  });\n}\n\n/**\n * Track an agent action\n */\nexport async function trackAgent(\n  action: string,\n  metadata?: { runId?: string; skill?: string; result?: any; error?: string; url?: string }\n): Promise<string> {\n  return trackUserEvent({\n    type: 'agent',\n    value: action,\n    metadata: { ...metadata },\n  });\n}\n\n","/**\n * Hugging Face Embedding Integration\n * Uses Hugging Face Inference API for semantic embeddings\n */\n\n// import { MemoryStoreInstance } from './store'; // Unused for now\n// import { MemoryEvent } from './tracker'; // Unused for now\n// import { Embedding } from './embedding'; // Unused for now\n\nconst HUGGINGFACE_API_URL = 'http://localhost:8000/huggingface'; // Backend API URL\nconst DEFAULT_MODEL = 'sentence-transformers/all-MiniLM-L6-v2';\nconst EMBEDDING_DIMENSIONS = 384; // all-MiniLM-L6-v2 produces 384-dim embeddings\n\n/**\n * Generate embedding using Hugging Face API\n */\nexport async function generateHuggingFaceEmbedding(\n  text: string,\n  model: string = DEFAULT_MODEL\n): Promise<number[]> {\n  try {\n    const response = await fetch(`${HUGGINGFACE_API_URL}/embedding`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        text,\n        model,\n      }),\n    });\n\n    if (!response.ok) {\n      const error = await response.text();\n      throw new Error(`Hugging Face API error: ${error}`);\n    }\n\n    const data = await response.json();\n    return data.embedding as number[];\n  } catch (error) {\n    console.error('[HuggingFace] Failed to generate embedding:', error);\n    // Fallback to hash-based embedding if API fails\n    return generateFallbackEmbedding(text);\n  }\n}\n\n/**\n * Generate batch embeddings using Hugging Face API\n */\nexport async function batchGenerateEmbeddings(\n  texts: string[],\n  model: string = DEFAULT_MODEL\n): Promise<number[][]> {\n  try {\n    const response = await fetch(`${HUGGINGFACE_API_URL}/embedding/batch`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        texts,\n        model,\n      }),\n    });\n\n    if (!response.ok) {\n      const error = await response.text();\n      throw new Error(`Hugging Face API error: ${error}`);\n    }\n\n    const data = await response.json();\n    return data.embeddings as number[][];\n  } catch (error) {\n    console.error('[HuggingFace] Failed to generate batch embeddings:', error);\n    // Fallback to hash-based embeddings\n    return Promise.all(texts.map(text => generateFallbackEmbedding(text)));\n  }\n}\n\n/**\n * Fallback hash-based embedding (used when API is unavailable)\n */\nfunction generateFallbackEmbedding(text: string): number[] {\n  const vector: number[] = new Array(EMBEDDING_DIMENSIONS).fill(0);\n  const words = text.toLowerCase().split(/\\s+/);\n  \n  for (let i = 0; i < words.length; i++) {\n    const word = words[i];\n    let hash = 0;\n    for (let j = 0; j < word.length; j++) {\n      hash = ((hash << 5) - hash) + word.charCodeAt(j);\n      hash = hash & hash; // Convert to 32-bit integer\n    }\n    \n    const dim = Math.abs(hash) % EMBEDDING_DIMENSIONS;\n    vector[dim] += 1 / (i + 1); // Weight by position\n  }\n\n  // Normalize vector\n  const magnitude = Math.sqrt(vector.reduce((sum, val) => sum + val * val, 0));\n  if (magnitude > 0) {\n    for (let i = 0; i < vector.length; i++) {\n      vector[i] /= magnitude;\n    }\n  }\n\n  return vector;\n}\n\n/**\n * Check if Hugging Face API is available\n */\nexport async function checkHuggingFaceAvailable(): Promise<boolean> {\n  try {\n    const response = await fetch(`${HUGGINGFACE_API_URL}/status`, {\n      method: 'GET',\n    });\n    \n    if (!response.ok) {\n      return false;\n    }\n    \n    const data = await response.json();\n    return data.available === true;\n  } catch (error) {\n    console.debug('[HuggingFace] API check failed:', error);\n    return false;\n  }\n}\n\n","/**\n * Memory Summarizer\n * Automatically compresses and summarizes memory events\n * Runs nightly to create summaries of old events\n */\n\nimport { MemoryEvent } from './store';\nimport { superMemoryDB } from './db';\n\nexport interface MemorySummary {\n  id: string;\n  type: 'daily' | 'weekly' | 'monthly';\n  periodStart: number;\n  periodEnd: number;\n  summary: string;\n  eventCount: number;\n  eventIds: string[]; // IDs of events that were summarized\n  tags: string[];\n  createdAt: number;\n}\n\n// const SUMMARY_STORE = 'summaries'; // Unused for now\n\n/**\n * Summarize events using AI (via backend)\n */\nasync function summarizeEventsWithAI(events: MemoryEvent[]): Promise<string> {\n  try {\n    // Group events by type\n    const eventsByType = new Map<string, MemoryEvent[]>();\n    for (const event of events) {\n      const type = event.type;\n      if (!eventsByType.has(type)) {\n        eventsByType.set(type, []);\n      }\n      eventsByType.get(type)!.push(event);\n    }\n\n    // Build summary context\n    const contextParts: string[] = [];\n    for (const [type, typeEvents] of eventsByType.entries()) {\n      contextParts.push(`\\n${type} events (${typeEvents.length}):`);\n      for (const event of typeEvents.slice(0, 10)) { // Limit to 10 per type\n        const value = typeof event.value === 'string' ? event.value : JSON.stringify(event.value);\n        const title = event.metadata?.title || event.metadata?.url || value;\n        contextParts.push(`- ${title}`);\n      }\n      if (typeEvents.length > 10) {\n        contextParts.push(`... and ${typeEvents.length - 10} more`);\n      }\n    }\n\n    const context = contextParts.join('\\n');\n\n    // Call AI backend for summarization\n    try {\n      // Try OpenAI/Hugging Face/Ollama endpoint\n      const apiUrl = process.env.VITE_API_URL || 'http://localhost:8000';\n      \n      // First try the /redix/ask endpoint\n      const response = await fetch(`${apiUrl}/redix/ask`, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({\n          prompt: `You are a personal memory assistant. Summarize these memory events in 2-3 concise sentences, highlighting key activities, patterns, and insights:\\n\\n${context}\\n\\nProvide a natural, human-readable summary.`,\n          stream: false,\n          session_id: 'memory-summarizer',\n        }),\n      });\n\n      if (response.ok) {\n        const data = await response.json();\n        const summary = data.response || data.text || data.answer || '';\n        if (summary && summary.length > 20) {\n          return summary;\n        }\n      }\n      \n      // Fallback: Try OpenAI endpoint directly\n      try {\n        const openaiResponse = await fetch(`${apiUrl}/openai/chat`, {\n          method: 'POST',\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify({\n            messages: [\n              {\n                role: 'system',\n                content: 'You are a personal memory assistant that creates concise, insightful summaries of user activities.',\n              },\n              {\n                role: 'user',\n                content: `Summarize these memory events in 2-3 sentences:\\n\\n${context}`,\n              },\n            ],\n            model: 'gpt-4o-mini',\n            temperature: 0.5,\n          }),\n        });\n        \n        if (openaiResponse.ok) {\n          const openaiData = await openaiResponse.json();\n          const summary = openaiData.response || openaiData.text || '';\n          if (summary && summary.length > 20) {\n            return summary;\n          }\n        }\n      } catch (openaiError) {\n        console.debug('[Summarizer] OpenAI endpoint failed:', openaiError);\n      }\n    } catch (error) {\n      console.warn('[Summarizer] AI summarization failed, using fallback:', error);\n    }\n\n    // Fallback: Simple text summary\n    return generateFallbackSummary(events);\n  } catch (error) {\n    console.error('[Summarizer] Summarization failed:', error);\n    return generateFallbackSummary(events);\n  }\n}\n\n/**\n * Generate a simple fallback summary without AI\n */\nfunction generateFallbackSummary(events: MemoryEvent[]): string {\n  const eventsByType = new Map<string, number>();\n  const urls = new Set<string>();\n  const queries = new Set<string>();\n\n  for (const event of events) {\n    eventsByType.set(event.type, (eventsByType.get(event.type) || 0) + 1);\n    if (event.metadata?.url) {\n      urls.add(event.metadata.url);\n    }\n    if (event.type === 'search' && typeof event.value === 'string') {\n      queries.add(event.value);\n    }\n  }\n\n  const parts: string[] = [];\n  parts.push(`Summary of ${events.length} events:`);\n  \n  for (const [type, count] of eventsByType.entries()) {\n    parts.push(`${count} ${type} events`);\n  }\n  \n  if (urls.size > 0) {\n    parts.push(`${urls.size} unique URLs visited`);\n  }\n  \n  if (queries.size > 0) {\n    parts.push(`${queries.size} search queries`);\n  }\n\n  return parts.join('. ') + '.';\n}\n\n/**\n * Compress events by creating a summary and removing old events\n */\nexport async function compressEvents(\n  events: MemoryEvent[],\n  summaryType: 'daily' | 'weekly' | 'monthly' = 'daily',\n): Promise<MemorySummary> {\n  if (events.length === 0) {\n    throw new Error('No events to compress');\n  }\n\n  // Sort events by timestamp\n  const sortedEvents = [...events].sort((a, b) => a.ts - b.ts);\n  const periodStart = sortedEvents[0].ts;\n  const periodEnd = sortedEvents[sortedEvents.length - 1].ts;\n\n  // Generate summary\n  const summaryText = await summarizeEventsWithAI(sortedEvents);\n\n  // Extract tags from events\n  const allTags = new Set<string>();\n  for (const event of sortedEvents) {\n    if (event.metadata?.tags) {\n      for (const tag of event.metadata.tags) {\n        allTags.add(tag);\n      }\n    }\n  }\n\n  // Create summary record\n  const summary: MemorySummary = {\n    id: `summary-${periodStart}-${periodEnd}`,\n    type: summaryType,\n    periodStart,\n    periodEnd,\n    summary: summaryText,\n    eventCount: sortedEvents.length,\n    eventIds: sortedEvents.map(e => e.id),\n    tags: Array.from(allTags),\n    createdAt: Date.now(),\n  };\n\n  // Save summary to IndexedDB\n  await saveSummary(summary);\n\n  return summary;\n}\n\n/**\n * Save summary to IndexedDB\n */\nasync function saveSummary(summary: MemorySummary): Promise<void> {\n  try {\n    await superMemoryDB.init();\n    const db = (superMemoryDB as any).db;\n    if (!db) {\n      throw new Error('Database not initialized');\n    }\n    \n    // Use IndexedDB for summaries (add summaries store if needed)\n    return new Promise((resolve, reject) => {\n      const transaction = db.transaction(['events'], 'readwrite');\n      const store = transaction.objectStore('events');\n      \n      // Store summary as a special event type\n      const summaryEvent = {\n        id: summary.id,\n        type: 'summary' as any, // Special type for summaries\n        value: summary.summary,\n        metadata: {\n          summaryType: summary.type,\n          periodStart: summary.periodStart,\n          periodEnd: summary.periodEnd,\n          eventCount: summary.eventCount,\n          eventIds: summary.eventIds,\n          tags: summary.tags,\n        },\n        ts: summary.createdAt,\n        score: 1.0, // High score for summaries\n      };\n      \n      const request = store.put(summaryEvent);\n      request.onsuccess = () => {\n        // Also save to localStorage for quick access\n        try {\n          const summaries = JSON.parse(localStorage.getItem('sm-summaries') || '[]');\n          summaries.push(summary);\n          // Keep only last 100 summaries\n          if (summaries.length > 100) {\n            summaries.splice(0, summaries.length - 100);\n          }\n          localStorage.setItem('sm-summaries', JSON.stringify(summaries));\n        } catch (e) {\n          console.warn('[Summarizer] Failed to save to localStorage:', e);\n        }\n        resolve();\n      };\n      request.onerror = () => reject(request.error);\n    });\n  } catch (error) {\n    console.error('[Summarizer] Failed to save summary:', error);\n    // Fallback to localStorage\n    try {\n      const summaries = JSON.parse(localStorage.getItem('sm-summaries') || '[]');\n      summaries.push(summary);\n      if (summaries.length > 100) {\n        summaries.splice(0, summaries.length - 100);\n      }\n      localStorage.setItem('sm-summaries', JSON.stringify(summaries));\n    } catch (e) {\n      console.error('[Summarizer] Failed to save summary to localStorage:', e);\n    }\n  }\n}\n\n/**\n * Get all summaries\n */\nexport async function getSummaries(limit?: number): Promise<MemorySummary[]> {\n  try {\n    const summaries = JSON.parse(localStorage.getItem('sm-summaries') || '[]');\n    const sorted = summaries.sort((a: MemorySummary, b: MemorySummary) => b.createdAt - a.createdAt);\n    return limit ? sorted.slice(0, limit) : sorted;\n  } catch (error) {\n    console.error('[Summarizer] Failed to get summaries:', error);\n    return [];\n  }\n}\n\n/**\n * Run nightly summarization\n * Should be called once per day\n */\nexport async function runNightlySummarization(): Promise<{\n  success: boolean;\n  summariesCreated: number;\n  eventsCompressed: number;\n}> {\n  try {\n    const now = Date.now();\n    const oneDayAgo = now - (24 * 60 * 60 * 1000);\n    const oneWeekAgo = now - (7 * 24 * 60 * 60 * 1000);\n    const oneMonthAgo = now - (30 * 24 * 60 * 60 * 1000);\n\n    // Get old events (older than 7 days, not pinned)\n    const oldEvents = await superMemoryDB.getEvents({\n      until: oneWeekAgo,\n      limit: 1000,\n    });\n\n    // Filter out pinned events\n    const eventsToCompress = oldEvents.filter(e => !e.metadata?.pinned);\n\n    if (eventsToCompress.length === 0) {\n      return { success: true, summariesCreated: 0, eventsCompressed: 0 };\n    }\n\n    // Group events by time period\n    const dailyEvents: MemoryEvent[] = [];\n    const weeklyEvents: MemoryEvent[] = [];\n    const monthlyEvents: MemoryEvent[] = [];\n\n    for (const event of eventsToCompress) {\n      if (event.ts >= oneDayAgo) {\n        // Shouldn't happen (we filtered until oneWeekAgo), but just in case\n        continue;\n      } else if (event.ts >= oneWeekAgo) {\n        // Between 1 week and 1 day ago - compress to daily summary\n        dailyEvents.push(event);\n      } else if (event.ts >= oneMonthAgo) {\n        // Between 1 month and 1 week ago - compress to weekly summary\n        weeklyEvents.push(event);\n      } else {\n        // Older than 1 month - compress to monthly summary\n        monthlyEvents.push(event);\n      }\n    }\n\n    let summariesCreated = 0;\n    let eventsCompressed = 0;\n\n    // Compress daily events (group by day)\n    if (dailyEvents.length > 0) {\n      const eventsByDay = new Map<number, MemoryEvent[]>();\n      for (const event of dailyEvents) {\n        const dayStart = new Date(event.ts).setHours(0, 0, 0, 0);\n        if (!eventsByDay.has(dayStart)) {\n          eventsByDay.set(dayStart, []);\n        }\n        eventsByDay.get(dayStart)!.push(event);\n      }\n\n      for (const [dayStart, dayEvents] of eventsByDay.entries()) {\n        // Compress if 5+ events (lowered threshold for better compression)\n        if (dayEvents.length >= 5) {\n          try {\n            await compressEvents(dayEvents, 'daily');\n            summariesCreated++;\n            eventsCompressed += dayEvents.length;\n            \n            // Delete compressed events (keep summary)\n            for (const event of dayEvents) {\n              await superMemoryDB.deleteEvent(event.id);\n            }\n          } catch (error) {\n            console.error(`[Summarizer] Failed to compress daily events for ${new Date(dayStart).toISOString()}:`, error);\n          }\n        }\n      }\n    }\n\n    // Compress weekly events (group by week)\n    if (weeklyEvents.length > 0) {\n      const eventsByWeek = new Map<number, MemoryEvent[]>();\n      for (const event of weeklyEvents) {\n        const weekStart = new Date(event.ts);\n        weekStart.setDate(weekStart.getDate() - weekStart.getDay()); // Start of week\n        weekStart.setHours(0, 0, 0, 0);\n        const weekStartTs = weekStart.getTime();\n        \n        if (!eventsByWeek.has(weekStartTs)) {\n          eventsByWeek.set(weekStartTs, []);\n        }\n        eventsByWeek.get(weekStartTs)!.push(event);\n      }\n\n      for (const [weekStart, weekEvents] of eventsByWeek.entries()) {\n        // Compress if 10+ events (lowered threshold)\n        if (weekEvents.length >= 10) {\n          try {\n            await compressEvents(weekEvents, 'weekly');\n            summariesCreated++;\n            eventsCompressed += weekEvents.length;\n            \n            // Delete compressed events\n            for (const event of weekEvents) {\n              await superMemoryDB.deleteEvent(event.id);\n            }\n          } catch (error) {\n            console.error(`[Summarizer] Failed to compress weekly events for ${new Date(weekStart).toISOString()}:`, error);\n          }\n        }\n      }\n    }\n\n    // Compress monthly events (group by month)\n    if (monthlyEvents.length > 0) {\n      const eventsByMonth = new Map<number, MemoryEvent[]>();\n      for (const event of monthlyEvents) {\n        const monthStart = new Date(event.ts);\n        monthStart.setDate(1);\n        monthStart.setHours(0, 0, 0, 0);\n        const monthStartTs = monthStart.getTime();\n        \n        if (!eventsByMonth.has(monthStartTs)) {\n          eventsByMonth.set(monthStartTs, []);\n        }\n        eventsByMonth.get(monthStartTs)!.push(event);\n      }\n\n      for (const [monthStart, monthEvents] of eventsByMonth.entries()) {\n        // Compress if 20+ events (lowered threshold)\n        if (monthEvents.length >= 20) {\n          try {\n            await compressEvents(monthEvents, 'monthly');\n            summariesCreated++;\n            eventsCompressed += monthEvents.length;\n            \n            // Delete compressed events\n            for (const event of monthEvents) {\n              await superMemoryDB.deleteEvent(event.id);\n            }\n          } catch (error) {\n            console.error(`[Summarizer] Failed to compress monthly events for ${new Date(monthStart).toISOString()}:`, error);\n          }\n        }\n      }\n    }\n\n    return {\n      success: true,\n      summariesCreated,\n      eventsCompressed,\n    };\n  } catch (error) {\n    console.error('[Summarizer] Nightly summarization failed:', error);\n    return {\n      success: false,\n      summariesCreated: 0,\n      eventsCompressed: 0,\n    };\n  }\n}\n\n/**\n * Initialize nightly summarization scheduler\n * Runs automatically once per day, or can be triggered manually\n */\nexport function initNightlySummarization(): void {\n  // Check if we should run summarization\n  const lastRun = localStorage.getItem('sm-last-summary-run');\n  const now = Date.now();\n  const oneDayMs = 24 * 60 * 60 * 1000;\n\n  // Run if never run before, or if last run was more than 24 hours ago\n  if (!lastRun || (now - parseInt(lastRun, 10)) > oneDayMs) {\n    // Run summarization asynchronously (don't block app startup)\n    setTimeout(() => {\n      runNightlySummarization()\n        .then((result) => {\n          console.log('[Summarizer] Nightly summarization completed:', result);\n          localStorage.setItem('sm-last-summary-run', now.toString());\n          \n          // Emit event for UI to show notification if needed\n          if (result.summariesCreated > 0) {\n            window.dispatchEvent(new CustomEvent('memory-summarized', {\n              detail: {\n                summariesCreated: result.summariesCreated,\n                eventsCompressed: result.eventsCompressed,\n              },\n            }));\n          }\n        })\n        .catch((error) => {\n          console.error('[Summarizer] Nightly summarization error:', error);\n        });\n    }, 5000); // Wait 5 seconds after app startup\n\n    // Schedule next run (24 hours from now)\n    const nextRun = now + oneDayMs;\n    const delay = nextRun - now;\n    setTimeout(() => {\n      initNightlySummarization();\n    }, delay);\n  } else {\n    // Schedule next run\n    const nextRun = parseInt(lastRun, 10) + oneDayMs;\n    const delay = Math.max(0, nextRun - now);\n    setTimeout(() => {\n      initNightlySummarization();\n    }, delay);\n  }\n}\n\n/**\n * Manually trigger summarization (for testing or user-initiated compression)\n */\nexport async function triggerSummarization(): Promise<{\n  success: boolean;\n  summariesCreated: number;\n  eventsCompressed: number;\n}> {\n  console.log('[Summarizer] Manual summarization triggered');\n  const result = await runNightlySummarization();\n  localStorage.setItem('sm-last-summary-run', Date.now().toString());\n  return result;\n}\n\n"],"file":"core-memory-DmK-uh9X.js"}