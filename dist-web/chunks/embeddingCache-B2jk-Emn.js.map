{"version":3,"mappings":"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","names":["sha256","text","data","hashBuffer","b","getCachePath","hash","isTauriRuntime","__vitePreload","isTauriRuntime2","n","invoke","error","getCachedEmbedding","model","lruResult","getCachedEmbeddingLRU","cachePath","fileBytes","fileContent","cached","saveCachedEmbeddingLRU","cacheEmbedding","vector","jsonContent","bytes","getOrGenerateEmbedding","isWebMode","acc","char","_","i"],"ignoreList":[],"sources":["../../src/services/embedding/embeddingCache.ts"],"sourcesContent":["/**\n * Embedding Cache - Telepathy Upgrade Phase 3\n * Cache embeddings forever using SHA256 hash\n * Location: ~/regen/embed_cache/{sha256}.json\n *\n * Future Enhancement #2: Now uses LRU cache for memory efficiency\n */\n\nimport { invoke } from '@tauri-apps/api/core';\nimport { saveCachedEmbeddingLRU, getCachedEmbeddingLRU } from './lruCache';\nimport { isTauriRuntime, isWebMode } from '../../lib/env';\n\nexport interface CachedEmbedding {\n  text: string;\n  vector: number[];\n  model: string;\n  timestamp: number;\n  hash: string;\n}\n\n/**\n * Generate SHA256 hash of text (for cache key)\n */\nasync function sha256(text: string): Promise<string> {\n  // Use Web Crypto API for SHA256\n  const encoder = new TextEncoder();\n  const data = encoder.encode(text);\n  const hashBuffer = await crypto.subtle.digest('SHA-256', data);\n  const hashArray = Array.from(new Uint8Array(hashBuffer));\n  const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');\n  return hashHex;\n}\n\n/**\n * Get cache path for an embedding hash\n */\nasync function getCachePath(hash: string): Promise<string> {\n  try {\n    // Check if Tauri is available\n    const { isTauriRuntime } = await import('../../lib/env');\n    if (!isTauriRuntime()) {\n      return `embed_cache/${hash}.json`; // Fallback for web mode\n    }\n\n    return await invoke<string>('get_app_data_path', {\n      subpath: `embed_cache/${hash}.json`,\n    });\n  } catch (error: any) {\n    // Silently fallback - Tauri not available is expected in web mode\n    if (error?.message?.includes('Tauri API not available')) {\n      return `embed_cache/${hash}.json`;\n    }\n    // Only log unexpected errors\n    if (error?.message && !error.message.includes('Tauri')) {\n      console.warn('[EmbeddingCache] Failed to get app data path', error);\n    }\n    return `embed_cache/${hash}.json`;\n  }\n}\n\n/**\n * Get cached embedding by text hash\n */\nexport async function getCachedEmbedding(\n  text: string,\n  model: string = 'nomic-embed-text:4bit'\n): Promise<number[] | null> {\n  try {\n    // Future Enhancement #2: Try LRU cache first (fast, in-memory)\n    const lruResult = await getCachedEmbeddingLRU(text, model);\n    if (lruResult) {\n      console.log('[EmbeddingCache] LRU cache hit');\n      return lruResult.vector;\n    }\n\n    // Fallback to disk cache (slower but persistent)\n    const hash = await sha256(`${model}:${text}`);\n    const cachePath = await getCachePath(hash);\n\n    // Try to read cached file\n    try {\n      // Read file as binary (bytes) and decode to string\n      const fileBytes = await invoke<number[]>('read_file', { path: cachePath });\n      const fileContent = new TextDecoder().decode(new Uint8Array(fileBytes));\n      const cached: CachedEmbedding = JSON.parse(fileContent);\n\n      // Verify it's for the same model and text\n      if (cached.model === model && cached.text === text) {\n        console.log('[EmbeddingCache] Disk cache hit for', hash.slice(0, 8));\n\n        // Promote to LRU cache\n        await saveCachedEmbeddingLRU(text, cached.vector, model);\n\n        return cached.vector;\n      }\n    } catch {\n      // Cache miss - file doesn't exist\n      console.debug('[EmbeddingCache] Cache miss for', hash.slice(0, 8));\n    }\n\n    return null;\n  } catch (error) {\n    console.warn('[EmbeddingCache] Failed to get cached embedding', error);\n    return null;\n  }\n}\n\n/**\n * Cache an embedding forever\n */\nexport async function cacheEmbedding(\n  text: string,\n  vector: number[],\n  model: string = 'nomic-embed-text:4bit'\n): Promise<void> {\n  try {\n    // Future Enhancement #2: Save to LRU cache (fast, in-memory)\n    await saveCachedEmbeddingLRU(text, vector, model);\n\n    // Also save to disk for persistence\n    const hash = await sha256(`${model}:${text}`);\n    const cachePath = await getCachePath(hash);\n\n    const cached: CachedEmbedding = {\n      text,\n      vector,\n      model,\n      timestamp: Date.now(),\n      hash,\n    };\n\n    // Write to cache file\n    const jsonContent = JSON.stringify(cached);\n    const bytes = new TextEncoder().encode(jsonContent);\n\n    await invoke('write_file', {\n      path: cachePath,\n      contents: Array.from(bytes),\n    });\n\n    console.log('[EmbeddingCache] Cached embedding', hash.slice(0, 8));\n  } catch (error) {\n    console.warn('[EmbeddingCache] Failed to cache embedding', error);\n    // Non-critical - continue even if caching fails\n  }\n}\n\n/**\n * Get embedding with caching (returns cached if available, otherwise generates and caches)\n */\nexport async function getOrGenerateEmbedding(\n  text: string,\n  model: string = 'nomic-embed-text:4bit'\n): Promise<number[]> {\n  // Try cache first\n  const cached = await getCachedEmbedding(text, model);\n  if (cached) {\n    return cached;\n  }\n\n  // Generate new embedding\n  // Skip Tauri API in web mode\n  if (isWebMode() || !isTauriRuntime()) {\n    // Fallback to simple hash-based vector for web mode\n    const hash = text.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);\n    return new Array(384).fill(0).map((_, i) => Math.sin(hash + i) * 0.1);\n  }\n\n  try {\n    const vector = await invoke<number[]>('embed_text', {\n      text,\n      model,\n    });\n\n    // Cache for future use (async - don't wait)\n    cacheEmbedding(text, vector, model).catch(() => {\n      // Non-critical\n    });\n\n    return vector;\n  } catch (error) {\n    // Suppress Tauri API errors in web mode\n    if (!isWebMode()) {\n      console.warn('[EmbeddingCache] Tauri embedding failed, using fallback', error);\n    }\n    // Fallback to simple hash-based vector\n    const hash = text.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);\n    return new Array(384).fill(0).map((_, i) => Math.sin(hash + i) * 0.1);\n  }\n}\n"],"file":"embeddingCache-B2jk-Emn.js"}