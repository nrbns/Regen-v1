import{N as z}from"./vendor-react-gmX1Lmvt.js";import{aw as O}from"./vendor-Vl2WtvH-.js";const W={},E=t=>{let e;const s=new Set,n=(v,p)=>{const f=typeof v=="function"?v(e):v;if(!Object.is(f,e)){const y=e;e=p??(typeof f!="object"||f===null)?f:Object.assign({},e,f),s.forEach(S=>S(e,y))}},a=()=>e,d={setState:n,getState:a,getInitialState:()=>u,subscribe:v=>(s.add(v),()=>s.delete(v)),destroy:()=>{(W?"production":void 0)!=="production"&&console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."),s.clear()}},u=e=t(n,a,d);return d},R=t=>t?E(t):E,D={},{useDebugValue:k}=z,{useSyncExternalStoreWithSelector:P}=O;let I=!1;const $=t=>t;function x(t,e=$,s){(D?"production":void 0)!=="production"&&s&&!I&&(console.warn("[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"),I=!0);const n=P(t.subscribe,t.getState,t.getServerState||t.getInitialState,e,s);return k(n),n}const b=t=>{(D?"production":void 0)!=="production"&&typeof t!="function"&&console.warn("[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`.");const e=typeof t=="function"?R(t):t,s=(n,a)=>x(e,n,a);return Object.assign(s,e),s},X=t=>t?b(t):b,T={};function q(t,e){let s;try{s=t()}catch{return}return{getItem:a=>{var r;const g=d=>d===null?null:JSON.parse(d,void 0),m=(r=s.getItem(a))!=null?r:null;return m instanceof Promise?m.then(g):g(m)},setItem:(a,r)=>s.setItem(a,JSON.stringify(r,void 0)),removeItem:a=>s.removeItem(a)}}const _=t=>e=>{try{const s=t(e);return s instanceof Promise?s:{then(n){return _(n)(s)},catch(n){return this}}}catch(s){return{then(n){return this},catch(n){return _(n)(s)}}}},C=(t,e)=>(s,n,a)=>{let r={getStorage:()=>localStorage,serialize:JSON.stringify,deserialize:JSON.parse,partialize:i=>i,version:0,merge:(i,l)=>({...l,...i}),...e},g=!1;const m=new Set,d=new Set;let u;try{u=r.getStorage()}catch{}if(!u)return t((...i)=>{console.warn(`[zustand persist middleware] Unable to update item '${r.name}', the given storage is currently unavailable.`),s(...i)},n,a);const v=_(r.serialize),p=()=>{const i=r.partialize({...n()});let l;const o=v({state:i,version:r.version}).then(h=>u.setItem(r.name,h)).catch(h=>{l=h});if(l)throw l;return o},f=a.setState;a.setState=(i,l)=>{f(i,l),p()};const y=t((...i)=>{s(...i),p()},n,a);let S;const c=()=>{var i;if(!u)return;g=!1,m.forEach(o=>o(n()));const l=((i=r.onRehydrateStorage)==null?void 0:i.call(r,n()))||void 0;return _(u.getItem.bind(u))(r.name).then(o=>{if(o)return r.deserialize(o)}).then(o=>{if(o)if(typeof o.version=="number"&&o.version!==r.version){if(r.migrate)return r.migrate(o.state,o.version);console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return o.state}).then(o=>{var h;return S=r.merge(o,(h=n())!=null?h:y),s(S,!0),p()}).then(()=>{l?.(S,void 0),g=!0,d.forEach(o=>o(S))}).catch(o=>{l?.(void 0,o)})};return a.persist={setOptions:i=>{r={...r,...i},i.getStorage&&(u=i.getStorage())},clearStorage:()=>{u?.removeItem(r.name)},getOptions:()=>r,rehydrate:()=>c(),hasHydrated:()=>g,onHydrate:i=>(m.add(i),()=>{m.delete(i)}),onFinishHydration:i=>(d.add(i),()=>{d.delete(i)})},c(),S||y},N=(t,e)=>(s,n,a)=>{let r={storage:q(()=>localStorage),partialize:c=>c,version:0,merge:(c,i)=>({...i,...c}),...e},g=!1;const m=new Set,d=new Set;let u=r.storage;if(!u)return t((...c)=>{console.warn(`[zustand persist middleware] Unable to update item '${r.name}', the given storage is currently unavailable.`),s(...c)},n,a);const v=()=>{const c=r.partialize({...n()});return u.setItem(r.name,{state:c,version:r.version})},p=a.setState;a.setState=(c,i)=>{p(c,i),v()};const f=t((...c)=>{s(...c),v()},n,a);a.getInitialState=()=>f;let y;const S=()=>{var c,i;if(!u)return;g=!1,m.forEach(o=>{var h;return o((h=n())!=null?h:f)});const l=((i=r.onRehydrateStorage)==null?void 0:i.call(r,(c=n())!=null?c:f))||void 0;return _(u.getItem.bind(u))(r.name).then(o=>{if(o)if(typeof o.version=="number"&&o.version!==r.version){if(r.migrate)return[!0,r.migrate(o.state,o.version)];console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return[!1,o.state];return[!1,void 0]}).then(o=>{var h;const[F,H]=o;if(y=r.merge(H,(h=n())!=null?h:f),s(y,!0),F)return v()}).then(()=>{l?.(y,void 0),y=n(),g=!0,d.forEach(o=>o(y))}).catch(o=>{l?.(void 0,o)})};return a.persist={setOptions:c=>{r={...r,...c},c.storage&&(u=c.storage)},clearStorage:()=>{u?.removeItem(r.name)},getOptions:()=>r,rehydrate:()=>S(),hasHydrated:()=>g,onHydrate:c=>(m.add(c),()=>{m.delete(c)}),onFinishHydration:c=>(d.add(c),()=>{d.delete(c)})},r.skipHydration||S(),y||f},J=(t,e)=>"getStorage"in e||"serialize"in e||"deserialize"in e?((T?"production":void 0)!=="production"&&console.warn("[DEPRECATED] `getStorage`, `serialize` and `deserialize` options are deprecated. Use `storage` option instead."),C(t,e)):N(t,e),Y=J,{useDebugValue:L}=z,{useSyncExternalStoreWithSelector:U}=O,M=t=>t;function G(t,e=M,s){const n=U(t.subscribe,t.getState,t.getServerState||t.getInitialState,e,s);return L(n),n}const w=(t,e)=>{const s=R(t),n=(a,r=e)=>G(s,a,r);return Object.assign(n,s),n},Z=(t,e)=>t?w(t,e):w;function A(t,e){if(Object.is(t,e))return!0;if(typeof t!="object"||t===null||typeof e!="object"||e===null)return!1;if(t instanceof Map&&e instanceof Map){if(t.size!==e.size)return!1;for(const[n,a]of t)if(!Object.is(a,e.get(n)))return!1;return!0}if(t instanceof Set&&e instanceof Set){if(t.size!==e.size)return!1;for(const n of t)if(!e.has(n))return!1;return!0}const s=Object.keys(t);if(s.length!==Object.keys(e).length)return!1;for(const n of s)if(!Object.prototype.hasOwnProperty.call(e,n)||!Object.is(t[n],e[n]))return!1;return!0}export{Z as a,X as c,Y as p,A as s,G as u};
//# sourceMappingURL=vendor-zustand-BWsgwsXr.js.map
