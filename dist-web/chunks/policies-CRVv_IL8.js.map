{"version":3,"file":"policies-CRVv_IL8.js","sources":["../../src/core/redix/policies.ts"],"sourcesContent":["/**\n * Redix Policy Engine - Resource management and optimization policies\n * Applies rules for tab suspension, throttling, and prefetching based on system state\n */\n\nimport policiesConfig from './policies.json';\nimport { Redix, dispatch } from './runtime';\n\nexport type PolicyMode = 'default' | 'performance' | 'balanced' | 'battery';\n\nexport interface PolicyRules {\n  suspendBackgroundTabs: boolean;\n  suspendAfterMinutes: number;\n  throttleHeavyTabs: boolean;\n  memoryThreshold: number; // percentage\n  cpuThreshold: number; // percentage\n  batteryThreshold: number; // percentage\n  prefetchEnabled: boolean;\n  prefetchOnWifiOnly: boolean;\n}\n\ninterface SystemMetrics {\n  memoryUsage?: number; // percentage\n  cpuUsage?: number; // percentage\n  batteryLevel?: number; // percentage\n  isWifi?: boolean;\n  isBatteryLow?: boolean;\n}\n\nclass PolicyEngine {\n  private currentMode: PolicyMode = 'default';\n  private metrics: SystemMetrics = {};\n  private activePolicies: PolicyRules;\n\n  constructor() {\n    this.activePolicies = this.getPolicyRules('default');\n    this.initializeMetrics();\n  }\n\n  /**\n   * Get policy rules for a mode\n   */\n  getPolicyRules(mode: PolicyMode = this.currentMode): PolicyRules {\n    const policies = (policiesConfig as any)[mode];\n    if (!policies) {\n      console.warn(`[RedixPolicies] Unknown policy mode: ${mode}, using default`);\n      return (policiesConfig as any).default;\n    }\n    return policies as PolicyRules;\n  }\n\n  /**\n   * Set active policy mode\n   */\n  setMode(mode: PolicyMode): void {\n    this.currentMode = mode;\n    this.activePolicies = this.getPolicyRules(mode);\n    \n    dispatch({\n      type: 'redix:policy:mode-changed',\n      payload: { mode, policies: this.activePolicies },\n    });\n\n    console.log(`[RedixPolicies] Mode changed to: ${mode}`);\n  }\n\n  /**\n   * Get current policy mode\n   */\n  getMode(): PolicyMode {\n    return this.currentMode;\n  }\n\n  /**\n   * Update system metrics\n   */\n  updateMetrics(metrics: Partial<SystemMetrics>): void {\n    this.metrics = { ...this.metrics, ...metrics };\n    this.evaluatePolicies();\n  }\n\n  /**\n   * Initialize metrics from system APIs\n   */\n  private async initializeMetrics(): Promise<void> {\n    // Battery API (if available)\n    if ('getBattery' in navigator) {\n      try {\n        const battery = await (navigator as any).getBattery();\n        this.updateMetrics({\n          batteryLevel: battery.level * 100,\n          isBatteryLow: battery.level < 0.2,\n        });\n\n        // Listen for battery changes\n        battery.addEventListener('levelchange', () => {\n          this.updateMetrics({\n            batteryLevel: battery.level * 100,\n            isBatteryLow: battery.level < 0.2,\n          });\n        });\n      } catch (error) {\n        console.warn('[RedixPolicies] Battery API unavailable:', error);\n      }\n    }\n\n    // Network API (if available)\n    if ('connection' in navigator) {\n      const connection = (navigator as any).connection;\n      if (connection) {\n        this.updateMetrics({\n          isWifi: connection.effectiveType === 'wifi' || connection.type === 'wifi',\n        });\n\n        connection.addEventListener('change', () => {\n          this.updateMetrics({\n            isWifi: connection.effectiveType === 'wifi' || connection.type === 'wifi',\n          });\n        });\n      }\n    }\n\n    // Memory API (if available)\n    if ('memory' in performance) {\n      const memory = (performance as any).memory;\n      if (memory) {\n        const memoryUsage = (memory.usedJSHeapSize / memory.jsHeapSizeLimit) * 100;\n        this.updateMetrics({ memoryUsage });\n      }\n    }\n  }\n\n  /**\n   * Evaluate policies based on current metrics\n   */\n  private evaluatePolicies(): void {\n    const { memoryUsage, cpuUsage, batteryLevel, isWifi } = this.metrics;\n    const {\n      memoryThreshold,\n      cpuThreshold,\n      batteryThreshold,\n      prefetchEnabled,\n      prefetchOnWifiOnly,\n    } = this.activePolicies;\n\n    // Check if we should disable prefetch due to battery or network\n    if (prefetchEnabled) {\n      const shouldDisablePrefetch =\n        (prefetchOnWifiOnly && !isWifi) ||\n        (batteryLevel !== undefined && batteryLevel < batteryThreshold);\n\n      if (shouldDisablePrefetch) {\n        dispatch({\n          type: 'redix:policy:prefetch-disabled',\n          payload: {\n            reason: prefetchOnWifiOnly && !isWifi ? 'not_wifi' : 'battery_low',\n            batteryLevel,\n            isWifi,\n          },\n        });\n      }\n    }\n\n    // Check if we should throttle tabs due to resource constraints\n    if (memoryUsage !== undefined && memoryUsage > memoryThreshold) {\n      dispatch({\n        type: 'redix:policy:memory-high',\n        payload: {\n          usage: memoryUsage,\n          threshold: memoryThreshold,\n          action: 'throttle_tabs',\n        },\n      });\n    }\n\n    if (cpuUsage !== undefined && cpuUsage > cpuThreshold) {\n      dispatch({\n        type: 'redix:policy:cpu-high',\n        payload: {\n          usage: cpuUsage,\n          threshold: cpuThreshold,\n          action: 'throttle_tabs',\n        },\n      });\n    }\n\n    // Check if battery is low\n    if (batteryLevel !== undefined && batteryLevel < batteryThreshold) {\n      dispatch({\n        type: 'redix:policy:battery-low',\n        payload: {\n          level: batteryLevel,\n          threshold: batteryThreshold,\n          action: 'suspend_background_tabs',\n        },\n      });\n    }\n  }\n\n  /**\n   * Check if an action is allowed by current policies\n   */\n  shouldAllow(action: string, _context?: Record<string, any>): boolean {\n    const { suspendBackgroundTabs, prefetchEnabled, prefetchOnWifiOnly } = this.activePolicies;\n    const { isWifi, batteryLevel } = this.metrics;\n    const { batteryThreshold } = this.activePolicies;\n\n    switch (action) {\n      case 'prefetch':\n        if (!prefetchEnabled) return false;\n        if (prefetchOnWifiOnly && !isWifi) return false;\n        if (batteryLevel !== undefined && batteryLevel < batteryThreshold) return false;\n        return true;\n\n      case 'suspend_tab':\n        return suspendBackgroundTabs;\n\n      case 'throttle_tab':\n        return this.activePolicies.throttleHeavyTabs;\n\n      default:\n        return true;\n    }\n  }\n\n  /**\n   * Get recommendations based on current metrics\n   */\n  getRecommendations(): string[] {\n    const recommendations: string[] = [];\n    const { memoryUsage, cpuUsage, batteryLevel } = this.metrics;\n    const { memoryThreshold, cpuThreshold, batteryThreshold: batteryThresh } = this.activePolicies;\n\n    if (memoryUsage !== undefined && memoryUsage > memoryThreshold) {\n      recommendations.push('Consider closing unused tabs to reduce memory usage');\n    }\n\n    if (cpuUsage !== undefined && cpuUsage > cpuThreshold) {\n      recommendations.push('CPU usage is high - heavy tabs will be throttled');\n    }\n\n    if (batteryLevel !== undefined && batteryLevel < batteryThresh) {\n      recommendations.push('Battery is low - background tabs will be suspended');\n    }\n\n    return recommendations;\n  }\n\n  /**\n   * Get current metrics\n   */\n  getMetrics(): SystemMetrics {\n    return { ...this.metrics };\n  }\n\n  /**\n   * Get active policies\n   */\n  getActivePolicies(): PolicyRules {\n    return { ...this.activePolicies };\n  }\n}\n\n// Singleton instance\nexport const policyEngine = new PolicyEngine();\n\n// Export convenience functions\nexport const setPolicyMode = (mode: PolicyMode) => policyEngine.setMode(mode);\nexport const getPolicyMode = () => policyEngine.getMode();\nexport const updatePolicyMetrics = (metrics: Partial<SystemMetrics>) =>\n  policyEngine.updateMetrics(metrics);\nexport const shouldAllowPolicy = (action: string, context?: Record<string, any>) =>\n  policyEngine.shouldAllow(action, context);\nexport const getPolicyRecommendations = () => policyEngine.getRecommendations();\nexport const getPolicyMetrics = () => policyEngine.getMetrics();\nexport const getPolicyRules = (mode?: PolicyMode) => policyEngine.getPolicyRules(mode);\n\n// Listen for performance events\nRedix.watch('redix:performance:low', (event) => {\n  const { memory, cpu, battery } = event.payload;\n  policyEngine.updateMetrics({\n    memoryUsage: memory,\n    cpuUsage: cpu,\n    batteryLevel: battery,\n  });\n});\n\n"],"names":["PolicyEngine","__publicField","mode","policies","policiesConfig","dispatch","metrics","battery","error","connection","memory","memoryUsage","cpuUsage","batteryLevel","isWifi","memoryThreshold","cpuThreshold","batteryThreshold","prefetchEnabled","prefetchOnWifiOnly","action","_context","suspendBackgroundTabs","recommendations","batteryThresh","policyEngine","setPolicyMode","getPolicyMode","updatePolicyMetrics","shouldAllowPolicy","context","getPolicyRecommendations","getPolicyMetrics","getPolicyRules","Redix","event","cpu"],"mappings":"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"}