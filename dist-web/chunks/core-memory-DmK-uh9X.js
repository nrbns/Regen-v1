import{_ as w}from"./core-ai-yFIunLTZ.js";var q=Object.defineProperty,L=(s,e,t)=>e in s?q(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t,A=(s,e,t)=>L(s,typeof e!="symbol"?e+"":e,t);const B="sm-",S=1e4;class V{constructor(){A(this,"db",null),A(this,"useIndexedDB",!1)}async init(){if(!("indexedDB"in window)){this.useIndexedDB=!1;return}try{const{superMemoryDB:e}=await w(async()=>{const{superMemoryDB:t}=await Promise.resolve().then(()=>v);return{superMemoryDB:t}},void 0);await e.init(),this.useIndexedDB=!0,this.db=e.db}catch(e){console.warn("[SuperMemory] IndexedDB unavailable, using localStorage:",e),this.useIndexedDB=!1}}get(e){try{if(typeof window>"u"||!window.localStorage)return null;const t=localStorage.getItem(B+e);return t?JSON.parse(t):null}catch(t){return console.error("[SuperMemory] Failed to get:",e,t),null}}set(e,t){try{if(typeof window>"u"||!window.localStorage)return;localStorage.setItem(B+e,JSON.stringify(t))}catch(r){console.error("[SuperMemory] Failed to set:",e,r)}}push(e,t){try{if(typeof window>"u"||!window.localStorage)return;const r=this.get(e)||[];r.unshift(t),r.length>S&&r.splice(S),this.set(e,r)}catch(r){console.error("[SuperMemory] Failed to push:",e,r)}}async saveEvent(e){const t={...e,id:`mem-${Date.now()}-${Math.random().toString(36).substr(2,9)}`,ts:Date.now(),score:this.calculateScore(e)};if(this.useIndexedDB)try{const{superMemoryDB:r}=await w(async()=>{const{superMemoryDB:n}=await Promise.resolve().then(()=>v);return{superMemoryDB:n}},void 0);return await r.saveEvent(t),t.id}catch(r){console.warn("[SuperMemory] IndexedDB save failed, falling back to localStorage:",r),this.useIndexedDB=!1}return this.push("events",t),this.cleanupOldEventsSync(),t.id}async getEvents(e){if(this.useIndexedDB)try{const{superMemoryDB:n}=await w(async()=>{const{superMemoryDB:o}=await Promise.resolve().then(()=>v);return{superMemoryDB:o}},void 0);return await n.getEvents(e)}catch(n){console.warn("[SuperMemory] IndexedDB read failed, falling back to localStorage:",n),this.useIndexedDB=!1}let r=this.get("events")||[];return e?.type&&(r=r.filter(n=>n.type===e.type)),e?.since&&(r=r.filter(n=>n.ts>=e.since)),e?.until&&(r=r.filter(n=>n.ts<=e.until)),e?.pinned!==void 0&&(r=r.filter(n=>!!n.metadata?.pinned===e.pinned)),e?.tags&&e.tags.length>0&&(r=r.filter(n=>{const o=n.metadata?.tags||[];return e.tags.every(a=>o.includes(a))})),r.slice(0,e?.limit||100)}calculateScore(e){return(this.get("events")||[]).filter(o=>o.type===e.type&&JSON.stringify(o.value)===JSON.stringify(e.value)).length*.6+1*.4}async cleanupOldEvents(){if(this.db)try{const r=this.db.transaction(["events"],"readwrite").objectStore("events").index("ts"),n=Date.now()-2160*60*60*1e3,o=IDBKeyRange.upperBound(n);return new Promise((a,i)=>{const c=r.openCursor(o);c.onsuccess=d=>{const l=d.target.result;l?(l.delete(),l.continue()):a()},c.onerror=()=>i(c.error)})}catch(e){console.warn("[SuperMemory] Cleanup failed:",e)}}cleanupOldEventsSync(){if(typeof window>"u"||!window.localStorage)return;const e=this.get("events")||[],t=Date.now()-2160*60*60*1e3,r=e.filter(n=>n.ts>=t);r.length>S&&r.splice(S),this.set("events",r)}async forgetAll(){if(this.useIndexedDB&&this.db)try{await this.db.transaction(["events"],"readwrite").objectStore("events").clear()}catch(e){console.warn("[SuperMemory] Failed to clear IndexedDB:",e)}typeof window<"u"&&window.localStorage&&localStorage.removeItem(B+"events")}async export(){return this.getEvents({limit:S})}async getEventById(e){if(this.useIndexedDB)try{const{superMemoryDB:r}=await w(async()=>{const{superMemoryDB:n}=await Promise.resolve().then(()=>v);return{superMemoryDB:n}},void 0);return await r.getEvent(e)}catch(r){console.warn("[SuperMemory] IndexedDB getEvent failed, falling back to localStorage:",r),this.useIndexedDB=!1}return(this.get("events")||[]).find(r=>r.id===e)||null}async getEventsByIds(e){if(e.length===0)return[];if(this.useIndexedDB)try{const{superMemoryDB:n}=await w(async()=>{const{superMemoryDB:o}=await Promise.resolve().then(()=>v);return{superMemoryDB:o}},void 0);return await n.getEventsByIds(e)}catch(n){console.warn("[SuperMemory] IndexedDB getEventsByIds failed, falling back to localStorage:",n),this.useIndexedDB=!1}const t=this.get("events")||[],r=new Map(t.map(n=>[n.id,n]));return e.map(n=>r.get(n)).filter(n=>!!n)}}const N=new V,_=N;typeof window<"u"&&N.init().catch(console.error);const H={};var J=Object.defineProperty,U=(s,e,t)=>e in s?J(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t,O=(s,e,t)=>U(s,typeof e!="symbol"?e+"":e,t);const C=384,K=6e4,P=typeof window<"u"&&window.__superMemoryApiBase||typeof import.meta<"u"&&H?.VITE_SUPER_MEMORY_API_BASE||"http://localhost:8000";class W{constructor(){O(this,"statusCache",{openai:{provider:"openai",available:!1},huggingface:{provider:"huggingface",available:!1},local:{provider:"local",available:!0}}),O(this,"preferredOrder",["openai","huggingface","local"])}async generateEmbedding(e,t){switch(t?.provider||await this.getPreferredProvider()){case"openai":return this.generateOpenAIEmbedding(e,t?.signal);case"huggingface":return this.generateHuggingFaceEmbedding(e,t?.signal);case"local":default:return this.generateLocalEmbedding(e)}}async getPreferredProvider(){if(typeof window<"u"&&!window.__ELECTRON__&&!window.__TAURI__)return"local";for(const t of this.preferredOrder)if((await this.checkProvider(t)).available)return t;return"local"}async checkProvider(e){const t=this.statusCache[e],r=Date.now();if(t.lastChecked&&r-t.lastChecked<K)return t;try{if(e==="openai"){const n=await this.checkOpenAI();return this.statusCache[e]=n,n}if(e==="huggingface"){const n=await this.checkHuggingFace();return this.statusCache[e]=n,n}return this.statusCache[e]={provider:"local",available:!0,lastChecked:r},this.statusCache[e]}catch(n){return this.statusCache[e]={provider:e,available:!1,lastChecked:r,error:n instanceof Error?n.message:String(n)},this.statusCache[e]}}async checkOpenAI(){if(typeof window<"u"&&!window.__ELECTRON__&&!window.__TAURI__)return{provider:"openai",available:!1,lastChecked:Date.now()};const t=performance.now();try{const r=await fetch(`${P}/openai/status`,{method:"GET"}),n=performance.now()-t;if(!r.ok)throw new Error(`OpenAI status ${r.status}`);return{provider:"openai",available:(await r.json()).available??!0,latencyMs:n,lastChecked:Date.now()}}catch(r){return{provider:"openai",available:!1,error:r instanceof Error?r.message:String(r),lastChecked:Date.now()}}}async checkHuggingFace(){if(typeof window<"u"&&!window.__ELECTRON__&&!window.__TAURI__)return{provider:"huggingface",available:!1,lastChecked:Date.now()};const t=performance.now();try{const r=await fetch(`${P}/huggingface/status`,{method:"GET"}),n=performance.now()-t;if(!r.ok)throw new Error(`HuggingFace status ${r.status}`);return{provider:"huggingface",available:(await r.json()).available??!0,latencyMs:n,lastChecked:Date.now()}}catch(r){return{provider:"huggingface",available:!1,error:r instanceof Error?r.message:String(r),lastChecked:Date.now()}}}async generateOpenAIEmbedding(e,t){try{const r=await fetch(`${P}/openai/embedding`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({text:e,model:"text-embedding-3-small"}),signal:t});if(!r.ok)throw new Error(`OpenAI embedding failed: ${r.status}`);const o=(await r.json()).embedding;if(!Array.isArray(o))throw new Error("OpenAI embedding malformed");return o}catch(r){return this.statusCache.openai={provider:"openai",available:!1,error:r instanceof Error?r.message:String(r),lastChecked:Date.now()},this.generateHuggingFaceEmbedding(e,t)}}async generateHuggingFaceEmbedding(e,t){try{const{generateHuggingFaceEmbedding:r,checkHuggingFaceAvailable:n}=await w(async()=>{const{generateHuggingFaceEmbedding:i,checkHuggingFaceAvailable:c}=await Promise.resolve().then(()=>De);return{generateHuggingFaceEmbedding:i,checkHuggingFaceAvailable:c}},void 0);if(!await n())throw new Error("HuggingFace inference unavailable");return await r(e)}catch(r){return this.statusCache.huggingface={provider:"huggingface",available:!1,error:r instanceof Error?r.message:String(r),lastChecked:Date.now()},this.generateLocalEmbedding(e)}}async generateLocalEmbedding(e){const r=e.toLowerCase().split(/\s+/).filter(Boolean),n=new Array(C).fill(0);for(let a=0;a<r.length;a++){const i=r[a];let c=0;for(let l=0;l<i.length;l++)c=(c<<5)-c+i.charCodeAt(l),c|=0;const d=Math.abs(c)%C;n[d]+=1/Math.sqrt(a+1)}const o=Math.sqrt(n.reduce((a,i)=>a+i*i,0));if(o>0)for(let a=0;a<n.length;a++)n[a]=n[a]/o;return n}}const G=new W,Y=(s,e)=>G.generateEmbedding(s,e),X=new Map,Z=512,Q=50;function ee(s,e=Z,t=Q){if(s.length<=e)return[s];const r=[];let n=0;for(;n<s.length;){const o=Math.min(n+e,s.length);let a=s.slice(n,o);if(o<s.length){const i=a.lastIndexOf("."),c=a.lastIndexOf(`
`),d=Math.max(i,c);d>e*.5?(a=s.slice(n,n+d+1),n+=d+1):n=o-t}else n=o;r.push(a.trim())}return r.filter(o=>o.length>0)}async function j(s){return Y(s)}async function te(s){const e=[];try{let t="";if(s.type==="search"?t=s.value:s.type==="visit"?t=`${s.metadata?.title||""} ${s.value}`.trim():s.type==="note"?t=s.value:t=s.value||JSON.stringify(s.metadata||{}),!t||t.length<10)return e;const r=ee(t);for(let n=0;n<r.length;n++){const o=r[n],a=await j(o),i={id:`${s.id}-chunk-${n}`,eventId:s.id,vector:a,text:o,metadata:{chunkIndex:n,totalChunks:r.length,eventType:s.type,...s.metadata},timestamp:s.ts};X.set(i.id,i);try{const{superMemoryDB:c}=await w(async()=>{const{superMemoryDB:d}=await Promise.resolve().then(()=>v);return{superMemoryDB:d}},void 0);await c.saveEmbedding({id:i.id,eventId:i.eventId,vector:i.vector,text:i.text,metadata:i.metadata,timestamp:i.timestamp})}catch(c){console.warn("[Embedding] Failed to save to IndexedDB, using localStorage:",c),_.set(`embedding:${i.id}`,i)}e.push(i.id)}}catch(t){console.error("[Embedding] Failed to embed memory event:",t)}return e}var ne=Object.defineProperty,re=(s,e,t)=>e in s?ne(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t,k=(s,e,t)=>re(s,typeof e!="symbol"?e+"":e,t);const se="supermemory",oe=2;class ae{constructor(){k(this,"db",null),k(this,"initPromise",null)}async init(){if(this.initPromise)return this.initPromise;if(!("indexedDB"in window))throw new Error("IndexedDB not available");return this.initPromise=new Promise((e,t)=>{const r=indexedDB.open(se,oe);r.onerror=()=>t(r.error),r.onsuccess=()=>{this.db=r.result,e()},r.onupgradeneeded=n=>{const o=n.target.result,a=n.oldVersion||0;if(a<1&&!o.objectStoreNames.contains("events")){const i=o.createObjectStore("events",{keyPath:"id"});i.createIndex("type","type",{unique:!1}),i.createIndex("ts","ts",{unique:!1}),i.createIndex("score","score",{unique:!1})}if(a<2){if(!o.objectStoreNames.contains("embeddings")){const i=o.createObjectStore("embeddings",{keyPath:"id"});i.createIndex("eventId","eventId",{unique:!1}),i.createIndex("timestamp","timestamp",{unique:!1})}if(o.objectStoreNames.contains("events")){const i=n.target.transaction;i&&i.objectStore("events").indexNames.contains("pinned")}}}}),this.initPromise}async getDB(){if(this.db||await this.init(),!this.db)throw new Error("Database not initialized");return this.db}async saveEvent(e){const n=(await this.getDB()).transaction(["events"],"readwrite").objectStore("events");return new Promise((o,a)=>{const i=n.put(e);i.onsuccess=()=>o(),i.onerror=()=>a(i.error)})}async updateEventMetadata(e,t){const o=(await this.getDB()).transaction(["events"],"readwrite").objectStore("events");return new Promise((a,i)=>{const c=o.get(e);c.onsuccess=()=>{const d=c.result;if(!d){i(new Error("Event not found"));return}d.metadata={...d.metadata,...t};const l=o.put(d);l.onsuccess=()=>a(),l.onerror=()=>i(l.error)},c.onerror=()=>i(c.error)})}async getAllTags(){const r=(await this.getDB()).transaction(["events"],"readonly").objectStore("events"),n=new Set;return new Promise((o,a)=>{const i=r.openCursor();i.onsuccess=c=>{const d=c.target.result;if(d){const l=d.value;if(l.metadata?.tags)for(const m of l.metadata.tags)n.add(m);d.continue()}else o(Array.from(n).sort())},i.onerror=()=>a(i.error)})}async getEvents(e){const o=(await this.getDB()).transaction(["events"],"readonly").objectStore("events").index("ts"),a=[];let i=null;return e?.since&&e?.until?i=IDBKeyRange.bound(e.since,e.until):e?.since?i=IDBKeyRange.lowerBound(e.since):e?.until&&(i=IDBKeyRange.upperBound(e.until)),new Promise((c,d)=>{const l=o.openCursor(i,"prev"),m=e?.limit||100;l.onsuccess=h=>{const u=h.target.result;if(u&&a.length<m){const g=u.value;if(e?.type&&g.type!==e.type){u.continue();return}if(e?.pinned!==void 0&&(g.metadata?.pinned||!1)!==e.pinned){u.continue();return}if(e?.tags&&e.tags.length>0){const p=g.metadata?.tags||[];if(!e.tags.every(D=>p.includes(D))){u.continue();return}}a.push(g),u.continue()}else c(a)},l.onerror=()=>d(l.error)})}async saveEmbedding(e){const n=(await this.getDB()).transaction(["embeddings"],"readwrite").objectStore("embeddings");return new Promise((o,a)=>{const i=n.put(e);i.onsuccess=()=>o(),i.onerror=()=>a(i.error)})}async getEmbeddingsForEvent(e){const o=(await this.getDB()).transaction(["embeddings"],"readonly").objectStore("embeddings").index("eventId"),a=[];return new Promise((i,c)=>{const d=o.openCursor(IDBKeyRange.only(e));d.onsuccess=l=>{const m=l.target.result;m?(a.push(m.value),m.continue()):i(a)},d.onerror=()=>c(d.error)})}async getAllEmbeddings(e){const o=(await this.getDB()).transaction(["embeddings"],"readonly").objectStore("embeddings").index("timestamp"),a=[],i=e||1e3;return new Promise((c,d)=>{const l=o.openCursor(null,"prev");l.onsuccess=m=>{const h=m.target.result;h&&a.length<i?(a.push(h.value),h.continue()):c(a)},l.onerror=()=>d(l.error)})}async deleteEmbeddingsForEvent(e){const o=(await this.getDB()).transaction(["embeddings"],"readwrite").objectStore("embeddings").index("eventId");return new Promise((a,i)=>{const c=o.openCursor(IDBKeyRange.only(e));c.onsuccess=d=>{const l=d.target.result;l?(l.delete(),l.continue()):a()},c.onerror=()=>i(c.error)})}async getEmbedding(e){const n=(await this.getDB()).transaction(["embeddings"],"readonly").objectStore("embeddings");return new Promise((o,a)=>{const i=n.get(e);i.onsuccess=()=>{o(i.result||null)},i.onerror=()=>a(i.error)})}async deleteEmbedding(e){const n=(await this.getDB()).transaction(["embeddings"],"readwrite").objectStore("embeddings");return new Promise((o,a)=>{const i=n.delete(e);i.onsuccess=()=>o(),i.onerror=()=>a(i.error)})}async deleteEmbeddingsByEventId(e){await this.deleteEmbeddingsForEvent(e)}async getEmbeddingCount(){const r=(await this.getDB()).transaction(["embeddings"],"readonly").objectStore("embeddings");return new Promise((n,o)=>{const a=r.count();a.onsuccess=()=>n(a.result),a.onerror=()=>o(a.error)})}async clearEmbeddings(){const r=(await this.getDB()).transaction(["embeddings"],"readwrite").objectStore("embeddings");return new Promise((n,o)=>{const a=r.clear();a.onsuccess=()=>n(),a.onerror=()=>o(a.error)})}async deleteEvent(e){const t=await this.getDB();await this.deleteEmbeddingsForEvent(e);const n=t.transaction(["events"],"readwrite").objectStore("events");return new Promise((o,a)=>{const i=n.delete(e);i.onsuccess=()=>o(),i.onerror=()=>a(i.error)})}async cleanupOldData(e=90){const t=await this.getDB(),r=Date.now()-e*24*60*60*1e3,a=t.transaction(["events"],"readwrite").objectStore("events").index("ts"),i=IDBKeyRange.upperBound(r);await new Promise((h,u)=>{const g=a.openCursor(i);g.onsuccess=p=>{const y=p.target.result;if(y){const D=y.value;this.deleteEmbeddingsForEvent(D.id).catch(console.warn),y.delete(),y.continue()}else h()},g.onerror=()=>u(g.error)});const l=t.transaction(["embeddings"],"readwrite").objectStore("embeddings").index("timestamp"),m=IDBKeyRange.upperBound(r);await new Promise((h,u)=>{const g=l.openCursor(m);g.onsuccess=p=>{const y=p.target.result;y?(y.delete(),y.continue()):h()},g.onerror=()=>u(g.error)})}async getStats(){const e=await this.getDB(),r=e.transaction(["events"],"readonly").objectStore("events"),n=await new Promise((u,g)=>{const p=r.count();p.onsuccess=()=>u(p.result),p.onerror=()=>g(p.error)}),a=e.transaction(["embeddings"],"readonly").objectStore("embeddings"),i=await new Promise((u,g)=>{const p=a.count();p.onsuccess=()=>u(p.result),p.onerror=()=>g(p.error)}),c=await this.getEvents({limit:10}),d=await this.getAllEmbeddings(10),l=c.length>0?JSON.stringify(c[0]).length:500,m=d.length>0?JSON.stringify(d[0]).length:2e3,h=n*l+i*m;return{eventCount:n,embeddingCount:i,totalSize:h}}async clearAll(){const t=(await this.getDB()).transaction(["events","embeddings"],"readwrite");await Promise.all([new Promise((r,n)=>{const o=t.objectStore("events").clear();o.onsuccess=()=>r(),o.onerror=()=>n(o.error)}),new Promise((r,n)=>{const o=t.objectStore("embeddings").clear();o.onsuccess=()=>r(),o.onerror=()=>n(o.error)})])}async getEvent(e){const n=(await this.getDB()).transaction(["events"],"readonly").objectStore("events");return new Promise((o,a)=>{const i=n.get(e);i.onsuccess=()=>o(i.result||null),i.onerror=()=>a(i.error)})}async getEventsByIds(e){if(e.length===0)return[];const n=(await this.getDB()).transaction(["events"],"readonly").objectStore("events"),o=new Map;return await Promise.all(e.map(a=>new Promise((i,c)=>{const d=n.get(a);d.onsuccess=()=>{d.result&&o.set(a,d.result),i()},d.onerror=()=>c(d.error)}))),e.map(a=>o.get(a)).filter(a=>!!a)}}const f=new ae;typeof window<"u"&&f.init().catch(s=>{console.warn("[SuperMemoryDB] Failed to initialize:",s)});const v=Object.freeze(Object.defineProperty({__proto__:null,superMemoryDB:f},Symbol.toStringTag,{value:"Module"}));var ie=Object.defineProperty,ce=(s,e,t)=>e in s?ie(s,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):s[e]=t,M=(s,e,t)=>ce(s,typeof e!="symbol"?e+"":e,t);class de{constructor(){M(this,"cache",new Map),M(this,"cacheSizeLimit",1e3),M(this,"isInitialized",!1)}async init(){if(!this.isInitialized)try{const e=await f.getAllEmbeddings(100);for(const t of e)this.cache.set(t.id,t);this.isInitialized=!0}catch(e){console.warn("[VectorStore] Initialization failed:",e)}}async save(e){if(this.cache.set(e.id,e),this.cache.size>this.cacheSizeLimit){const t=Array.from(this.cache.entries());t.sort((n,o)=>n[1].timestamp-o[1].timestamp);const r=t.slice(0,this.cache.size-this.cacheSizeLimit);for(const[n]of r)this.cache.delete(n)}try{await f.saveEmbedding({id:e.id,eventId:e.eventId,vector:e.vector,text:e.text,metadata:e.metadata,timestamp:e.timestamp})}catch(t){console.error("[VectorStore] Failed to save embedding:",t)}}async get(e){if(this.cache.has(e))return this.cache.get(e);try{const t=await f.getEmbedding(e);if(t){const r={id:t.id,eventId:t.eventId,vector:t.vector,text:t.text,metadata:t.metadata,timestamp:t.timestamp};return this.cache.set(e,r),r}}catch(t){console.error("[VectorStore] Failed to get embedding:",t)}return null}async delete(e){this.cache.delete(e);try{return await f.deleteEmbedding(e),!0}catch(t){return console.error("[VectorStore] Failed to delete embedding:",t),!1}}async deleteByEventId(e){let t=0;const r=[];for(const[n,o]of this.cache.entries())o.eventId===e&&r.push(n);for(const n of r)this.cache.delete(n),t++;try{await f.deleteEmbeddingsByEventId(e),t++}catch(n){console.error("[VectorStore] Failed to delete embeddings by event ID:",n)}return t}async search(e,t={}){const{maxVectors:r=1e3,minSimilarity:n=0}=t;let o;typeof e=="string"?o=await j(e):o=e;const a=[];for(const d of this.cache.values())a.push(d);if(a.length<r)try{const d=await f.getAllEmbeddings(r);for(const l of d){const m={id:l.id,eventId:l.eventId,vector:l.vector,text:l.text,metadata:l.metadata,timestamp:l.timestamp};if(this.cache.has(m.id)||(this.cache.set(m.id,m),a.push(m)),a.length>=r)break}}catch(d){console.warn("[VectorStore] Failed to load embeddings from IndexedDB:",d)}return a.map(d=>{const l=this.cosineSimilarity(o,d.vector);return{embedding:d,similarity:l,metadata:d.metadata}}).filter(d=>d.similarity>=n).sort((d,l)=>l.similarity-d.similarity)}cosineSimilarity(e,t){if(e.length!==t.length)return 0;let r=0,n=0,o=0;for(let a=0;a<e.length;a++)r+=e[a]*t[a],n+=e[a]*e[a],o+=t[a]*t[a];return n===0||o===0?0:r/(Math.sqrt(n)*Math.sqrt(o))}async count(){try{return await f.getEmbeddingCount()||this.cache.size}catch{return this.cache.size}}async batchSave(e){const t=e.slice(0,100);for(const r of t)await this.save(r);e.length>100&&await this.batchSave(e.slice(100))}async clear(){this.cache.clear();try{await f.clearEmbeddings()}catch(e){console.error("[VectorStore] Failed to clear embeddings:",e)}}async getStats(){const e=await this.count(),t=this.cache.size;let r=0,n=0;for(const a of this.cache.values())r+=a.vector.length,n++;const o=n>0?r/n:0;return{totalVectors:e,cachedVectors:t,avgVectorDimension:o}}}const $=new de;$.init().catch(console.warn);const le=(s,e)=>$.search(s,e);async function Oe(s,e={}){const{limit:t=12,minSimilarity:r=.55}=e,n=await le(s,{maxVectors:t*4,minSimilarity:r});return n.length===0?[]:await ue(n,t)}async function ue(s,e){const t=[],r=new Set;for(const i of s)if(!r.has(i.embedding.eventId)&&(t.push(i.embedding.eventId),r.add(i.embedding.eventId),t.length>=e))break;const n=await _.getEventsByIds(t),o=new Map(n.map(i=>[i.id,i])),a=[];for(const i of s){if(a.length>=e)break;const c=o.get(i.embedding.eventId);c&&a.push({event:c,similarity:i.similarity,embeddingId:i.embedding.id,chunkText:i.embedding.text})}return a}const me=new Set(["the","and","for","with","this","that","from","about","into","there","their","them","your","have","more","will","what","when","where","which","using","used","been","than","then","over","after","before","because","while","within","without","such","also","only","even","much","many","some","any","each","most","very","like","just","onto","upon","here","time","date","page","tab","mode","note","visit"]),ge=6;function he(s,e=ge){if(!s)return[];const t=s.toLowerCase().replace(/[^a-z0-9\s]/g," ").split(/\s+/).filter(Boolean).filter(n=>n.length>2&&!me.has(n)),r=new Map;for(const n of t)r.set(n,(r.get(n)||0)+1);return Array.from(r.entries()).sort((n,o)=>o[1]-n[1]).slice(0,e).map(([n])=>n)}function fe(s){const e=[];typeof s.value=="string"&&e.push(s.value),typeof s.metadata?.title=="string"&&e.push(s.metadata.title),typeof s.metadata?.notePreview=="string"&&e.push(s.metadata.notePreview),typeof s.metadata?.url=="string"&&e.push(s.metadata.url.replace(/^https?:\/\//,"").split(/[/?#]/)[0]);const t=e.join(" ");return he(t)}async function pe(s){try{const e=ye(s),t=await _.saveEvent(e),r=await _.getEventById(t)??{...e,id:t,ts:Date.now(),score:0};let n=[];try{n=await te(r)}catch(o){console.warn("[Pipeline] Failed to generate embeddings, continuing without them:",o)}return{eventId:t,embeddingIds:n,success:!0}}catch(e){const t=e instanceof Error?e.message:String(e);return console.error("[Pipeline] Failed to process memory event:",e),{eventId:"",embeddingIds:[],success:!1,error:t}}}function ye(s){const e=fe(s);if(e.length===0)return s;const t=Array.isArray(s.metadata?.tags)?s.metadata.tags:[],r=Array.from(new Set([...t,...e])).slice(0,10);return{...s,metadata:{...s.metadata||{},tags:r}}}const E=new Map,we=1e3;function ve(s){return`${s.type}:${JSON.stringify(s.value)}:${JSON.stringify(s.metadata||{})}`}function be(s){const e=ve(s),t=E.get(e),r=Date.now();if(t&&r-t<we)return!0;E.set(e,r);for(const[n,o]of E.entries())r-o>5e3&&E.delete(n);return!1}async function b(s){if(be(s))return"";const e=await pe(s);return e.success?e.eventId:(console.warn("[SuperMemory] Failed to process event:",e.error),"")}async function Ce(s,e,t){return b({type:"visit",value:s,metadata:{url:s,title:e,...t}})}async function ke(s,e){return b({type:"bookmark",value:s,metadata:{url:s,...e}})}async function Fe(s,e){const t=e?.notePreview||"";return b({type:"note",value:s,metadata:{url:s,noteLength:t.length,notePreview:t.substring(0,200),...e}})}async function ze(s,e){return b({type:"action",value:s,metadata:e})}async function Ne(s,e){return b({type:"task",value:s,metadata:{...e}})}async function je(s,e){return b({type:"agent",value:s,metadata:{...e}})}const R="http://localhost:8000/huggingface",Se="sentence-transformers/all-MiniLM-L6-v2",F=384;async function Ee(s,e=Se){try{const t=await fetch(`${R}/embedding`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({text:s,model:e})});if(!t.ok){const n=await t.text();throw new Error(`Hugging Face API error: ${n}`)}return(await t.json()).embedding}catch(t){return console.error("[HuggingFace] Failed to generate embedding:",t),Ie(s)}}function Ie(s){const e=new Array(F).fill(0),t=s.toLowerCase().split(/\s+/);for(let n=0;n<t.length;n++){const o=t[n];let a=0;for(let c=0;c<o.length;c++)a=(a<<5)-a+o.charCodeAt(c),a=a&a;const i=Math.abs(a)%F;e[i]+=1/(n+1)}const r=Math.sqrt(e.reduce((n,o)=>n+o*o,0));if(r>0)for(let n=0;n<e.length;n++)e[n]/=r;return e}async function _e(){try{const s=await fetch(`${R}/status`,{method:"GET"});return s.ok?(await s.json()).available===!0:!1}catch(s){return console.debug("[HuggingFace] API check failed:",s),!1}}const De=Object.freeze(Object.defineProperty({__proto__:null,checkHuggingFaceAvailable:_e,generateHuggingFaceEmbedding:Ee},Symbol.toStringTag,{value:"Module"}));var Be={};async function Pe(s){try{const e=new Map;for(const n of s){const o=n.type;e.has(o)||e.set(o,[]),e.get(o).push(n)}const t=[];for(const[n,o]of e.entries()){t.push(`
${n} events (${o.length}):`);for(const a of o.slice(0,10)){const i=typeof a.value=="string"?a.value:JSON.stringify(a.value),c=a.metadata?.title||a.metadata?.url||i;t.push(`- ${c}`)}o.length>10&&t.push(`... and ${o.length-10} more`)}const r=t.join(`
`);try{const n=Be.VITE_API_URL||"http://localhost:8000",o=await fetch(`${n}/redix/ask`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({prompt:`You are a personal memory assistant. Summarize these memory events in 2-3 concise sentences, highlighting key activities, patterns, and insights:

${r}

Provide a natural, human-readable summary.`,stream:!1,session_id:"memory-summarizer"})});if(o.ok){const a=await o.json(),i=a.response||a.text||a.answer||"";if(i&&i.length>20)return i}try{const a=await fetch(`${n}/openai/chat`,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify({messages:[{role:"system",content:"You are a personal memory assistant that creates concise, insightful summaries of user activities."},{role:"user",content:`Summarize these memory events in 2-3 sentences:

${r}`}],model:"gpt-4o-mini",temperature:.5})});if(a.ok){const i=await a.json(),c=i.response||i.text||"";if(c&&c.length>20)return c}}catch(a){console.debug("[Summarizer] OpenAI endpoint failed:",a)}}catch(n){console.warn("[Summarizer] AI summarization failed, using fallback:",n)}return z(s)}catch(e){return console.error("[Summarizer] Summarization failed:",e),z(s)}}function z(s){const e=new Map,t=new Set,r=new Set;for(const o of s)e.set(o.type,(e.get(o.type)||0)+1),o.metadata?.url&&t.add(o.metadata.url),o.type==="search"&&typeof o.value=="string"&&r.add(o.value);const n=[];n.push(`Summary of ${s.length} events:`);for(const[o,a]of e.entries())n.push(`${a} ${o} events`);return t.size>0&&n.push(`${t.size} unique URLs visited`),r.size>0&&n.push(`${r.size} search queries`),n.join(". ")+"."}async function I(s,e="daily"){if(s.length===0)throw new Error("No events to compress");const t=[...s].sort((c,d)=>c.ts-d.ts),r=t[0].ts,n=t[t.length-1].ts,o=await Pe(t),a=new Set;for(const c of t)if(c.metadata?.tags)for(const d of c.metadata.tags)a.add(d);const i={id:`summary-${r}-${n}`,type:e,periodStart:r,periodEnd:n,summary:o,eventCount:t.length,eventIds:t.map(c=>c.id),tags:Array.from(a),createdAt:Date.now()};return await Me(i),i}async function Me(s){try{await f.init();const e=f.db;if(!e)throw new Error("Database not initialized");return new Promise((t,r)=>{const o=e.transaction(["events"],"readwrite").objectStore("events"),a={id:s.id,type:"summary",value:s.summary,metadata:{summaryType:s.type,periodStart:s.periodStart,periodEnd:s.periodEnd,eventCount:s.eventCount,eventIds:s.eventIds,tags:s.tags},ts:s.createdAt,score:1},i=o.put(a);i.onsuccess=()=>{try{const c=JSON.parse(localStorage.getItem("sm-summaries")||"[]");c.push(s),c.length>100&&c.splice(0,c.length-100),localStorage.setItem("sm-summaries",JSON.stringify(c))}catch(c){console.warn("[Summarizer] Failed to save to localStorage:",c)}t()},i.onerror=()=>r(i.error)})}catch(e){console.error("[Summarizer] Failed to save summary:",e);try{const t=JSON.parse(localStorage.getItem("sm-summaries")||"[]");t.push(s),t.length>100&&t.splice(0,t.length-100),localStorage.setItem("sm-summaries",JSON.stringify(t))}catch(t){console.error("[Summarizer] Failed to save summary to localStorage:",t)}}}async function Te(s){try{const t=JSON.parse(localStorage.getItem("sm-summaries")||"[]").sort((r,n)=>n.createdAt-r.createdAt);return s?t.slice(0,s):t}catch(e){return console.error("[Summarizer] Failed to get summaries:",e),[]}}async function x(){try{const s=Date.now(),e=s-1440*60*1e3,t=s-10080*60*1e3,r=s-720*60*60*1e3,o=(await f.getEvents({until:t,limit:1e3})).filter(m=>!m.metadata?.pinned);if(o.length===0)return{success:!0,summariesCreated:0,eventsCompressed:0};const a=[],i=[],c=[];for(const m of o)m.ts>=e||(m.ts>=t?a.push(m):m.ts>=r?i.push(m):c.push(m));let d=0,l=0;if(a.length>0){const m=new Map;for(const h of a){const u=new Date(h.ts).setHours(0,0,0,0);m.has(u)||m.set(u,[]),m.get(u).push(h)}for(const[h,u]of m.entries())if(u.length>=5)try{await I(u,"daily"),d++,l+=u.length;for(const g of u)await f.deleteEvent(g.id)}catch(g){console.error(`[Summarizer] Failed to compress daily events for ${new Date(h).toISOString()}:`,g)}}if(i.length>0){const m=new Map;for(const h of i){const u=new Date(h.ts);u.setDate(u.getDate()-u.getDay()),u.setHours(0,0,0,0);const g=u.getTime();m.has(g)||m.set(g,[]),m.get(g).push(h)}for(const[h,u]of m.entries())if(u.length>=10)try{await I(u,"weekly"),d++,l+=u.length;for(const g of u)await f.deleteEvent(g.id)}catch(g){console.error(`[Summarizer] Failed to compress weekly events for ${new Date(h).toISOString()}:`,g)}}if(c.length>0){const m=new Map;for(const h of c){const u=new Date(h.ts);u.setDate(1),u.setHours(0,0,0,0);const g=u.getTime();m.has(g)||m.set(g,[]),m.get(g).push(h)}for(const[h,u]of m.entries())if(u.length>=20)try{await I(u,"monthly"),d++,l+=u.length;for(const g of u)await f.deleteEvent(g.id)}catch(g){console.error(`[Summarizer] Failed to compress monthly events for ${new Date(h).toISOString()}:`,g)}}return{success:!0,summariesCreated:d,eventsCompressed:l}}catch(s){return console.error("[Summarizer] Nightly summarization failed:",s),{success:!1,summariesCreated:0,eventsCompressed:0}}}function T(){const s=localStorage.getItem("sm-last-summary-run"),e=Date.now(),t=1440*60*1e3;if(!s||e-parseInt(s,10)>t){setTimeout(()=>{x().then(o=>{console.log("[Summarizer] Nightly summarization completed:",o),localStorage.setItem("sm-last-summary-run",e.toString()),o.summariesCreated>0&&window.dispatchEvent(new CustomEvent("memory-summarized",{detail:{summariesCreated:o.summariesCreated,eventsCompressed:o.eventsCompressed}}))}).catch(o=>{console.error("[Summarizer] Nightly summarization error:",o)})},5e3);const n=e+t-e;setTimeout(()=>{T()},n)}else{const r=parseInt(s,10)+t,n=Math.max(0,r-e);setTimeout(()=>{T()},n)}}async function xe(){console.log("[Summarizer] Manual summarization triggered");const s=await x();return localStorage.setItem("sm-last-summary-run",Date.now().toString()),s}const $e=Object.freeze(Object.defineProperty({__proto__:null,compressEvents:I,getSummaries:Te,initNightlySummarization:T,runNightlySummarization:x,triggerSummarization:xe},Symbol.toStringTag,{value:"Module"}));export{_ as M,Fe as a,ke as b,Ne as c,f as d,Ce as e,je as f,$e as g,pe as p,Oe as s,ze as t};
//# sourceMappingURL=core-memory-DmK-uh9X.js.map
