{"version":3,"mappings":";8PAMA,MAAMA,EAAmB,GACnBC,EAAkB,GAClBC,EAAgB,IAEhBC,EAAiB,IAEvB,IAAIC,EAA6D,KAa1D,SAASC,GAAqC,CACnD,GAAI,OAAO,QAAY,KAAe,CAAC,QAAQ,YAAa,CAE1D,GAAI,OAAO,YAAgB,KAAgB,YAAoB,OAAQ,CACrE,MAAMC,EAAO,YAAoB,OAC3BC,EAAQD,EAAI,iBAAmBA,EAAI,gBACnCE,EAAOF,EAAI,eACjB,MAAO,CACL,SAAUE,EACV,UAAWD,EACX,SAAU,EACV,IAAKC,EACL,WAAYD,EAAQ,EAAIC,EAAOD,EAAQ,EAE3C,CACA,OAAO,IACT,CAEA,MAAMD,EAAM,QAAQ,cACdC,EAAQD,EAAI,UAAYA,EAAI,SAC5BE,EAAOF,EAAI,SAAWA,EAAI,SAEhC,MAAO,CACL,SAAUA,EAAI,SACd,UAAWA,EAAI,UACf,SAAUA,EAAI,SACd,IAAKA,EAAI,IACT,WAAYC,EAAQ,EAAIC,EAAOD,EAAQ,EAE3C,CAcO,SAASE,EAAsBC,EAA0BC,EAA+B,CACzFP,GACFQ,EAAA,EAGFR,EAAsB,YAAY,IAAM,CACtC,MAAMS,EAAQR,EAAA,EACd,GAAI,CAACQ,EAAO,OAGZ,MAAMC,EAAQD,EAAM,KAAO,KAAO,KAAO,MAErCC,EAAQZ,GAAiBW,EAAM,YAAcZ,GAE/C,QAAQ,KACN,oCAAoCa,EAAM,QAAQ,CAAC,CAAC,QAAQD,EAAM,WAAa,KAAK,QAAQ,CAAC,CAAC,MAEhGF,IAAA,GACSE,EAAM,YAAcb,IAE7B,QAAQ,KACN,+BAA+Bc,EAAM,QAAQ,CAAC,CAAC,QAAQD,EAAM,WAAa,KAAK,QAAQ,CAAC,CAAC,MAE3FH,IAAA,EAEJ,EAAGP,CAAc,CACnB,CAKO,SAASS,GAA6B,CACvCR,IACF,cAAcA,CAAmB,EACjCA,EAAsB,KAE1B,CAKA,eAAsBW,GAAsC,CAC1D,GAAI,CACF,KAAM,CAAE,aAAAC,CAAA,EAAiB,MAAAC,EAAA,6BAAAD,GAAA,KAAM,QAAO,uBAAuB,OAAAE,KAAA,uBAAAF,CAAA,qCACvDG,EAAYH,EAAa,WACzBI,EAAOD,EAAU,KACjBE,EAAWF,EAAU,SAGrBG,EAAeF,EAAK,OAAOG,GAAOA,EAAI,KAAOF,GAAY,CAACE,EAAI,QAAU,CAACA,EAAI,QAAQ,EAE3F,GAAID,EAAa,SAAW,EAAG,MAAO,GAGtC,MAAME,EAAeF,EAClB,KAAK,CAACG,EAAGC,KAAOD,EAAE,cAAgB,IAAMC,EAAE,cAAgB,EAAE,EAC5D,MAAM,EAAG,CAAC,EAEb,IAAIC,EAAgB,EACpB,UAAWJ,KAAOC,EAChB,GAAI,CAEF,KAAM,CAAE,aAAAR,GAAiB,MAAAC,EAAA,6BAAAW,CAAA,OAAM,QAAO,uBAAuB,OAAAV,KAAA,uBAAAU,CAAA,qCAC7DZ,EAAa,WAAW,UAAUO,EAAI,GAAI,CAAE,SAAU,GAAM,EAC5DI,GACF,OAASE,EAAO,CACd,QAAQ,KAAK,wCAAwCN,EAAI,EAAE,IAAKM,CAAK,CACvE,CAGF,eAAQ,IAAI,4BAA4BF,CAAa,sBAAsB,EACpEA,CACT,OAASE,EAAO,CACd,eAAQ,MAAM,yCAA0CA,CAAK,EACtD,CACT,CACF","names":["MEMORY_THRESHOLD","MEMORY_CRITICAL","MEMORY_MAX_GB","CHECK_INTERVAL","memoryCheckInterval","getMemoryUsage","mem","total","used","startMemoryMonitoring","onLowMemory","onCritical","stopMemoryMonitoring","stats","rssGB","unloadInactiveTabs","useTabsStore","__vitePreload","n","tabsState","tabs","activeId","inactiveTabs","tab","tabsToUnload","a","b","unloadedCount","useTabsStore2","error"],"ignoreList":[],"sources":["../../src/core/monitoring/memoryMonitor.ts"],"sourcesContent":["/**\n * Memory Monitor\n * Tracks RAM usage and auto-unloads tabs when memory is low\n */\n\n// PR: Telepathy Upgrade - Aggressive lag fixes\nconst MEMORY_THRESHOLD = 0.8; // 80% of available memory\nconst MEMORY_CRITICAL = 0.9; // 90% - aggressive cleanup\nconst MEMORY_MAX_GB = 2.5; // Max 2.5GB (down from 3GB) - Telepathy upgrade\nconst _VISION_DISABLE_THRESHOLD_GB = 6.0; // Auto-disable vision mode under 6GB RAM\nconst CHECK_INTERVAL = 5000; // Check every 5 seconds\n\nlet memoryCheckInterval: ReturnType<typeof setInterval> | null = null;\n\nexport interface MemoryStats {\n  heapUsed: number;\n  heapTotal: number;\n  external: number;\n  rss: number;\n  percentage: number;\n}\n\n/**\n * Get current memory usage\n */\nexport function getMemoryUsage(): MemoryStats | null {\n  if (typeof process === 'undefined' || !process.memoryUsage) {\n    // Browser environment - use performance.memory if available\n    if (typeof performance !== 'undefined' && (performance as any).memory) {\n      const mem = (performance as any).memory;\n      const total = mem.jsHeapSizeLimit || mem.totalJSHeapSize;\n      const used = mem.usedJSHeapSize;\n      return {\n        heapUsed: used,\n        heapTotal: total,\n        external: 0,\n        rss: used,\n        percentage: total > 0 ? used / total : 0,\n      };\n    }\n    return null;\n  }\n\n  const mem = process.memoryUsage();\n  const total = mem.heapTotal + mem.external;\n  const used = mem.heapUsed + mem.external;\n\n  return {\n    heapUsed: mem.heapUsed,\n    heapTotal: mem.heapTotal,\n    external: mem.external,\n    rss: mem.rss,\n    percentage: total > 0 ? used / total : 0,\n  };\n}\n\n/**\n * Check if memory is low\n */\nexport function isMemoryLow(): boolean {\n  const stats = getMemoryUsage();\n  if (!stats) return false;\n  return stats.percentage >= MEMORY_THRESHOLD;\n}\n\n/**\n * Start memory monitoring\n */\nexport function startMemoryMonitoring(onLowMemory?: () => void, onCritical?: () => void): void {\n  if (memoryCheckInterval) {\n    stopMemoryMonitoring();\n  }\n\n  memoryCheckInterval = setInterval(() => {\n    const stats = getMemoryUsage();\n    if (!stats) return;\n\n    // Check absolute memory (RSS) for 4GB devices\n    const rssGB = stats.rss / (1024 * 1024 * 1024);\n\n    if (rssGB > MEMORY_MAX_GB || stats.percentage >= MEMORY_CRITICAL) {\n      // Critical: >3GB RSS or >90% memory\n      console.warn(\n        `[MemoryMonitor] Critical memory: ${rssGB.toFixed(2)}GB (${(stats.percentage * 100).toFixed(1)}%)`\n      );\n      onCritical?.();\n    } else if (stats.percentage >= MEMORY_THRESHOLD) {\n      // Low: >80% memory\n      console.warn(\n        `[MemoryMonitor] Low memory: ${rssGB.toFixed(2)}GB (${(stats.percentage * 100).toFixed(1)}%)`\n      );\n      onLowMemory?.();\n    }\n  }, CHECK_INTERVAL);\n}\n\n/**\n * Stop memory monitoring\n */\nexport function stopMemoryMonitoring(): void {\n  if (memoryCheckInterval) {\n    clearInterval(memoryCheckInterval);\n    memoryCheckInterval = null;\n  }\n}\n\n/**\n * Unload inactive tabs to free memory\n */\nexport async function unloadInactiveTabs(): Promise<number> {\n  try {\n    const { useTabsStore } = await import('../../state/tabsStore');\n    const tabsState = useTabsStore.getState();\n    const tabs = tabsState.tabs;\n    const activeId = tabsState.activeId;\n\n    // Find inactive tabs (not active, not pinned)\n    const inactiveTabs = tabs.filter(tab => tab.id !== activeId && !tab.pinned && !tab.sleeping);\n\n    if (inactiveTabs.length === 0) return 0;\n\n    // Unload oldest inactive tabs (up to 3)\n    const tabsToUnload = inactiveTabs\n      .sort((a, b) => (a.lastActiveAt || 0) - (b.lastActiveAt || 0))\n      .slice(0, 3);\n\n    let unloadedCount = 0;\n    for (const tab of tabsToUnload) {\n      try {\n        // Mark tab as sleeping (will be handled by tab suspension service)\n        const { useTabsStore } = await import('../../state/tabsStore');\n        useTabsStore.getState().updateTab(tab.id, { sleeping: true });\n        unloadedCount++;\n      } catch (error) {\n        console.warn(`[MemoryMonitor] Failed to unload tab ${tab.id}:`, error);\n      }\n    }\n\n    console.log(`[MemoryMonitor] Unloaded ${unloadedCount} tabs to free memory`);\n    return unloadedCount;\n  } catch (error) {\n    console.error('[MemoryMonitor] Failed to unload tabs:', error);\n    return 0;\n  }\n}\n"],"file":"memoryMonitor-BGCXgiUi.js"}