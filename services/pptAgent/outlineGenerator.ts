/**
 * Outline Generator
 * Uses LLM to create presentation structure from prompt
 */

import { getCachedLLMClient } from '../llmClient';
import type { PresentationOutline, SlideContent } from './types';

export class OutlineGenerator {
  /**
   * Generate presentation outline from prompt
   */
  async generateOutline(
    prompt: string,
    options?: {
      slideCount?: number;
      theme?: string;
    }
  ): Promise<PresentationOutline> {
    const targetSlides = options?.slideCount || 10;
    const theme = options?.theme || 'professional';

    try {
      const client = getCachedLLMClient();
      const llmPrompt = this.buildPrompt(prompt, targetSlides, theme);

      const response = await client.chat.completions.create({
        model: process.env.ANTHROPIC_MODEL || 'claude-haiku-4.5',
        messages: [{ role: 'user', content: llmPrompt }],
        temperature: 0.7,
        max_tokens: 2048,
      });

      const content = response.choices[0]?.message?.content || '';
      const outline = this.parseOutline(content, prompt);

      console.log(`[OutlineGenerator] Generated ${outline.slides.length} slides`);
      return outline;
    } catch (error) {
      console.warn('[OutlineGenerator] LLM failed, using template:', error);
      return this.generateTemplateOutline(prompt, targetSlides);
    }
  }

  /**
   * Build LLM prompt for outline generation
   */
  private buildPrompt(prompt: string, slideCount: number, theme: string): string {
    return `You are a presentation designer. Create a ${slideCount}-slide presentation outline for:

"${prompt}"

Theme: ${theme}

Return a JSON structure with:
{
  "title": "Presentation Title",
  "subtitle": "Subtitle",
  "slides": [
    {
      "slideNumber": 1,
      "type": "title",
      "title": "Main Title",
      "content": ["Subtitle or tagline"],
      "notes": "Speaker notes"
    },
    {
      "slideNumber": 2,
      "type": "content",
      "title": "Slide Title",
      "content": ["Bullet point 1", "Bullet point 2", "Bullet point 3"],
      "imageQuery": "relevant image search term",
      "notes": "What to say"
    }
  ]
}

Slide types: title, content, image, quote, closing
Keep content concise (3-5 bullet points max)
Include relevant imageQuery for visual slides
Provide speaker notes for each slide

Return ONLY valid JSON, no markdown formatting.`;
  }

  /**
   * Parse LLM response into outline
   */
  private parseOutline(llmResponse: string, prompt: string): PresentationOutline {
    try {
      // Remove markdown code blocks if present
      const cleaned = llmResponse
        .replace(/```json\n?/g, '')
        .replace(/```\n?/g, '')
        .trim();

      const parsed = JSON.parse(cleaned);

      return {
        title: parsed.title || this.extractTitle(prompt),
        subtitle: parsed.subtitle || '',
        slides: parsed.slides || [],
        totalSlides: parsed.slides?.length || 0,
        estimatedDuration: Math.ceil((parsed.slides?.length || 0) * 1.5), // ~1.5 min/slide
      };
    } catch (error) {
      console.error('[OutlineGenerator] Parse error:', error);
      throw new Error('Failed to parse outline from LLM response');
    }
  }

  /**
   * Fallback: template-based outline
   */
  private generateTemplateOutline(prompt: string, slideCount: number): PresentationOutline {
    const title = this.extractTitle(prompt);
    const slides: SlideContent[] = [];

    // Title slide
    slides.push({
      slideNumber: 1,
      type: 'title',
      title,
      content: ['Generated Presentation'],
      notes: 'Welcome and introduction',
    });

    // Content slides
    for (let i = 2; i < slideCount; i++) {
      slides.push({
        slideNumber: i,
        type: 'content',
        title: `Topic ${i - 1}`,
        content: [
          'Key point about this topic',
          'Supporting detail or example',
          'Additional context',
        ],
        imageQuery: prompt.split(' ').slice(0, 3).join(' '),
        notes: `Discuss topic ${i - 1} in detail`,
      });
    }

    // Closing slide
    slides.push({
      slideNumber: slideCount,
      type: 'closing',
      title: 'Thank You',
      content: ['Questions?'],
      notes: 'Open for Q&A',
    });

    return {
      title,
      subtitle: 'Generated by Regen AI',
      slides,
      totalSlides: slideCount,
      estimatedDuration: Math.ceil(slideCount * 1.5),
    };
  }

  /**
   * Extract title from prompt
   */
  private extractTitle(prompt: string): string {
    // Simple heuristic: capitalize first few words
    const words = prompt.split(' ').slice(0, 6);
    return words
      .map((w) => w.charAt(0).toUpperCase() + w.slice(1))
      .join(' ');
  }

  /**
   * Validate outline structure
   */
  validateOutline(outline: PresentationOutline): boolean {
    if (!outline.title || outline.slides.length === 0) {
      return false;
    }

    // Must have title slide
    const hasTitle = outline.slides.some((s) => s.type === 'title');
    if (!hasTitle) {
      return false;
    }

    // All slides must have titles
    const allHaveTitles = outline.slides.every((s) => s.title && s.title.length > 0);
    if (!allHaveTitles) {
      return false;
    }

    return true;
  }
}

export function createOutlineGenerator(): OutlineGenerator {
  return new OutlineGenerator();
}
