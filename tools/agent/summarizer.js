#!/usr/bin/env node
/**
 * Summarizer Agent - Example streaming agent
 * Subscribes to agent.requests, streams summaries to agent.summaries.<id>
 * PR: Realtime agent example
 */

const WebSocket = require('ws');

const BUS_URL = process.env.BUS_URL || 'ws://localhost:4002';
const REQUEST_CHANNEL = 'agent.requests';
const SUMMARY_CHANNEL_PREFIX = 'agent.summaries';

let ws = null;
let reconnectTimer = null;
let isConnected = false;

/**
 * Connect to bus
 */
function connect() {
  if (ws && ws.readyState === WebSocket.OPEN) {
    return;
  }

  console.log(`[Summarizer] Connecting to bus: ${BUS_URL}`);

  ws = new WebSocket(BUS_URL);

  ws.on('open', () => {
    isConnected = true;
    console.log('[Summarizer] Connected to bus');

    // Subscribe to request channel
    ws.send(
      JSON.stringify({
        type: 'subscribe',
        channel: REQUEST_CHANNEL,
      })
    );

    // Clear reconnect timer
    if (reconnectTimer) {
      clearTimeout(reconnectTimer);
      reconnectTimer = null;
    }
  });

  ws.on('message', data => {
    try {
      const message = JSON.parse(data.toString());
      handleMessage(message);
    } catch (error) {
      console.error('[Summarizer] Message parse error:', error);
    }
  });

  ws.on('error', error => {
    console.error('[Summarizer] WebSocket error:', error);
    isConnected = false;
  });

  ws.on('close', () => {
    isConnected = false;
    console.log('[Summarizer] Disconnected, reconnecting in 3s...');

    // Reconnect after delay
    reconnectTimer = setTimeout(() => {
      connect();
    }, 3000);
  });
}

/**
 * Handle incoming messages
 */
function handleMessage(message) {
  if (message.type === 'connected') {
    console.log(`[Summarizer] Connected as ${message.clientId}`);
    return;
  }

  if (message.type === 'subscribed') {
    console.log(`[Summarizer] Subscribed to ${message.channel}`);
    return;
  }

  if (message.type === 'message' && message.channel === REQUEST_CHANNEL) {
    const request = message.data;
    handleSummarizeRequest(request);
  }
}

/**
 * Handle summarize request
 */
async function handleSummarizeRequest(request) {
  const { id, query, content, url } = request;

  if (!id) {
    console.warn('[Summarizer] Request missing id');
    return;
  }

  console.log(`[Summarizer] Processing request ${id}: ${query || 'summarize'}`);

  const summaryChannel = `${SUMMARY_CHANNEL_PREFIX}.${id}`;

  // Subscribe to summary channel (for potential cancellation)
  ws.send(
    JSON.stringify({
      type: 'subscribe',
      channel: summaryChannel,
    })
  );

  // Start streaming summary
  await streamSummary(summaryChannel, {
    id,
    query,
    content: content || `Content from ${url || 'unknown'}`,
    url,
  });
}

/**
 * Stream summary (simulated token streaming)
 */
async function streamSummary(channel, context) {
  const { id, query, content, url } = context;

  // Simulate LLM streaming with chunks
  const summaryText = generateSummary(content, query);
  const chunks = chunkText(summaryText, 10); // 10 tokens per chunk

  // Send start event
  publish(channel, {
    type: 'start',
    requestId: id,
    query,
    url,
    timestamp: Date.now(),
  });

  // Stream chunks with delay
  for (let i = 0; i < chunks.length; i++) {
    await delay(50 + Math.random() * 50); // 50-100ms per chunk

    publish(channel, {
      type: 'chunk',
      requestId: id,
      chunk: chunks[i],
      index: i,
      total: chunks.length,
      isFinal: i === chunks.length - 1,
    });
  }

  // Send completion event
  publish(channel, {
    type: 'complete',
    requestId: id,
    summary: summaryText,
    timestamp: Date.now(),
  });

  console.log(`[Summarizer] Completed request ${id}`);
}

/**
 * Generate summary (mock LLM)
 */
function generateSummary(content, query) {
  const words = content.split(/\s+/).slice(0, 100); // First 100 words
  const preview = words.join(' ');

  if (query) {
    return `Summary for "${query}": ${preview}... [This is a mock summary. In production, this would call Ollama/HF/OpenAI streaming API.]`;
  }

  return `Summary: ${preview}... [This is a mock summary generated by the summarizer agent.]`;
}

/**
 * Chunk text for streaming
 */
function chunkText(text, tokensPerChunk = 10) {
  const words = text.split(/\s+/);
  const chunks = [];

  for (let i = 0; i < words.length; i += tokensPerChunk) {
    chunks.push(words.slice(i, i + tokensPerChunk).join(' '));
  }

  return chunks;
}

/**
 * Publish message to channel
 */
function publish(channel, data) {
  if (!isConnected || !ws || ws.readyState !== WebSocket.OPEN) {
    console.warn('[Summarizer] Cannot publish, not connected');
    return;
  }

  ws.send(
    JSON.stringify({
      type: 'publish',
      channel,
      data,
    })
  );
}

/**
 * Delay helper
 */
function delay(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

/**
 * Start agent
 */
console.log('ðŸ¤– Summarizer Agent starting...');
console.log(`ðŸ“¡ Bus URL: ${BUS_URL}`);
console.log(`ðŸ“¥ Subscribing to: ${REQUEST_CHANNEL}`);
console.log(`ðŸ“¤ Publishing to: ${SUMMARY_CHANNEL_PREFIX}.*`);

connect();

// Keep process alive
process.on('SIGTERM', () => {
  console.log('[Summarizer] Shutting down...');
  if (ws) {
    ws.close();
  }
  process.exit(0);
});
